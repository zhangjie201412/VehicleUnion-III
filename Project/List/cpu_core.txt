; generated by ARM C/C++ Compiler, 5.02 [Build 28]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\OBJ\cpu_core.o --asm_dir=.\List\ --list_dir=.\List\ --depend=..\OBJ\cpu_core.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\BSP -I..\CORE -I..\STM32F10x_FWLib\inc -I..\USER -I..\UCOSIII\uC-CPU -I..\UCOSIII\uC-CPU\ARM-Cortex-M3\RealView -I..\UCOSIII\uC-LIB -I..\UCOSIII\uC-LIB\Ports\ARM-Cortex-M3\RealView -I..\UCOSIII\uCOS-III -I..\UCOSIII\uCOS-III\Ports -I..\UCOSIII\uCOS-III\Ports\ARM-Cortex-M3\Generic\RealView -I..\UCOSIII\uCOS-III\Source -I..\UCOSIII\UCOS_BSP -I..\UCOSIII\uCOS_CONFIG -I..\UCOSIII-Task -I..\SYSTEM -I..\BSP\inc -I..\PAL -I..\PAL\vehicles -ID:\Keil_v4\ARM\RV31\INC -ID:\Keil_v4\ARM\CMSIS\Include -ID:\Keil_v4\ARM\Inc\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=..\OBJ\cpu_core.crf ..\UCOSIII\uC-CPU\cpu_core.c]
                          THUMB

                          AREA ||i.CPU_CntLeadZeros08||, CODE, READONLY, ALIGN=1

                  CPU_CntLeadZeros08 PROC
;;;1189   #if (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_08)
;;;1190   CPU_DATA  CPU_CntLeadZeros08 (CPU_INT08U  val)
000000  b510              PUSH     {r4,lr}
;;;1191   {
;;;1192   #if  (!((defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) && \
;;;1193           (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_08)))
;;;1194       CPU_DATA  ix;
;;;1195   #endif
;;;1196       CPU_DATA  nbr_lead_zeros;
;;;1197   
;;;1198                                                                                   /* ---------- ASM-OPTIMIZED ----------- */
;;;1199   #if ((defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) && \
;;;1200        (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_08))
;;;1201       nbr_lead_zeros  =  CPU_CntLeadZeros((CPU_DATA)val);
000002  f7fffffe          BL       CPU_CntLeadZeros
;;;1202       nbr_lead_zeros -= (CPU_CFG_DATA_SIZE - CPU_WORD_SIZE_08) * DEF_OCTET_NBR_BITS;
000006  3818              SUBS     r0,r0,#0x18
;;;1203   
;;;1204   
;;;1205   #else                                                                           /* ----------- C-OPTIMIZED ------------ */
;;;1206                                                                                   /* Chk bits [07:00] :                   */
;;;1207                                                                                   /* .. Nbr lead zeros =               .. */
;;;1208       ix              = (CPU_DATA)(val >>  0u);                                   /* .. lookup tbl ix  = 'val' >>  0 bits */
;;;1209       nbr_lead_zeros  = (CPU_DATA)(CPU_CntLeadZerosTbl[ix] +  0u);                /* .. plus nbr msb lead zeros =  0 bits.*/
;;;1210   #endif
;;;1211   
;;;1212   
;;;1213       return (nbr_lead_zeros);
;;;1214   }
000008  bd10              POP      {r4,pc}
;;;1215   #endif
                          ENDP


                          AREA ||i.CPU_CntLeadZeros16||, CODE, READONLY, ALIGN=1

                  CPU_CntLeadZeros16 PROC
;;;1256   #if (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_16)
;;;1257   CPU_DATA  CPU_CntLeadZeros16 (CPU_INT16U  val)
000000  b510              PUSH     {r4,lr}
;;;1258   {
;;;1259   #if  (!((defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) && \
;;;1260           (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_16)))
;;;1261       CPU_DATA  ix;
;;;1262   #endif
;;;1263       CPU_DATA  nbr_lead_zeros;
;;;1264   
;;;1265                                                                                   /* ---------- ASM-OPTIMIZED ----------- */
;;;1266   #if ((defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) && \
;;;1267        (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_16))
;;;1268       nbr_lead_zeros  =  CPU_CntLeadZeros((CPU_DATA)val);
000002  f7fffffe          BL       CPU_CntLeadZeros
;;;1269       nbr_lead_zeros -= (CPU_CFG_DATA_SIZE - CPU_WORD_SIZE_16) * DEF_OCTET_NBR_BITS;
000006  3810              SUBS     r0,r0,#0x10
;;;1270   
;;;1271   
;;;1272   #else                                                                           /* ----------- C-OPTIMIZED ------------ */
;;;1273       if (val > 0x00FFu) {                                                        /* Chk bits [15:08] :                   */
;;;1274                                                                                   /* .. Nbr lead zeros =               .. */
;;;1275           ix             = (CPU_DATA)(val >>  8u);                                /* .. lookup tbl ix  = 'val' >>  8 bits */
;;;1276           nbr_lead_zeros = (CPU_DATA)(CPU_CntLeadZerosTbl[ix] +  0u);             /* .. plus nbr msb lead zeros =  0 bits.*/
;;;1277   
;;;1278       } else {                                                                    /* Chk bits [07:00] :                   */
;;;1279                                                                                   /* .. Nbr lead zeros =               .. */
;;;1280           ix             = (CPU_DATA)(val >>  0u);                                /* .. lookup tbl ix  = 'val' >>  0 bits */
;;;1281           nbr_lead_zeros = (CPU_DATA)(CPU_CntLeadZerosTbl[ix] +  8u);             /* .. plus nbr msb lead zeros =  8 bits.*/
;;;1282       }
;;;1283   #endif
;;;1284   
;;;1285   
;;;1286       return (nbr_lead_zeros);
;;;1287   }
000008  bd10              POP      {r4,pc}
;;;1288   #endif
                          ENDP


                          AREA ||i.CPU_CntLeadZeros32||, CODE, READONLY, ALIGN=1

                  CPU_CntLeadZeros32 PROC
;;;1329   #if (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_32)
;;;1330   CPU_DATA  CPU_CntLeadZeros32 (CPU_INT32U  val)
000000  f7ffbffe          B.W      CPU_CntLeadZeros
;;;1331   {
;;;1332   #if  (!((defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) && \
;;;1333           (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_32)))
;;;1334       CPU_DATA  ix;
;;;1335   #endif
;;;1336       CPU_DATA  nbr_lead_zeros;
;;;1337   
;;;1338                                                                                   /* ---------- ASM-OPTIMIZED ----------- */
;;;1339   #if ((defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) && \
;;;1340        (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_32))
;;;1341       nbr_lead_zeros  =  CPU_CntLeadZeros((CPU_DATA)val);
;;;1342       nbr_lead_zeros -= (CPU_CFG_DATA_SIZE - CPU_WORD_SIZE_32) * DEF_OCTET_NBR_BITS;
;;;1343   
;;;1344   
;;;1345   #else                                                                           /* ----------- C-OPTIMIZED ------------ */
;;;1346       if (val > 0x0000FFFFu) {
;;;1347           if (val > 0x00FFFFFFu) {                                                /* Chk bits [31:24] :                   */
;;;1348                                                                                   /* .. Nbr lead zeros =               .. */
;;;1349               ix             = (CPU_DATA)(val >> 24u);                            /* .. lookup tbl ix  = 'val' >> 24 bits */
;;;1350               nbr_lead_zeros = (CPU_DATA)(CPU_CntLeadZerosTbl[ix] +  0u);         /* .. plus nbr msb lead zeros =  0 bits.*/
;;;1351   
;;;1352           } else {                                                                /* Chk bits [23:16] :                   */
;;;1353                                                                                   /* .. Nbr lead zeros =               .. */
;;;1354               ix             = (CPU_DATA)(val >> 16u);                            /* .. lookup tbl ix  = 'val' >> 16 bits */
;;;1355               nbr_lead_zeros = (CPU_DATA)(CPU_CntLeadZerosTbl[ix] +  8u);         /* .. plus nbr msb lead zeros =  8 bits.*/
;;;1356           }
;;;1357   
;;;1358       } else {
;;;1359           if (val > 0x000000FFu) {                                                /* Chk bits [15:08] :                   */
;;;1360                                                                                   /* .. Nbr lead zeros =               .. */
;;;1361               ix             = (CPU_DATA)(val >>  8u);                            /* .. lookup tbl ix  = 'val' >>  8 bits */
;;;1362               nbr_lead_zeros = (CPU_DATA)(CPU_CntLeadZerosTbl[ix] + 16u);         /* .. plus nbr msb lead zeros = 16 bits.*/
;;;1363   
;;;1364           } else {                                                                /* Chk bits [07:00] :                   */
;;;1365                                                                                   /* .. Nbr lead zeros =               .. */
;;;1366               ix             = (CPU_DATA)(val >>  0u);                            /* .. lookup tbl ix  = 'val' >>  0 bits */
;;;1367               nbr_lead_zeros = (CPU_DATA)(CPU_CntLeadZerosTbl[ix] + 24u);         /* .. plus nbr msb lead zeros = 24 bits.*/
;;;1368           }
;;;1369       }
;;;1370   #endif
;;;1371   
;;;1372   
;;;1373       return (nbr_lead_zeros);
;;;1374   }
;;;1375   #endif
                          ENDP


                          AREA ||i.CPU_CntLeadZeros64||, CODE, READONLY, ALIGN=2

                  CPU_CntLeadZeros64 PROC
;;;1416   #if (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_64)
;;;1417   CPU_DATA  CPU_CntLeadZeros64 (CPU_INT64U  val)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1418   {
000002  f04f36ff          MOV      r6,#0xffffffff
;;;1419   #if  (!((defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) && \
;;;1420           (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_64)))
;;;1421       CPU_DATA  ix;
;;;1422   #endif
;;;1423       CPU_DATA  nbr_lead_zeros;
;;;1424   
;;;1425                                                                                   /* ---------- ASM-OPTIMIZED ----------- */
;;;1426   #if ((defined(CPU_CFG_LEAD_ZEROS_ASM_PRESENT)) && \
;;;1427        (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_64))
;;;1428       nbr_lead_zeros  =  CPU_CntLeadZeros((CPU_DATA)val);
;;;1429       nbr_lead_zeros -= (CPU_CFG_DATA_SIZE - CPU_WORD_SIZE_64) * DEF_OCTET_NBR_BITS;
;;;1430   
;;;1431   
;;;1432   #else                                                                           /* ----------- C-OPTIMIZED ------------ */
;;;1433       if (val > 0x00000000FFFFFFFFu) {
;;;1434           if (val > 0x0000FFFFFFFFFFFFu) {
;;;1435               if (val > 0x00FFFFFFFFFFFFFFu) {                                    /* Chk bits [63:56] :                   */
;;;1436                                                                                   /* .. Nbr lead zeros =               .. */
;;;1437                   ix             = (CPU_DATA)(val >> 56u);                        /* .. lookup tbl ix  = 'val' >> 56 bits */
000006  0e0c              LSRS     r4,r1,#24
;;;1438                   nbr_lead_zeros = (CPU_DATA)(CPU_CntLeadZerosTbl[ix] +  0u);     /* .. plus nbr msb lead zeros =  0 bits.*/
;;;1439   
;;;1440               } else {                                                            /* Chk bits [55:48] :                   */
;;;1441                                                                                   /* .. Nbr lead zeros =               .. */
;;;1442                   ix             = (CPU_DATA)(val >> 48u);                        /* .. lookup tbl ix  = 'val' >> 48 bits */
000008  0c0b              LSRS     r3,r1,#16
;;;1443                   nbr_lead_zeros = (CPU_DATA)(CPU_CntLeadZerosTbl[ix] +  8u);     /* .. plus nbr msb lead zeros =  8 bits.*/
;;;1444               }
;;;1445   
;;;1446           } else {
;;;1447               if (val > 0x000000FFFFFFFFFFu) {                                    /* Chk bits [47:40] :                   */
;;;1448                                                                                   /* .. Nbr lead zeros =               .. */
;;;1449                   ix             = (CPU_DATA)(val >> 40u);                        /* .. lookup tbl ix  = 'val' >> 40 bits */
00000a  0a0f              LSRS     r7,r1,#8
00000c  2500              MOVS     r5,#0                 ;1418
00000e  4a23              LDR      r2,|L4.156|
000010  1a36              SUBS     r6,r6,r0              ;1438
000012  418d              SBCS     r5,r5,r1              ;1438
000014  d21c              BCS      |L4.80|
000016  f04f36ff          MOV      r6,#0xffffffff        ;1418
00001a  0c35              LSRS     r5,r6,#16             ;1418
00001c  1a36              SUBS     r6,r6,r0              ;1418
00001e  418d              SBCS     r5,r5,r1              ;1418
000020  d20a              BCS      |L4.56|
000022  f04f36ff          MOV      r6,#0xffffffff        ;1434
000026  0a35              LSRS     r5,r6,#8              ;1434
000028  1a30              SUBS     r0,r6,r0              ;1434
00002a  418d              SBCS     r5,r5,r1              ;1434
00002c  d201              BCS      |L4.50|
00002e  5d10              LDRB     r0,[r2,r4]            ;1438
;;;1450                   nbr_lead_zeros = (CPU_DATA)(CPU_CntLeadZerosTbl[ix] + 16u);     /* .. plus nbr msb lead zeros = 16 bits.*/
;;;1451   
;;;1452               } else {                                                            /* Chk bits [39:32] :                   */
;;;1453                                                                                   /* .. Nbr lead zeros =               .. */
;;;1454                   ix             = (CPU_DATA)(val >> 32u);                        /* .. lookup tbl ix  = 'val' >> 32 bits */
;;;1455                   nbr_lead_zeros = (CPU_DATA)(CPU_CntLeadZerosTbl[ix] + 24u);     /* .. plus nbr msb lead zeros = 24 bits.*/
;;;1456               }
;;;1457           }
;;;1458   
;;;1459       } else {
;;;1460           if (val > 0x000000000000FFFFu) {
;;;1461               if (val > 0x0000000000FFFFFFu) {                                    /* Chk bits [31:24] :                   */
;;;1462                                                                                   /* .. Nbr lead zeros =               .. */
;;;1463                   ix             = (CPU_DATA)(val >> 24u);                        /* .. lookup tbl ix  = 'val' >> 24 bits */
;;;1464                   nbr_lead_zeros = (CPU_DATA)(CPU_CntLeadZerosTbl[ix] + 32u);     /* .. plus nbr msb lead zeros = 32 bits.*/
;;;1465   
;;;1466               } else {                                                            /* Chk bits [23:16] :                   */
;;;1467                                                                                   /* .. Nbr lead zeros =               .. */
;;;1468                   ix             = (CPU_DATA)(val >> 16u);                        /* .. lookup tbl ix  = 'val' >> 16 bits */
;;;1469                   nbr_lead_zeros = (CPU_DATA)(CPU_CntLeadZerosTbl[ix] + 40u);     /* .. plus nbr msb lead zeros = 40 bits.*/
;;;1470               }
;;;1471   
;;;1472           } else {
;;;1473               if (val > 0x00000000000000FFu) {                                    /* Chk bits [15:08] :                   */
;;;1474                                                                                   /* .. Nbr lead zeros =               .. */
;;;1475                   ix             = (CPU_DATA)(val >>  8u);                        /* .. lookup tbl ix  = 'val' >>  8 bits */
;;;1476                   nbr_lead_zeros = (CPU_DATA)(CPU_CntLeadZerosTbl[ix] + 48u);     /* .. plus nbr msb lead zeros = 48 bits.*/
;;;1477   
;;;1478               } else {                                                            /* Chk bits [07:00] :                   */
;;;1479                                                                                   /* .. Nbr lead zeros =               .. */
;;;1480                   ix             = (CPU_DATA)(val >>  0u);                        /* .. lookup tbl ix  = 'val' >>  0 bits */
;;;1481                   nbr_lead_zeros = (CPU_DATA)(CPU_CntLeadZerosTbl[ix] + 56u);     /* .. plus nbr msb lead zeros = 56 bits.*/
;;;1482               }
;;;1483           }
;;;1484       }
;;;1485   #endif
;;;1486   
;;;1487   
;;;1488       return (nbr_lead_zeros);
;;;1489   }
000030  bdf0              POP      {r4-r7,pc}
                  |L4.50|
000032  5cd0              LDRB     r0,[r2,r3]            ;1443
000034  3008              ADDS     r0,r0,#8              ;1443
000036  bdf0              POP      {r4-r7,pc}
                  |L4.56|
000038  f04f34ff          MOV      r4,#0xffffffff
00003c  23ff              MOVS     r3,#0xff
00003e  1a20              SUBS     r0,r4,r0
000040  418b              SBCS     r3,r3,r1
000042  d202              BCS      |L4.74|
000044  5dd0              LDRB     r0,[r2,r7]            ;1450
000046  3010              ADDS     r0,r0,#0x10           ;1450
000048  bdf0              POP      {r4-r7,pc}
                  |L4.74|
00004a  5c50              LDRB     r0,[r2,r1]            ;1455
00004c  3018              ADDS     r0,r0,#0x18           ;1455
00004e  bdf0              POP      {r4-r7,pc}
                  |L4.80|
000050  f64f74ff          MOV      r4,#0xffff
000054  2300              MOVS     r3,#0
000056  1a24              SUBS     r4,r4,r0
000058  418b              SBCS     r3,r3,r1
00005a  d211              BCS      |L4.128|
00005c  f06f447f          MVN      r4,#0xff000000        ;1460
000060  2300              MOVS     r3,#0                 ;1460
000062  1a24              SUBS     r4,r4,r0              ;1460
000064  418b              SBCS     r3,r3,r1              ;1460
000066  d205              BCS      |L4.116|
000068  0e00              LSRS     r0,r0,#24             ;1463
00006a  ea402001          ORR      r0,r0,r1,LSL #8       ;1463
00006e  5c10              LDRB     r0,[r2,r0]            ;1464
000070  3020              ADDS     r0,r0,#0x20           ;1464
000072  bdf0              POP      {r4-r7,pc}
                  |L4.116|
000074  0c00              LSRS     r0,r0,#16             ;1468
000076  ea404001          ORR      r0,r0,r1,LSL #16      ;1468
00007a  5c10              LDRB     r0,[r2,r0]            ;1469
00007c  3028              ADDS     r0,r0,#0x28           ;1469
00007e  bdf0              POP      {r4-r7,pc}
                  |L4.128|
000080  24ff              MOVS     r4,#0xff
000082  2300              MOVS     r3,#0
000084  1a24              SUBS     r4,r4,r0
000086  418b              SBCS     r3,r3,r1
000088  d205              BCS      |L4.150|
00008a  0a00              LSRS     r0,r0,#8              ;1475
00008c  ea406001          ORR      r0,r0,r1,LSL #24      ;1475
000090  5c10              LDRB     r0,[r2,r0]            ;1476
000092  3030              ADDS     r0,r0,#0x30           ;1476
000094  bdf0              POP      {r4-r7,pc}
                  |L4.150|
000096  5c10              LDRB     r0,[r2,r0]            ;1481
000098  3038              ADDS     r0,r0,#0x38           ;1481
00009a  bdf0              POP      {r4-r7,pc}
;;;1490   #endif
                          ENDP

                  |L4.156|
                          DCD      ||.constdata||

                          AREA ||i.CPU_CntTrailZeros08||, CODE, READONLY, ALIGN=1

                  CPU_CntTrailZeros08 PROC
;;;1695   #if (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_08)
;;;1696   CPU_DATA  CPU_CntTrailZeros08 (CPU_INT08U  val)
000000  b108              CBZ      r0,|L5.6|
;;;1697   {
;;;1698   #if  (!((defined(CPU_CFG_TRAIL_ZEROS_ASM_PRESENT)) && \
;;;1699           (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_08)))
;;;1700       CPU_INT08U  val_bit_mask;
;;;1701       CPU_DATA    nbr_lead_zeros;
;;;1702   #endif
;;;1703       CPU_DATA    nbr_trail_zeros;
;;;1704   
;;;1705   
;;;1706       if (val == 0u) {                                            /* Rtn ALL val bits as zero'd (see Note #3).            */
;;;1707           return (CPU_WORD_SIZE_08 * DEF_OCTET_NBR_BITS);
;;;1708       }
;;;1709   
;;;1710                                                                   /* ------------------ ASM-OPTIMIZED ------------------- */
;;;1711   #if ((defined(CPU_CFG_TRAIL_ZEROS_ASM_PRESENT)) && \
;;;1712        (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_08))
;;;1713       nbr_trail_zeros = CPU_CntTrailZeros((CPU_DATA)val);
000002  f7ffbffe          B.W      CPU_CntTrailZeros
                  |L5.6|
000006  2008              MOVS     r0,#8                 ;1707
;;;1714   
;;;1715   #else                                                           /* ------------------- C-OPTIMIZED -------------------- */
;;;1716       val_bit_mask    = val & ((CPU_INT08U)~val + 1u);            /* Zero/clr all bits EXCEPT least-sig set bit.          */
;;;1717       nbr_lead_zeros  = CPU_CntLeadZeros08(val_bit_mask);         /* Cnt  nbr lead  0s.                                   */
;;;1718                                                                   /* Calc nbr trail 0s = (nbr val bits - 1) - nbr lead 0s.*/
;;;1719       nbr_trail_zeros = ((CPU_WORD_SIZE_08 * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
;;;1720   #endif
;;;1721   
;;;1722   
;;;1723       return (nbr_trail_zeros);
;;;1724   }
000008  4770              BX       lr
;;;1725   #endif
                          ENDP


                          AREA ||i.CPU_CntTrailZeros16||, CODE, READONLY, ALIGN=1

                  CPU_CntTrailZeros16 PROC
;;;1799   #if (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_16)
;;;1800   CPU_DATA  CPU_CntTrailZeros16 (CPU_INT16U  val)
000000  b108              CBZ      r0,|L6.6|
;;;1801   {
;;;1802   #if  (!((defined(CPU_CFG_TRAIL_ZEROS_ASM_PRESENT)) && \
;;;1803           (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_16)))
;;;1804       CPU_INT16U  val_bit_mask;
;;;1805       CPU_DATA    nbr_lead_zeros;
;;;1806   #endif
;;;1807       CPU_DATA    nbr_trail_zeros;
;;;1808   
;;;1809   
;;;1810       if (val == 0u) {                                            /* Rtn ALL val bits as zero'd (see Note #3).            */
;;;1811           return (CPU_WORD_SIZE_16 * DEF_OCTET_NBR_BITS);
;;;1812       }
;;;1813   
;;;1814                                                                   /* ------------------ ASM-OPTIMIZED ------------------- */
;;;1815   #if ((defined(CPU_CFG_TRAIL_ZEROS_ASM_PRESENT)) && \
;;;1816        (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_16))
;;;1817       nbr_trail_zeros = CPU_CntTrailZeros((CPU_DATA)val);
000002  f7ffbffe          B.W      CPU_CntTrailZeros
                  |L6.6|
000006  2010              MOVS     r0,#0x10              ;1811
;;;1818   
;;;1819   #else                                                           /* ------------------- C-OPTIMIZED -------------------- */
;;;1820       val_bit_mask    = val & ((CPU_INT16U)~val + 1u);            /* Zero/clr all bits EXCEPT least-sig set bit.          */
;;;1821       nbr_lead_zeros  = CPU_CntLeadZeros16(val_bit_mask);         /* Cnt  nbr lead  0s.                                   */
;;;1822                                                                   /* Calc nbr trail 0s = (nbr val bits - 1) - nbr lead 0s.*/
;;;1823       nbr_trail_zeros = ((CPU_WORD_SIZE_16 * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
;;;1824   #endif
;;;1825   
;;;1826   
;;;1827       return (nbr_trail_zeros);
;;;1828   }
000008  4770              BX       lr
;;;1829   #endif
                          ENDP


                          AREA ||i.CPU_CntTrailZeros32||, CODE, READONLY, ALIGN=1

                  CPU_CntTrailZeros32 PROC
;;;1903   #if (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_32)
;;;1904   CPU_DATA  CPU_CntTrailZeros32 (CPU_INT32U  val)
000000  b108              CBZ      r0,|L7.6|
;;;1905   {
;;;1906   #if  (!((defined(CPU_CFG_TRAIL_ZEROS_ASM_PRESENT)) && \
;;;1907           (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_32)))
;;;1908       CPU_INT32U  val_bit_mask;
;;;1909       CPU_DATA    nbr_lead_zeros;
;;;1910   #endif
;;;1911       CPU_DATA    nbr_trail_zeros;
;;;1912   
;;;1913   
;;;1914       if (val == 0u) {                                            /* Rtn ALL val bits as zero'd (see Note #3).            */
;;;1915           return (CPU_WORD_SIZE_32 * DEF_OCTET_NBR_BITS);
;;;1916       }
;;;1917   
;;;1918                                                                   /* ------------------ ASM-OPTIMIZED ------------------- */
;;;1919   #if ((defined(CPU_CFG_TRAIL_ZEROS_ASM_PRESENT)) && \
;;;1920        (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_32))
;;;1921       nbr_trail_zeros = CPU_CntTrailZeros((CPU_DATA)val);
000002  f7ffbffe          B.W      CPU_CntTrailZeros
                  |L7.6|
000006  2020              MOVS     r0,#0x20              ;1915
;;;1922   
;;;1923   #else                                                           /* ------------------- C-OPTIMIZED -------------------- */
;;;1924       val_bit_mask    = val & ((CPU_INT32U)~val + 1u);            /* Zero/clr all bits EXCEPT least-sig set bit.          */
;;;1925       nbr_lead_zeros  = CPU_CntLeadZeros32(val_bit_mask);         /* Cnt  nbr lead  0s.                                   */
;;;1926                                                                   /* Calc nbr trail 0s = (nbr val bits - 1) - nbr lead 0s.*/
;;;1927       nbr_trail_zeros = ((CPU_WORD_SIZE_32 * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
;;;1928   #endif
;;;1929   
;;;1930   
;;;1931       return (nbr_trail_zeros);
;;;1932   }
000008  4770              BX       lr
;;;1933   #endif
                          ENDP


                          AREA ||i.CPU_CntTrailZeros64||, CODE, READONLY, ALIGN=1

                  CPU_CntTrailZeros64 PROC
;;;2007   #if (CPU_CFG_DATA_SIZE_MAX >= CPU_WORD_SIZE_64)
;;;2008   CPU_DATA  CPU_CntTrailZeros64 (CPU_INT64U  val)
000000  b500              PUSH     {lr}
;;;2009   {
;;;2010   #if  (!((defined(CPU_CFG_TRAIL_ZEROS_ASM_PRESENT)) && \
;;;2011           (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_64)))
;;;2012       CPU_INT64U  val_bit_mask;
;;;2013       CPU_DATA    nbr_lead_zeros;
;;;2014   #endif
;;;2015       CPU_DATA    nbr_trail_zeros;
;;;2016   
;;;2017   
;;;2018       if (val == 0u) {                                            /* Rtn ALL val bits as zero'd (see Note #3).            */
000002  ea500201          ORRS     r2,r0,r1
000006  d101              BNE      |L8.12|
;;;2019           return (CPU_WORD_SIZE_64 * DEF_OCTET_NBR_BITS);
000008  2040              MOVS     r0,#0x40
;;;2020       }
;;;2021   
;;;2022                                                                   /* ------------------ ASM-OPTIMIZED ------------------- */
;;;2023   #if ((defined(CPU_CFG_TRAIL_ZEROS_ASM_PRESENT)) && \
;;;2024        (CPU_CFG_DATA_SIZE >= CPU_WORD_SIZE_64))
;;;2025       nbr_trail_zeros = CPU_CntTrailZeros((CPU_DATA)val);
;;;2026   
;;;2027   #else                                                           /* ------------------- C-OPTIMIZED -------------------- */
;;;2028       val_bit_mask    = val & ((CPU_INT64U)~val + 1u);            /* Zero/clr all bits EXCEPT least-sig set bit.          */
;;;2029       nbr_lead_zeros  = CPU_CntLeadZeros64(val_bit_mask);         /* Cnt  nbr lead  0s.                                   */
;;;2030                                                                   /* Calc nbr trail 0s = (nbr val bits - 1) - nbr lead 0s.*/
;;;2031       nbr_trail_zeros = ((CPU_WORD_SIZE_64 * DEF_OCTET_NBR_BITS) - 1u) - nbr_lead_zeros;
;;;2032   #endif
;;;2033   
;;;2034   
;;;2035       return (nbr_trail_zeros);
;;;2036   }
00000a  bd00              POP      {pc}
                  |L8.12|
00000c  43c2              MVNS     r2,r0
00000e  1c52              ADDS     r2,r2,#1
000010  43cb              MVNS     r3,r1
000012  f1430300          ADC      r3,r3,#0
000016  4010              ANDS     r0,r0,r2
000018  4019              ANDS     r1,r1,r3
00001a  f7fffffe          BL       CPU_CntLeadZeros64
00001e  f1c0003f          RSB      r0,r0,#0x3f           ;2031
000022  bd00              POP      {pc}
;;;2037   #endif
                          ENDP


                          AREA ||i.CPU_Init||, CODE, READONLY, ALIGN=2

                  CPU_Init PROC
;;;191    
;;;192    void  CPU_Init (void)
000000  4904              LDR      r1,|L9.20|
;;;193    {
000002  b510              PUSH     {r4,lr}
000004  2000              MOVS     r0,#0
000006  6008              STR      r0,[r1,#0]  ; CPU_TS_TmrFreq_Hz
000008  f7fffffe          BL       CPU_TS_TmrInit
00000c  e8bd4010          POP      {r4,lr}
000010  f7ffbffe          B.W      CPU_NameClr
;;;194                                                                    /* --------------------- INIT TS ---------------------- */
;;;195    #if ((CPU_CFG_TS_EN     == DEF_ENABLED) || \
;;;196         (CPU_CFG_TS_TMR_EN == DEF_ENABLED))
;;;197        CPU_TS_Init();                                              /* See Note #3a.                                        */
;;;198    #endif
;;;199                                                                    /* -------------- INIT INT DIS TIME MEAS -------------- */
;;;200    #ifdef  CPU_CFG_INT_DIS_MEAS_EN
;;;201        CPU_IntDisMeasInit();                                       /* See Note #3b.                                        */
;;;202    #endif
;;;203    
;;;204                                                                    /* ------------------ INIT CPU NAME ------------------- */
;;;205    #if (CPU_CFG_NAME_EN == DEF_ENABLED)
;;;206         CPU_NameInit();
;;;207    #endif
;;;208    }
;;;209    
                          ENDP

                  |L9.20|
                          DCD      ||.data||

                          AREA ||i.CPU_NameClr||, CODE, READONLY, ALIGN=2

                  CPU_NameClr PROC
;;;259    #if (CPU_CFG_NAME_EN == DEF_ENABLED)
;;;260    void  CPU_NameClr (void)
000000  b510              PUSH     {r4,lr}
;;;261    {
;;;262        CPU_SR_ALLOC();
;;;263    
;;;264    
;;;265        CPU_CRITICAL_ENTER();
000002  f7fffffe          BL       CPU_SR_Save
000006  4604              MOV      r4,r0
;;;266        Mem_Clr((void     *)&CPU_Name[0],
000008  2110              MOVS     r1,#0x10
00000a  4804              LDR      r0,|L10.28|
00000c  f7fffffe          BL       Mem_Clr
;;;267                (CPU_SIZE_T) CPU_CFG_NAME_SIZE);
;;;268        CPU_CRITICAL_EXIT();
000010  4620              MOV      r0,r4
000012  e8bd4010          POP      {r4,lr}
000016  f7ffbffe          B.W      CPU_SR_Restore
;;;269    }
;;;270    #endif
                          ENDP

00001a  0000              DCW      0x0000
                  |L10.28|
                          DCD      ||.bss||

                          AREA ||i.CPU_NameGet||, CODE, READONLY, ALIGN=2

                  CPU_NameGet PROC
;;;303    #if (CPU_CFG_NAME_EN == DEF_ENABLED)
;;;304    void  CPU_NameGet (CPU_CHAR  *p_name,
000000  b570              PUSH     {r4-r6,lr}
;;;305                       CPU_ERR   *p_err)
;;;306    {
000002  4605              MOV      r5,r0
000004  000c              MOVS     r4,r1
000006  d00e              BEQ      |L11.38|
;;;307        CPU_SR_ALLOC();
;;;308    
;;;309    
;;;310        if (p_err == (CPU_ERR *)0) {
;;;311            CPU_SW_EXCEPTION(;);
;;;312        }
;;;313    
;;;314        if (p_name == (CPU_CHAR *)0) {
000008  b175              CBZ      r5,|L11.40|
;;;315           *p_err = CPU_ERR_NULL_PTR;
;;;316            return;
;;;317        }
;;;318    
;;;319        CPU_CRITICAL_ENTER();
00000a  f7fffffe          BL       CPU_SR_Save
00000e  4606              MOV      r6,r0
;;;320       (void)Str_Copy_N(p_name,
000010  2210              MOVS     r2,#0x10
000012  4907              LDR      r1,|L11.48|
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       Str_Copy_N
;;;321                       &CPU_Name[0],
;;;322                        CPU_CFG_NAME_SIZE);
;;;323        CPU_CRITICAL_EXIT();
00001a  4630              MOV      r0,r6
00001c  f7fffffe          BL       CPU_SR_Restore
;;;324    
;;;325       *p_err = CPU_ERR_NONE;
000020  2000              MOVS     r0,#0
000022  8020              STRH     r0,[r4,#0]
;;;326    }
000024  bd70              POP      {r4-r6,pc}
                  |L11.38|
000026  e7fe              B        |L11.38|
                  |L11.40|
000028  200a              MOVS     r0,#0xa               ;315
00002a  8008              STRH     r0,[r1,#0]            ;315
00002c  bd70              POP      {r4-r6,pc}
;;;327    #endif
                          ENDP

00002e  0000              DCW      0x0000
                  |L11.48|
                          DCD      ||.bss||

                          AREA ||i.CPU_NameSet||, CODE, READONLY, ALIGN=2

                  CPU_NameSet PROC
;;;356    #if (CPU_CFG_NAME_EN == DEF_ENABLED)
;;;357    void  CPU_NameSet (const  CPU_CHAR  *p_name,
000000  b570              PUSH     {r4-r6,lr}
;;;358                              CPU_ERR   *p_err)
;;;359    {
000002  000c              MOVS     r4,r1
000004  4605              MOV      r5,r0
000006  d012              BEQ      |L12.46|
;;;360        CPU_SIZE_T  len;
;;;361        CPU_SR_ALLOC();
;;;362    
;;;363    
;;;364        if (p_err == (CPU_ERR *)0) {
;;;365            CPU_SW_EXCEPTION(;);
;;;366        }
;;;367    
;;;368        if (p_name == (const CPU_CHAR *)0) {
000008  b195              CBZ      r5,|L12.48|
;;;369           *p_err = CPU_ERR_NULL_PTR;
;;;370            return;
;;;371        }
;;;372    
;;;373        len = Str_Len_N(p_name,
00000a  2110              MOVS     r1,#0x10
00000c  f7fffffe          BL       Str_Len_N
;;;374                        CPU_CFG_NAME_SIZE);
;;;375        if (len < CPU_CFG_NAME_SIZE) {                              /* If       cfg name len < max name size, ...           */
000010  2810              CMP      r0,#0x10
000012  d210              BCS      |L12.54|
;;;376            CPU_CRITICAL_ENTER();
000014  f7fffffe          BL       CPU_SR_Save
000018  4606              MOV      r6,r0
;;;377           (void)Str_Copy_N(&CPU_Name[0],                           /* ... copy cfg name to CPU host name.                  */
00001a  2210              MOVS     r2,#0x10
00001c  4629              MOV      r1,r5
00001e  4808              LDR      r0,|L12.64|
000020  f7fffffe          BL       Str_Copy_N
;;;378                             p_name,
;;;379                             CPU_CFG_NAME_SIZE);
;;;380            CPU_CRITICAL_EXIT();
000024  4630              MOV      r0,r6
000026  f7fffffe          BL       CPU_SR_Restore
;;;381           *p_err = CPU_ERR_NONE;
00002a  2000              MOVS     r0,#0
00002c  e005              B        |L12.58|
                  |L12.46|
00002e  e7fe              B        |L12.46|
                  |L12.48|
000030  200a              MOVS     r0,#0xa               ;369
000032  8008              STRH     r0,[r1,#0]            ;369
;;;382    
;;;383        } else {
;;;384           *p_err = CPU_ERR_NAME_SIZE;
;;;385        }
;;;386    }
000034  bd70              POP      {r4-r6,pc}
                  |L12.54|
000036  f44f707a          MOV      r0,#0x3e8             ;384
                  |L12.58|
00003a  8020              STRH     r0,[r4,#0]            ;381
00003c  bd70              POP      {r4-r6,pc}
;;;387    #endif
                          ENDP

00003e  0000              DCW      0x0000
                  |L12.64|
                          DCD      ||.bss||

                          AREA ||i.CPU_SW_Exception||, CODE, READONLY, ALIGN=1

                  CPU_SW_Exception PROC
                  |L13.0|
;;;230    
;;;231    void  CPU_SW_Exception (void)
000000  e7fe              B        |L13.0|
;;;232    {
;;;233        while (DEF_ON) {
;;;234            ;
;;;235        }
;;;236    }
;;;237    
                          ENDP


                          AREA ||i.CPU_TS_Get32||, CODE, READONLY, ALIGN=1

                  CPU_TS_Get32 PROC
;;;442    #if (CPU_CFG_TS_32_EN == DEF_ENABLED)
;;;443    CPU_TS32  CPU_TS_Get32 (void)
000000  f7ffbffe          B.W      CPU_TS_TmrRd
;;;444    {
;;;445        CPU_TS32    ts;
;;;446    #if (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_32)
;;;447        CPU_TS_TMR  tmr_cur;
;;;448        CPU_TS_TMR  tmr_delta;
;;;449        CPU_SR_ALLOC();
;;;450    #endif
;;;451    
;;;452    
;;;453    #if (CPU_CFG_TS_TMR_SIZE >= CPU_WORD_SIZE_32)
;;;454        ts = (CPU_TS32)CPU_TS_TmrRd();                                  /* Get cur ts tmr val (in 32-bit ts cnts).          */
;;;455    
;;;456    #else
;;;457        CPU_INT_DIS();
;;;458        tmr_cur            = (CPU_TS_TMR) CPU_TS_TmrRd();               /* Get cur ts tmr val (in ts tmr cnts).             */
;;;459        tmr_delta          = (CPU_TS_TMR)(tmr_cur - CPU_TS_32_TmrPrev); /* Calc      delta ts tmr cnts.                     */
;;;460        CPU_TS_32_Accum   += (CPU_TS32  ) tmr_delta;                    /* Inc ts by delta ts tmr cnts (see Note #2).       */
;;;461        CPU_TS_32_TmrPrev  = (CPU_TS_TMR) tmr_cur;                      /* Save cur ts tmr cnts for next update.            */
;;;462        ts                 = (CPU_TS32  ) CPU_TS_32_Accum;
;;;463        CPU_INT_EN();
;;;464    #endif
;;;465    
;;;466        return (ts);
;;;467    }
;;;468    #endif
                          ENDP


                          AREA ||i.CPU_TS_TmrFreqGet||, CODE, READONLY, ALIGN=2

                  CPU_TS_TmrFreqGet PROC
;;;619    #if (CPU_CFG_TS_TMR_EN == DEF_ENABLED)
;;;620    CPU_TS_TMR_FREQ  CPU_TS_TmrFreqGet (CPU_ERR  *p_err)
000000  b120              CBZ      r0,|L15.12|
;;;621    {
;;;622        CPU_TS_TMR_FREQ  freq_hz;
;;;623    
;;;624    
;;;625        if (p_err == (CPU_ERR *)0) {
;;;626            CPU_SW_EXCEPTION(;);
;;;627        }
;;;628    
;;;629        freq_hz =  CPU_TS_TmrFreq_Hz;
000002  4905              LDR      r1,|L15.24|
000004  6809              LDR      r1,[r1,#0]  ; CPU_TS_TmrFreq_Hz
;;;630       *p_err   = (freq_hz != 0u) ? CPU_ERR_NONE : CPU_ERR_TS_FREQ_INVALID;
000006  b111              CBZ      r1,|L15.14|
000008  2200              MOVS     r2,#0
00000a  e002              B        |L15.18|
                  |L15.12|
00000c  e7fe              B        |L15.12|
                  |L15.14|
00000e  f44f62fa          MOV      r2,#0x7d0
                  |L15.18|
000012  8002              STRH     r2,[r0,#0]
;;;631    
;;;632        return (freq_hz);
000014  4608              MOV      r0,r1
;;;633    }
000016  4770              BX       lr
;;;634    #endif
                          ENDP

                  |L15.24|
                          DCD      ||.data||

                          AREA ||i.CPU_TS_TmrFreqSet||, CODE, READONLY, ALIGN=2

                  CPU_TS_TmrFreqSet PROC
;;;670    #if (CPU_CFG_TS_TMR_EN == DEF_ENABLED)
;;;671    void  CPU_TS_TmrFreqSet (CPU_TS_TMR_FREQ  freq_hz)
000000  4901              LDR      r1,|L16.8|
;;;672    {
;;;673        CPU_TS_TmrFreq_Hz = freq_hz;
000002  6008              STR      r0,[r1,#0]  ; CPU_TS_TmrFreq_Hz
;;;674    }
000004  4770              BX       lr
;;;675    #endif
                          ENDP

000006  0000              DCW      0x0000
                  |L16.8|
                          DCD      ||.data||

                          AREA ||i.CPU_TS_Update||, CODE, READONLY, ALIGN=1

                  CPU_TS_Update PROC
;;;577    #if (CPU_CFG_TS_EN == DEF_ENABLED)
;;;578    void  CPU_TS_Update (void)
000000  4770              BX       lr
;;;579    {
;;;580    #if ((CPU_CFG_TS_32_EN    == DEF_ENABLED)  && \
;;;581         (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_32))
;;;582       (void)CPU_TS_Get32();
;;;583    #endif
;;;584    
;;;585    #if ((CPU_CFG_TS_64_EN    == DEF_ENABLED)  && \
;;;586         (CPU_CFG_TS_TMR_SIZE <  CPU_WORD_SIZE_64))
;;;587       (void)CPU_TS_Get64();
;;;588    #endif
;;;589    }
;;;590    #endif
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  CPU_Name
                          %        16

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  CPU_CntLeadZerosTbl
000000  08070606          DCB      0x08,0x07,0x06,0x06
000004  05050505          DCB      0x05,0x05,0x05,0x05
000008  04040404          DCB      0x04,0x04,0x04,0x04
00000c  04040404          DCB      0x04,0x04,0x04,0x04
000010  03030303          DCB      0x03,0x03,0x03,0x03
000014  03030303          DCB      0x03,0x03,0x03,0x03
000018  03030303          DCB      0x03,0x03,0x03,0x03
00001c  03030303          DCB      0x03,0x03,0x03,0x03
000020  02020202          DCB      0x02,0x02,0x02,0x02
000024  02020202          DCB      0x02,0x02,0x02,0x02
000028  02020202          DCB      0x02,0x02,0x02,0x02
00002c  02020202          DCB      0x02,0x02,0x02,0x02
000030  02020202          DCB      0x02,0x02,0x02,0x02
000034  02020202          DCB      0x02,0x02,0x02,0x02
000038  02020202          DCB      0x02,0x02,0x02,0x02
00003c  02020202          DCB      0x02,0x02,0x02,0x02
000040  01010101          DCB      0x01,0x01,0x01,0x01
000044  01010101          DCB      0x01,0x01,0x01,0x01
000048  01010101          DCB      0x01,0x01,0x01,0x01
00004c  01010101          DCB      0x01,0x01,0x01,0x01
000050  01010101          DCB      0x01,0x01,0x01,0x01
000054  01010101          DCB      0x01,0x01,0x01,0x01
000058  01010101          DCB      0x01,0x01,0x01,0x01
00005c  01010101          DCB      0x01,0x01,0x01,0x01
000060  01010101          DCB      0x01,0x01,0x01,0x01
000064  01010101          DCB      0x01,0x01,0x01,0x01
000068  01010101          DCB      0x01,0x01,0x01,0x01
00006c  01010101          DCB      0x01,0x01,0x01,0x01
000070  01010101          DCB      0x01,0x01,0x01,0x01
000074  01010101          DCB      0x01,0x01,0x01,0x01
000078  01010101          DCB      0x01,0x01,0x01,0x01
00007c  01010101          DCB      0x01,0x01,0x01,0x01
000080  00000000          DCB      0x00,0x00,0x00,0x00
000084  00000000          DCB      0x00,0x00,0x00,0x00
000088  00000000          DCB      0x00,0x00,0x00,0x00
00008c  00000000          DCB      0x00,0x00,0x00,0x00
000090  00000000          DCB      0x00,0x00,0x00,0x00
000094  00000000          DCB      0x00,0x00,0x00,0x00
000098  00000000          DCB      0x00,0x00,0x00,0x00
00009c  00000000          DCB      0x00,0x00,0x00,0x00
0000a0  00000000          DCB      0x00,0x00,0x00,0x00
0000a4  00000000          DCB      0x00,0x00,0x00,0x00
0000a8  00000000          DCB      0x00,0x00,0x00,0x00
0000ac  00000000          DCB      0x00,0x00,0x00,0x00
0000b0  00000000          DCB      0x00,0x00,0x00,0x00
0000b4  00000000          DCB      0x00,0x00,0x00,0x00
0000b8  00000000          DCB      0x00,0x00,0x00,0x00
0000bc  00000000          DCB      0x00,0x00,0x00,0x00
0000c0  00000000          DCB      0x00,0x00,0x00,0x00
0000c4  00000000          DCB      0x00,0x00,0x00,0x00
0000c8  00000000          DCB      0x00,0x00,0x00,0x00
0000cc  00000000          DCB      0x00,0x00,0x00,0x00
0000d0  00000000          DCB      0x00,0x00,0x00,0x00
0000d4  00000000          DCB      0x00,0x00,0x00,0x00
0000d8  00000000          DCB      0x00,0x00,0x00,0x00
0000dc  00000000          DCB      0x00,0x00,0x00,0x00
0000e0  00000000          DCB      0x00,0x00,0x00,0x00
0000e4  00000000          DCB      0x00,0x00,0x00,0x00
0000e8  00000000          DCB      0x00,0x00,0x00,0x00
0000ec  00000000          DCB      0x00,0x00,0x00,0x00
0000f0  00000000          DCB      0x00,0x00,0x00,0x00
0000f4  00000000          DCB      0x00,0x00,0x00,0x00
0000f8  00000000          DCB      0x00,0x00,0x00,0x00
0000fc  00000000          DCB      0x00,0x00,0x00,0x00

                          AREA ||area_number.22||, DATA, READONLY, ALIGN=2

                          EXPORTAS ||area_number.22||, ||.constdata||
                  CPU_EndiannessTest
                          DCD      0x12345678

                          AREA ||.data||, DATA, ALIGN=2

                  CPU_TS_TmrFreq_Hz
                          DCD      0x00000000
