; generated by ARM C/C++ Compiler, 5.02 [Build 28]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\OBJ\bsp_cpu_flash.o --asm_dir=.\List\ --list_dir=.\List\ --depend=..\OBJ\bsp_cpu_flash.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\BSP -I..\CORE -I..\STM32F10x_FWLib\inc -I..\USER -I..\UCOSIII\uC-CPU -I..\UCOSIII\uC-CPU\ARM-Cortex-M3\RealView -I..\UCOSIII\uC-LIB -I..\UCOSIII\uC-LIB\Ports\ARM-Cortex-M3\RealView -I..\UCOSIII\uCOS-III -I..\UCOSIII\uCOS-III\Ports -I..\UCOSIII\uCOS-III\Ports\ARM-Cortex-M3\Generic\RealView -I..\UCOSIII\uCOS-III\Source -I..\UCOSIII\UCOS_BSP -I..\UCOSIII\uCOS_CONFIG -I..\UCOSIII-Task -I..\SYSTEM -I..\BSP\inc -I..\PAL -I..\PAL\vehicles -ID:\Keil_v4\ARM\RV31\INC -ID:\Keil_v4\ARM\CMSIS\Include -ID:\Keil_v4\ARM\Inc\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=..\OBJ\bsp_cpu_flash.crf ..\BSP\src\bsp_cpu_flash.c]
                          THUMB

                          AREA ||i.bsp_CmpCpuFlash||, CODE, READONLY, ALIGN=1

                  bsp_CmpCpuFlash PROC
;;;86     */
;;;87     uint8_t bsp_CmpCpuFlash(uint32_t _ulFlashAddr, uint8_t *_ucpBuf, uint32_t _ulSize)
000000  b570              PUSH     {r4-r6,lr}
;;;88     {
;;;89     	uint32_t i;
;;;90     	uint8_t ucIsEqu;	/* 相等标志 */
;;;91     	uint8_t ucByte;
;;;92     
;;;93     	/* 如果偏移地址超过芯片容量，则不改写输出缓冲区 */
;;;94     	if (_ulFlashAddr + _ulSize > FLASH_BASE_ADDR + FLASH_SIZE)
000002  1883              ADDS     r3,r0,r2
000004  f1b36f01          CMP      r3,#0x8100000
000008  d901              BLS      |L1.14|
;;;95     	{
;;;96     		return FLASH_PARAM_ERR;		/*　函数参数错误　*/
00000a  2003              MOVS     r0,#3
;;;97     	}
;;;98     
;;;99     	/* 长度为0时返回正确 */
;;;100    	if (_ulSize == 0)
;;;101    	{
;;;102    		return FLASH_IS_EQU;		/* Flash内容和待写入的数据相等 */
;;;103    	}
;;;104    
;;;105    	ucIsEqu = 1;			/* 先假设所有字节和待写入的数据相等，如果遇到任何一个不相等，则设置为 0 */
;;;106    	for (i = 0; i < _ulSize; i++)
;;;107    	{
;;;108    		ucByte = *(uint8_t *)_ulFlashAddr;
;;;109    
;;;110    		if (ucByte != *_ucpBuf)
;;;111    		{
;;;112    			if (ucByte != 0xFF)
;;;113    			{
;;;114    				return FLASH_REQ_ERASE;		/* 需要擦除后再写 */
;;;115    			}
;;;116    			else
;;;117    			{
;;;118    				ucIsEqu = 0;	/* 不相等，需要写 */
;;;119    			}
;;;120    		}
;;;121    
;;;122    		_ulFlashAddr++;
;;;123    		_ucpBuf++;
;;;124    	}
;;;125    
;;;126    	if (ucIsEqu == 1)
;;;127    	{
;;;128    		return FLASH_IS_EQU;	/* Flash内容和待写入的数据相等，不需要擦除和写操作 */
;;;129    	}
;;;130    	else
;;;131    	{
;;;132    		return FLASH_REQ_WRITE;	/* Flash不需要擦除，直接写 */
;;;133    	}
;;;134    }
00000c  bd70              POP      {r4-r6,pc}
                  |L1.14|
00000e  b1a2              CBZ      r2,|L1.58|
000010  2401              MOVS     r4,#1                 ;105
000012  2300              MOVS     r3,#0                 ;106
000014  e00b              B        |L1.46|
                  |L1.22|
000016  7805              LDRB     r5,[r0,#0]            ;108
000018  780e              LDRB     r6,[r1,#0]            ;110
00001a  42ae              CMP      r6,r5                 ;110
00001c  d004              BEQ      |L1.40|
00001e  2dff              CMP      r5,#0xff              ;112
000020  d001              BEQ      |L1.38|
000022  2002              MOVS     r0,#2                 ;114
000024  bd70              POP      {r4-r6,pc}
                  |L1.38|
000026  2400              MOVS     r4,#0                 ;118
                  |L1.40|
000028  1c40              ADDS     r0,r0,#1              ;122
00002a  1c49              ADDS     r1,r1,#1              ;123
00002c  1c5b              ADDS     r3,r3,#1              ;106
                  |L1.46|
00002e  4293              CMP      r3,r2                 ;106
000030  d3f1              BCC      |L1.22|
000032  2c01              CMP      r4,#1                 ;126
000034  d001              BEQ      |L1.58|
000036  2001              MOVS     r0,#1                 ;132
000038  bd70              POP      {r4-r6,pc}
                  |L1.58|
00003a  2000              MOVS     r0,#0                 ;128
00003c  bd70              POP      {r4-r6,pc}
;;;135    
                          ENDP


                          AREA ||i.bsp_GetSector||, CODE, READONLY, ALIGN=1

                  bsp_GetSector PROC
;;;29     */
;;;30     uint32_t bsp_GetSector(uint32_t _ulWrAddr)
000000  f36f000a          BFC      r0,#0,#11
;;;31     {
;;;32     	uint32_t sector = 0;
;;;33     
;;;34     	sector = _ulWrAddr & SECTOR_MASK;
;;;35     
;;;36     	return sector;
;;;37     }
000004  4770              BX       lr
;;;38     
                          ENDP


                          AREA ||i.bsp_ReadCpuFlash||, CODE, READONLY, ALIGN=1

                  bsp_ReadCpuFlash PROC
;;;48     */
;;;49     uint8_t bsp_ReadCpuFlash(uint32_t _ulFlashAddr, uint8_t *_ucpDst, uint32_t _ulSize)
000000  b510              PUSH     {r4,lr}
;;;50     {
;;;51     	uint32_t i;
;;;52     
;;;53     	/* 如果偏移地址超过芯片容量，则不改写输出缓冲区 */
;;;54     	if (_ulFlashAddr + _ulSize > FLASH_BASE_ADDR + FLASH_SIZE)
000002  1883              ADDS     r3,r0,r2
000004  f1b36f01          CMP      r3,#0x8100000
000008  d802              BHI      |L3.16|
;;;55     	{
;;;56     		return 1;
;;;57     	}
;;;58     
;;;59     	/* 长度为0时不继续操作,否则起始地址为奇地址会出错 */
;;;60     	if (_ulSize == 0)
00000a  b10a              CBZ      r2,|L3.16|
;;;61     	{
;;;62     		return 1;
;;;63     	}
;;;64     
;;;65     	for (i = 0; i < _ulSize; i++)
00000c  2300              MOVS     r3,#0
00000e  e006              B        |L3.30|
                  |L3.16|
000010  2001              MOVS     r0,#1                 ;62
;;;66     	{
;;;67     		*_ucpDst++ = *(uint8_t *)_ulFlashAddr++;
;;;68     	}
;;;69     
;;;70     	return 0;
;;;71     }
000012  bd10              POP      {r4,pc}
                  |L3.20|
000014  f8104b01          LDRB     r4,[r0],#1            ;67
000018  f8014b01          STRB     r4,[r1],#1            ;67
00001c  1c5b              ADDS     r3,r3,#1              ;65
                  |L3.30|
00001e  4293              CMP      r3,r2                 ;65
000020  d3f8              BCC      |L3.20|
000022  2000              MOVS     r0,#0                 ;70
000024  bd10              POP      {r4,pc}
;;;72     
                          ENDP


                          AREA ||i.bsp_WriteCpuFlash||, CODE, READONLY, ALIGN=1

                  bsp_WriteCpuFlash PROC
;;;145    */
;;;146    uint8_t bsp_WriteCpuFlash(uint32_t _ulFlashAddr, uint8_t *_ucpSrc, uint32_t _ulSize)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;147    {
000004  4605              MOV      r5,r0
000006  4617              MOV      r7,r2
;;;148    	uint32_t i;
;;;149    	uint8_t ucRet;
;;;150    	uint16_t usTemp;
;;;151    	FLASH_Status status = FLASH_COMPLETE;
000008  2404              MOVS     r4,#4
;;;152    
;;;153    	/* 如果偏移地址超过芯片容量，则不改写输出缓冲区 */
;;;154    	if (_ulFlashAddr + _ulSize > FLASH_BASE_ADDR + FLASH_SIZE)
00000a  4438              ADD      r0,r0,r7
00000c  4688              MOV      r8,r1                 ;147
00000e  f1b06f01          CMP      r0,#0x8100000
000012  d802              BHI      |L4.26|
;;;155    	{
;;;156    		return 1;
;;;157    	}
;;;158    
;;;159    	/* 长度为0 时不继续操作  */
;;;160    	if (_ulSize == 0)
000014  b3bf              CBZ      r7,|L4.134|
;;;161    	{
;;;162    		return 0;
;;;163    	}
;;;164    
;;;165    	/* 长度为奇数时不继续操作  */
;;;166    	if ((_ulSize % 2) != 0)
000016  07f8              LSLS     r0,r7,#31
000018  d002              BEQ      |L4.32|
                  |L4.26|
;;;167    	{
;;;168    		return 1;
00001a  2001              MOVS     r0,#1
                  |L4.28|
;;;169    	}	
;;;170    
;;;171    	ucRet = bsp_CmpCpuFlash(_ulFlashAddr, _ucpSrc, _ulSize);
;;;172    
;;;173    	if (ucRet == FLASH_IS_EQU)
;;;174    	{
;;;175    		return 0;
;;;176    	}
;;;177    
;;;178    	__set_PRIMASK(1);  		/* 关中断 */
;;;179    
;;;180    	/* FLASH 解锁 */
;;;181    	FLASH_Unlock();
;;;182    
;;;183      	/* Clear pending flags (if any) */
;;;184    	FLASH_ClearFlag(FLASH_FLAG_BSY | FLASH_FLAG_EOP | FLASH_FLAG_PGERR | FLASH_FLAG_WRPRTERR);	
;;;185    
;;;186    	/* 需要擦除 */
;;;187    	if (ucRet == FLASH_REQ_ERASE)
;;;188    	{
;;;189    		status = FLASH_ErasePage(bsp_GetSector(_ulFlashAddr));
;;;190    		if (status != FLASH_COMPLETE)
;;;191    		{
;;;192    			return 2;
;;;193    		}		
;;;194    	}
;;;195    
;;;196    	/* 按字节模式编程（为提高效率，可以按字编程，一次写入4字节） */
;;;197    	for (i = 0; i < _ulSize / 2; i++)
;;;198    	{
;;;199    		//FLASH_ProgramByte(_ulFlashAddr++, *_ucpSrc++);		
;;;200    		usTemp = _ucpSrc[2 * i];
;;;201    		usTemp |= (_ucpSrc[2 * i + 1] << 8);
;;;202    		status = FLASH_ProgramHalfWord(_ulFlashAddr, usTemp);
;;;203    		if (status != FLASH_COMPLETE)
;;;204    		{
;;;205    			break;
;;;206    		}
;;;207    		
;;;208    		_ulFlashAddr += 2;
;;;209    	}
;;;210    
;;;211      	/* Flash 加锁，禁止写Flash控制寄存器 */
;;;212      	FLASH_Lock();
;;;213    
;;;214      	__set_PRIMASK(0);  		/* 开中断 */
;;;215    
;;;216    	if (status == FLASH_COMPLETE)
;;;217    	{
;;;218    		return 0;
;;;219    	}
;;;220    	return 2;
;;;221    }
00001c  e8bd81f0          POP      {r4-r8,pc}
                  |L4.32|
000020  4628              MOV      r0,r5                 ;171
000022  f7fffffe          BL       bsp_CmpCpuFlash
000026  0006              MOVS     r6,r0                 ;171
000028  d02e              BEQ      |L4.136|
00002a  2001              MOVS     r0,#1                 ;178
00002c  f3808810          MSR      PRIMASK,r0            ;178
000030  f7fffffe          BL       FLASH_Unlock
000034  2035              MOVS     r0,#0x35              ;184
000036  f7fffffe          BL       FLASH_ClearFlag
00003a  2e02              CMP      r6,#2                 ;187
00003c  d106              BNE      |L4.76|
00003e  0ae8              LSRS     r0,r5,#11             ;187
000040  02c0              LSLS     r0,r0,#11             ;187
000042  f7fffffe          BL       FLASH_ErasePage
000046  4604              MOV      r4,r0                 ;189
000048  2804              CMP      r0,#4                 ;190
00004a  d11a              BNE      |L4.130|
                  |L4.76|
00004c  2600              MOVS     r6,#0                 ;197
00004e  e00e              B        |L4.110|
                  |L4.80|
000050  eb080146          ADD      r1,r8,r6,LSL #1       ;201
000054  f8180016          LDRB     r0,[r8,r6,LSL #1]     ;200
000058  7849              LDRB     r1,[r1,#1]            ;201
00005a  ea402101          ORR      r1,r0,r1,LSL #8       ;201
00005e  4628              MOV      r0,r5                 ;202
000060  f7fffffe          BL       FLASH_ProgramHalfWord
000064  4604              MOV      r4,r0                 ;202
000066  2804              CMP      r0,#4                 ;203
000068  d104              BNE      |L4.116|
00006a  1cad              ADDS     r5,r5,#2              ;208
00006c  1c76              ADDS     r6,r6,#1              ;197
                  |L4.110|
00006e  ebb60f57          CMP      r6,r7,LSR #1          ;197
000072  d3ed              BCC      |L4.80|
                  |L4.116|
000074  f7fffffe          BL       FLASH_Lock
000078  2000              MOVS     r0,#0                 ;214
00007a  f3808810          MSR      PRIMASK,r0            ;214
00007e  2c04              CMP      r4,#4                 ;216
000080  d002              BEQ      |L4.136|
                  |L4.130|
000082  2002              MOVS     r0,#2                 ;220
000084  e7ca              B        |L4.28|
                  |L4.134|
000086  e7ff              B        |L4.136|
                  |L4.136|
000088  2000              MOVS     r0,#0                 ;218
00008a  e7c7              B        |L4.28|
;;;222    
                          ENDP

