; generated by ARM C/C++ Compiler, 5.02 [Build 28]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\OBJ\ringbuffer.o --asm_dir=.\List\ --list_dir=.\List\ --depend=..\OBJ\ringbuffer.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\BSP -I..\CORE -I..\STM32F10x_FWLib\inc -I..\USER -I..\UCOSIII\uC-CPU -I..\UCOSIII\uC-CPU\ARM-Cortex-M3\RealView -I..\UCOSIII\uC-LIB -I..\UCOSIII\uC-LIB\Ports\ARM-Cortex-M3\RealView -I..\UCOSIII\uCOS-III -I..\UCOSIII\uCOS-III\Ports -I..\UCOSIII\uCOS-III\Ports\ARM-Cortex-M3\Generic\RealView -I..\UCOSIII\uCOS-III\Source -I..\UCOSIII\UCOS_BSP -I..\UCOSIII\uCOS_CONFIG -I..\UCOSIII-Task -I..\SYSTEM -I..\BSP\inc -I..\PAL -I..\PAL\vehicles -ID:\Keil_v4\ARM\RV31\INC -ID:\Keil_v4\ARM\CMSIS\Include -ID:\Keil_v4\ARM\Inc\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=..\OBJ\ringbuffer.crf ..\BSP\src\ringbuffer.c]
                          THUMB

                          AREA ||i.rb_clear||, CODE, READONLY, ALIGN=1

                  rb_clear PROC
;;;92     
;;;93     void rb_clear(struct rb* rb)
000000  4770              BX       lr
;;;94     {
;;;95         uint8_t byte;
;;;96         while(!rb_is_empty) {
;;;97             rb_get(rb, &byte, 1);
;;;98         }
;;;99     //    rb->read_index = 0;
;;;100    //    rb->write_index = 0;
;;;101    }
                          ENDP


                          AREA ||i.rb_get||, CODE, READONLY, ALIGN=1

                  rb_get PROC
;;;60     
;;;61     bool rb_get(struct rb* rb, uint8_t *ptr, uint16_t length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;62     {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
;;;63         uint16_t size;
;;;64         if(rb->read_index > rb->write_index)
000008  88c0              LDRH     r0,[r0,#6]
00000a  8921              LDRH     r1,[r4,#8]
00000c  4615              MOV      r5,r2                 ;62
00000e  4288              CMP      r0,r1
000010  d903              BLS      |L2.26|
;;;65             size = rb->buffer_size - rb->read_index + rb->write_index;
000012  88a2              LDRH     r2,[r4,#4]
000014  1a12              SUBS     r2,r2,r0
000016  440a              ADD      r2,r2,r1
000018  e000              B        |L2.28|
                  |L2.26|
;;;66         else
;;;67             size = rb->write_index - rb->read_index;
00001a  1a0a              SUBS     r2,r1,r0
                  |L2.28|
00001c  b292              UXTH     r2,r2
;;;68         if(size < length)
00001e  42aa              CMP      r2,r5
000020  d202              BCS      |L2.40|
;;;69             return FALSE;
000022  2000              MOVS     r0,#0
                  |L2.36|
;;;70         if(rb->read_index > rb->write_index)
;;;71         {
;;;72             size = rb->buffer_size - rb->read_index;
;;;73             if(size > length)
;;;74             {
;;;75                 memcpy(ptr, &rb->buffer_ptr[rb->read_index], length);
;;;76                 rb->read_index += length;
;;;77             }
;;;78             else
;;;79             {
;;;80                 memcpy(ptr, &rb->buffer_ptr[rb->read_index], size);
;;;81                 memcpy(&ptr[size], &rb->buffer_ptr[0], length - size);
;;;82                 rb->read_index = length - size;
;;;83             }
;;;84         }
;;;85         else
;;;86         {
;;;87             memcpy(ptr, &rb->buffer_ptr[rb->read_index], length);
;;;88             rb->read_index += length;
;;;89         }
;;;90         return TRUE;
;;;91     }
000024  e8bd81f0          POP      {r4-r8,pc}
                  |L2.40|
000028  4288              CMP      r0,r1                 ;70
00002a  d904              BLS      |L2.54|
00002c  88a1              LDRH     r1,[r4,#4]            ;72
00002e  1a09              SUBS     r1,r1,r0              ;72
000030  b28e              UXTH     r6,r1                 ;72
000032  42ae              CMP      r6,r5                 ;73
000034  d909              BLS      |L2.74|
                  |L2.54|
000036  6821              LDR      r1,[r4,#0]            ;75
000038  462a              MOV      r2,r5                 ;75
00003a  4401              ADD      r1,r1,r0              ;75
00003c  4638              MOV      r0,r7                 ;75
00003e  f7fffffe          BL       __aeabi_memcpy
000042  88e0              LDRH     r0,[r4,#6]            ;76
000044  4428              ADD      r0,r0,r5              ;76
000046  80e0              STRH     r0,[r4,#6]            ;76
000048  e00c              B        |L2.100|
                  |L2.74|
00004a  6821              LDR      r1,[r4,#0]            ;80
00004c  4632              MOV      r2,r6                 ;80
00004e  4401              ADD      r1,r1,r0              ;80
000050  4638              MOV      r0,r7                 ;80
000052  f7fffffe          BL       __aeabi_memcpy
000056  1bad              SUBS     r5,r5,r6              ;81
000058  19b8              ADDS     r0,r7,r6              ;81
00005a  462a              MOV      r2,r5                 ;81
00005c  6821              LDR      r1,[r4,#0]            ;81
00005e  f7fffffe          BL       __aeabi_memcpy
000062  80e5              STRH     r5,[r4,#6]            ;82
                  |L2.100|
000064  2001              MOVS     r0,#1                 ;90
000066  e7dd              B        |L2.36|
;;;92     
                          ENDP


                          AREA ||i.rb_get_size||, CODE, READONLY, ALIGN=1

                  rb_get_size PROC
;;;20     
;;;21     uint16_t rb_get_size(struct rb *rb)
000000  88c2              LDRH     r2,[r0,#6]
;;;22     {
;;;23         uint16_t size;
;;;24         if(rb->read_index > rb->write_index) {
000002  8901              LDRH     r1,[r0,#8]
000004  428a              CMP      r2,r1
000006  d901              BLS      |L3.12|
;;;25             size = rb->read_index - rb->write_index;
000008  1a50              SUBS     r0,r2,r1
00000a  e002              B        |L3.18|
                  |L3.12|
;;;26         } else {
;;;27             size = rb->buffer_size - rb->write_index + rb->read_index;
00000c  8880              LDRH     r0,[r0,#4]
00000e  1a40              SUBS     r0,r0,r1
000010  4410              ADD      r0,r0,r2
                  |L3.18|
000012  b280              UXTH     r0,r0                 ;25
;;;28         }
;;;29         return size;
;;;30     }
000014  4770              BX       lr
;;;31     
                          ENDP


                          AREA ||i.rb_init||, CODE, READONLY, ALIGN=1

                  rb_init PROC
;;;3      
;;;4      void rb_init(struct rb* rb, uint8_t* pool, uint16_t size)
000000  2300              MOVS     r3,#0
;;;5      {
;;;6          //ASSERT(rb != NULL);
;;;7          rb->read_index = 0;
000002  80c3              STRH     r3,[r0,#6]
;;;8          rb->write_index = 0;
000004  8103              STRH     r3,[r0,#8]
;;;9          rb->buffer_ptr = pool;
;;;10         rb->buffer_size = size;
000006  6001              STR      r1,[r0,#0]
000008  8082              STRH     r2,[r0,#4]
;;;11     }
00000a  4770              BX       lr
;;;12     
                          ENDP


                          AREA ||i.rb_is_empty||, CODE, READONLY, ALIGN=1

                  rb_is_empty PROC
;;;12     
;;;13     bool rb_is_empty(struct rb* rb)
000000  88c1              LDRH     r1,[r0,#6]
;;;14     {
;;;15         if(rb->read_index == rb->write_index)
000002  8900              LDRH     r0,[r0,#8]
000004  4281              CMP      r1,r0
000006  d101              BNE      |L5.12|
;;;16             return TRUE;
000008  2001              MOVS     r0,#1
;;;17         else
;;;18             return FALSE;
;;;19     }
00000a  4770              BX       lr
                  |L5.12|
00000c  2000              MOVS     r0,#0                 ;18
00000e  4770              BX       lr
;;;20     
                          ENDP


                          AREA ||i.rb_put||, CODE, READONLY, ALIGN=1

                  rb_put PROC
;;;31     
;;;32     bool rb_put(struct rb* rb, const uint8_t *ptr, uint16_t length)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;33     {
000004  460f              MOV      r7,r1
000006  4604              MOV      r4,r0
;;;34         uint16_t size;
;;;35         if(rb->read_index > rb->write_index) {
000008  88c1              LDRH     r1,[r0,#6]
00000a  8900              LDRH     r0,[r0,#8]
00000c  4615              MOV      r5,r2                 ;33
00000e  4281              CMP      r1,r0
000010  d901              BLS      |L6.22|
;;;36             size = rb->read_index - rb->write_index;
000012  1a0a              SUBS     r2,r1,r0
000014  e002              B        |L6.28|
                  |L6.22|
;;;37         } else {
;;;38             size = rb->buffer_size - rb->write_index + rb->read_index;
000016  88a2              LDRH     r2,[r4,#4]
000018  1a12              SUBS     r2,r2,r0
00001a  440a              ADD      r2,r2,r1
                  |L6.28|
00001c  b292              UXTH     r2,r2
;;;39         }
;;;40         if(size < length)
00001e  42aa              CMP      r2,r5
000020  d202              BCS      |L6.40|
;;;41             return FALSE;
000022  2000              MOVS     r0,#0
                  |L6.36|
;;;42     
;;;43         if(rb->read_index > rb->write_index) {
;;;44             memcpy(&rb->buffer_ptr[rb->write_index], ptr, length);
;;;45             rb->write_index += length;
;;;46         } else {
;;;47             size = rb->buffer_size - rb->write_index;
;;;48             if(size > length) {
;;;49                 memcpy(&rb->buffer_ptr[rb->write_index], ptr, length);
;;;50                 rb->write_index += length;
;;;51             } else {
;;;52                 memcpy(&rb->buffer_ptr[rb->write_index], ptr, size);
;;;53                 memcpy(&rb->buffer_ptr[0], &ptr[size], length - size);
;;;54                 rb->write_index = length - size;
;;;55             }
;;;56         }
;;;57     
;;;58         return TRUE;
;;;59     }
000024  e8bd81f0          POP      {r4-r8,pc}
                  |L6.40|
000028  4281              CMP      r1,r0                 ;43
00002a  d804              BHI      |L6.54|
00002c  88a1              LDRH     r1,[r4,#4]            ;47
00002e  1a09              SUBS     r1,r1,r0              ;47
000030  b28e              UXTH     r6,r1                 ;47
000032  42ae              CMP      r6,r5                 ;48
000034  d909              BLS      |L6.74|
                  |L6.54|
000036  6821              LDR      r1,[r4,#0]            ;49
000038  462a              MOV      r2,r5                 ;49
00003a  4408              ADD      r0,r0,r1              ;49
00003c  4639              MOV      r1,r7                 ;49
00003e  f7fffffe          BL       __aeabi_memcpy
000042  8920              LDRH     r0,[r4,#8]            ;50
000044  4428              ADD      r0,r0,r5              ;50
000046  8120              STRH     r0,[r4,#8]            ;50
000048  e00c              B        |L6.100|
                  |L6.74|
00004a  6821              LDR      r1,[r4,#0]            ;52
00004c  4632              MOV      r2,r6                 ;52
00004e  4408              ADD      r0,r0,r1              ;52
000050  4639              MOV      r1,r7                 ;52
000052  f7fffffe          BL       __aeabi_memcpy
000056  1bad              SUBS     r5,r5,r6              ;53
000058  19b9              ADDS     r1,r7,r6              ;53
00005a  462a              MOV      r2,r5                 ;53
00005c  6820              LDR      r0,[r4,#0]            ;53
00005e  f7fffffe          BL       __aeabi_memcpy
000062  8125              STRH     r5,[r4,#8]            ;54
                  |L6.100|
000064  2001              MOVS     r0,#1                 ;58
000066  e7dd              B        |L6.36|
;;;60     
                          ENDP

