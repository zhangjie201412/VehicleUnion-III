; generated by ARM C/C++ Compiler, 5.02 [Build 28]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\OBJ\os_task.o --asm_dir=.\List\ --list_dir=.\List\ --depend=..\OBJ\os_task.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\BSP -I..\CORE -I..\STM32F10x_FWLib\inc -I..\USER -I..\UCOSIII\uC-CPU -I..\UCOSIII\uC-CPU\ARM-Cortex-M3\RealView -I..\UCOSIII\uC-LIB -I..\UCOSIII\uC-LIB\Ports\ARM-Cortex-M3\RealView -I..\UCOSIII\uCOS-III -I..\UCOSIII\uCOS-III\Ports -I..\UCOSIII\uCOS-III\Ports\ARM-Cortex-M3\Generic\RealView -I..\UCOSIII\uCOS-III\Source -I..\UCOSIII\UCOS_BSP -I..\UCOSIII\uCOS_CONFIG -I..\UCOSIII-Task -I..\SYSTEM -I..\BSP\inc -I..\PAL -I..\PAL\vehicles -ID:\Keil_v4\ARM\RV31\INC -ID:\Keil_v4\ARM\CMSIS\Include -ID:\Keil_v4\ARM\Inc\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=..\OBJ\os_task.crf ..\UCOSIII\uCOS-III\Source\os_task.c]
                          THUMB

                          AREA ||i.OSTaskChangePrio||, CODE, READONLY, ALIGN=2

                  OSTaskChangePrio PROC
;;;61     #if OS_CFG_TASK_CHANGE_PRIO_EN > 0u
;;;62     void  OSTaskChangePrio (OS_TCB   *p_tcb,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;63                             OS_PRIO   prio_new,
;;;64                             OS_ERR   *p_err)
;;;65     {
000004  4605              MOV      r5,r0
;;;66         CPU_BOOLEAN   self;
;;;67         CPU_SR_ALLOC();
;;;68     
;;;69     
;;;70     
;;;71     #ifdef OS_SAFETY_CRITICAL
;;;72         if (p_err == (OS_ERR *)0) {
;;;73             OS_SAFETY_CRITICAL_EXCEPTION();
;;;74             return;
;;;75         }
;;;76     #endif
;;;77     
;;;78     #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;79         if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* ---------- CANNOT CREATE A TASK FROM AN ISR ---------- */
000006  483b              LDR      r0,|L1.244|
000008  460c              MOV      r4,r1                 ;65
00000a  4616              MOV      r6,r2                 ;65
00000c  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
00000e  b110              CBZ      r0,|L1.22|
;;;80            *p_err = OS_ERR_TASK_CHANGE_PRIO_ISR;
000010  f2471049          MOV      r0,#0x7149
;;;81             return;
000014  e004              B        |L1.32|
                  |L1.22|
;;;82         }
;;;83     #endif
;;;84     
;;;85     #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
;;;86         if (prio_new == 0) {                                    /* Cannot set to IntQueue Task priority                   */
;;;87            *p_err = OS_ERR_PRIO_INVALID;
000016  f2462073          MOV      r0,#0x6273
00001a  b10c              CBZ      r4,|L1.32|
;;;88             return;
;;;89         }
;;;90     #endif
;;;91     
;;;92         if (prio_new >= (OS_CFG_PRIO_MAX - 1u)) {               /* Cannot set to Idle Task priority                       */
00001c  2c3f              CMP      r4,#0x3f
00001e  d302              BCC      |L1.38|
                  |L1.32|
;;;93            *p_err = OS_ERR_PRIO_INVALID;
000020  8010              STRH     r0,[r2,#0]
                  |L1.34|
;;;94             return;
;;;95         }
;;;96     
;;;97         if (p_tcb == (OS_TCB *)0) {                             /* See if want to change priority of 'self'               */
;;;98             CPU_CRITICAL_ENTER();
;;;99             p_tcb = OSTCBCurPtr;
;;;100            CPU_CRITICAL_EXIT();
;;;101            self  = DEF_TRUE;
;;;102        } else {
;;;103            self  = DEF_FALSE;
;;;104        }
;;;105    
;;;106        OS_CRITICAL_ENTER();
;;;107        switch (p_tcb->TaskState) {
;;;108            case OS_TASK_STATE_RDY:
;;;109                 OS_RdyListRemove(p_tcb);                       /* Remove from current priority                           */
;;;110                 p_tcb->Prio = prio_new;                        /* Set new task priority                                  */
;;;111                 OS_PrioInsert(p_tcb->Prio);
;;;112                 if (self == DEF_TRUE) {
;;;113                     OS_RdyListInsertHead(p_tcb);
;;;114                 } else {
;;;115                     OS_RdyListInsertTail(p_tcb);
;;;116                 }
;;;117                 break;
;;;118    
;;;119            case OS_TASK_STATE_DLY:                             /* Nothing to do except change the priority in the OS_TCB */
;;;120            case OS_TASK_STATE_SUSPENDED:
;;;121            case OS_TASK_STATE_DLY_SUSPENDED:
;;;122                 p_tcb->Prio = prio_new;                        /* Set new task priority                                  */
;;;123                 break;
;;;124    
;;;125            case OS_TASK_STATE_PEND:
;;;126            case OS_TASK_STATE_PEND_TIMEOUT:
;;;127            case OS_TASK_STATE_PEND_SUSPENDED:
;;;128            case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
;;;129                 switch (p_tcb->PendOn) {                       /* What to do depends on what we are pending on           */
;;;130                     case OS_TASK_PEND_ON_TASK_Q:               /* Nothing to do except change the priority in the OS_TCB */
;;;131                     case OS_TASK_PEND_ON_TASK_SEM:
;;;132                     case OS_TASK_PEND_ON_FLAG:
;;;133                          p_tcb->Prio = prio_new;               /* Set new task priority                                  */
;;;134                          break;
;;;135    
;;;136                     case OS_TASK_PEND_ON_MUTEX:
;;;137                     case OS_TASK_PEND_ON_MULTI:
;;;138                     case OS_TASK_PEND_ON_Q:
;;;139                     case OS_TASK_PEND_ON_SEM:
;;;140                          OS_PendListChangePrio(p_tcb,
;;;141                                                prio_new);
;;;142                          break;
;;;143    
;;;144                     default:
;;;145                          break;
;;;146                }
;;;147                 break;
;;;148    
;;;149            default:
;;;150                 OS_CRITICAL_EXIT();
;;;151                *p_err = OS_ERR_STATE_INVALID;
;;;152                 return;
;;;153        }
;;;154    
;;;155        OS_CRITICAL_EXIT_NO_SCHED();
;;;156    
;;;157        OSSched();                                              /* Run highest priority task ready                        */
;;;158    
;;;159       *p_err = OS_ERR_NONE;
;;;160    }
000022  e8bd81f0          POP      {r4-r8,pc}
                  |L1.38|
000026  b1b5              CBZ      r5,|L1.86|
000028  f05f0700          MOVS.W   r7,#0                 ;103
                  |L1.44|
00002c  f7fffffe          BL       CPU_SR_Save
000030  f8df80c4          LDR      r8,|L1.248|
000034  f8982000          LDRB     r2,[r8,#0]            ;106  ; OSSchedLockNestingCtr
000038  1c52              ADDS     r2,r2,#1              ;106
00003a  f8882000          STRB     r2,[r8,#0]            ;106
00003e  f7fffffe          BL       CPU_SR_Restore
000042  f8950036          LDRB     r0,[r5,#0x36]         ;107
000046  2808              CMP      r0,#8                 ;107
000048  d23d              BCS      |L1.198|
00004a  e8dff000          TBB      [pc,r0]               ;107
00004e  0c27              DCB      0x0c,0x27
000050  1d1d2727          DCB      0x1d,0x1d,0x27,0x27
000054  1d1d              DCB      0x1d,0x1d
                  |L1.86|
000056  f7fffffe          BL       CPU_SR_Save
00005a  4928              LDR      r1,|L1.252|
00005c  680d              LDR      r5,[r1,#0]            ;100  ; OSTCBCurPtr
00005e  f7fffffe          BL       CPU_SR_Restore
000062  2701              MOVS     r7,#1                 ;101
000064  e7e2              B        |L1.44|
000066  4628              MOV      r0,r5                 ;109
000068  f7fffffe          BL       OS_RdyListRemove
00006c  f8854037          STRB     r4,[r5,#0x37]         ;110
000070  4620              MOV      r0,r4                 ;111
000072  f7fffffe          BL       OS_PrioInsert
000076  2f01              CMP      r7,#1                 ;112
000078  4628              MOV      r0,r5                 ;115
00007a  d002              BEQ      |L1.130|
00007c  f7fffffe          BL       OS_RdyListInsertTail
000080  e013              B        |L1.170|
                  |L1.130|
000082  f7fffffe          BL       OS_RdyListInsertHead
000086  e010              B        |L1.170|
000088  f8950034          LDRB     r0,[r5,#0x34]         ;129
00008c  2808              CMP      r0,#8                 ;129
00008e  d20c              BCS      |L1.170|
000090  e8dff000          TBB      [pc,r0]               ;129
000094  0b040407          DCB      0x0b,0x04,0x04,0x07
000098  07070704          DCB      0x07,0x07,0x07,0x04
00009c  f8854037          STRB     r4,[r5,#0x37]         ;133
0000a0  e003              B        |L1.170|
0000a2  4621              MOV      r1,r4                 ;140
0000a4  4628              MOV      r0,r5                 ;140
0000a6  f7fffffe          BL       OS_PendListChangePrio
                  |L1.170|
0000aa  f7fffffe          BL       CPU_SR_Save
0000ae  f8982000          LDRB     r2,[r8,#0]            ;155  ; OSSchedLockNestingCtr
0000b2  1e52              SUBS     r2,r2,#1              ;155
0000b4  f8882000          STRB     r2,[r8,#0]            ;155
0000b8  f7fffffe          BL       CPU_SR_Restore
0000bc  f7fffffe          BL       OSSched
0000c0  2000              MOVS     r0,#0                 ;159
                  |L1.194|
0000c2  8030              STRH     r0,[r6,#0]            ;159
0000c4  e7ad              B        |L1.34|
                  |L1.198|
0000c6  f7fffffe          BL       CPU_SR_Save
0000ca  f8982000          LDRB     r2,[r8,#0]            ;150  ; OSSchedLockNestingCtr
0000ce  1e52              SUBS     r2,r2,#1              ;150
0000d0  f01202ff          ANDS     r2,r2,#0xff           ;150
0000d4  f8882000          STRB     r2,[r8,#0]            ;150
0000d8  d107              BNE      |L1.234|
0000da  4909              LDR      r1,|L1.256|
0000dc  8809              LDRH     r1,[r1,#0]            ;150  ; OSIntQNbrEntries
0000de  b121              CBZ      r1,|L1.234|
0000e0  f7fffffe          BL       CPU_SR_Restore
0000e4  f7fffffe          BL       OS_Sched0
0000e8  e001              B        |L1.238|
                  |L1.234|
0000ea  f7fffffe          BL       CPU_SR_Restore
                  |L1.238|
0000ee  f646602d          MOV      r0,#0x6e2d            ;151
0000f2  e7e6              B        |L1.194|
;;;161    #endif
                          ENDP

                  |L1.244|
                          DCD      OSIntNestingCtr
                  |L1.248|
                          DCD      OSSchedLockNestingCtr
                  |L1.252|
                          DCD      OSTCBCurPtr
                  |L1.256|
                          DCD      OSIntQNbrEntries

                          AREA ||i.OSTaskCreate||, CODE, READONLY, ALIGN=2

                  OSTaskCreate PROC
;;;248    /*$PAGE*/
;;;249    void  OSTaskCreate (OS_TCB        *p_tcb,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;250                        CPU_CHAR      *p_name,
;;;251                        OS_TASK_PTR    p_task,
;;;252                        void          *p_arg,
;;;253                        OS_PRIO        prio,
;;;254                        CPU_STK       *p_stk_base,
;;;255                        CPU_STK_SIZE   stk_limit,
;;;256                        CPU_STK_SIZE   stk_size,
;;;257                        OS_MSG_QTY     q_size,
;;;258                        OS_TICK        time_quanta,
;;;259                        void          *p_ext,
;;;260                        OS_OPT         opt,
;;;261                        OS_ERR        *p_err)
;;;262    {
000004  b083              SUB      sp,sp,#0xc
000006  4604              MOV      r4,r0
;;;263        CPU_STK_SIZE   i;
;;;264    #if OS_CFG_TASK_REG_TBL_SIZE > 0u
;;;265        OS_REG_ID      reg_nbr;
;;;266    #endif
;;;267    #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
;;;268        OS_TLS_ID      id;
;;;269    #endif
;;;270    
;;;271        CPU_STK       *p_sp;
;;;272        CPU_STK       *p_stk_limit;
;;;273        CPU_SR_ALLOC();
;;;274    
;;;275    
;;;276    
;;;277    #ifdef OS_SAFETY_CRITICAL
;;;278        if (p_err == (OS_ERR *)0) {
;;;279            OS_SAFETY_CRITICAL_EXCEPTION();
;;;280            return;
;;;281        }
;;;282    #endif
;;;283    
;;;284    #ifdef OS_SAFETY_CRITICAL_IEC61508
;;;285        if (OSSafetyCriticalStartFlag == DEF_TRUE) {
;;;286           *p_err = OS_ERR_ILLEGAL_CREATE_RUN_TIME;
;;;287            return;
;;;288        }
;;;289    #endif
;;;290    
;;;291    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;292        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* ---------- CANNOT CREATE A TASK FROM AN ISR ---------- */
000008  4862              LDR      r0,|L2.404|
00000a  e9dd9517          LDRD     r9,r5,[sp,#0x5c]      ;262
00000e  e9dd8610          LDRD     r8,r6,[sp,#0x40]      ;262
000012  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
000014  f8dda054          LDR      r10,[sp,#0x54]        ;262
000018  9f13              LDR      r7,[sp,#0x4c]         ;262
00001a  b110              CBZ      r0,|L2.34|
;;;293           *p_err = OS_ERR_TASK_CREATE_ISR;
00001c  f247104a          MOV      r0,#0x714a
;;;294            return;
000020  e02a              B        |L2.120|
                  |L2.34|
;;;295        }
;;;296    #endif
;;;297    
;;;298    #if OS_CFG_ARG_CHK_EN > 0u                                  /* ---------------- VALIDATE ARGUMENTS ------------------ */
;;;299        if (p_tcb == (OS_TCB *)0) {                             /* User must supply a valid OS_TCB                        */
000022  b14c              CBZ      r4,|L2.56|
;;;300           *p_err = OS_ERR_TCB_INVALID;
;;;301            return;
;;;302        }
;;;303        if (p_task == (OS_TASK_PTR)0) {                         /* User must supply a valid task                          */
000024  9805              LDR      r0,[sp,#0x14]
000026  b150              CBZ      r0,|L2.62|
;;;304           *p_err = OS_ERR_TASK_INVALID;
;;;305            return;
;;;306        }
;;;307        if (p_stk_base == (CPU_STK *)0) {                       /* User must supply a valid stack base address            */
000028  b166              CBZ      r6,|L2.68|
;;;308           *p_err = OS_ERR_STK_INVALID;
;;;309            return;
;;;310        }
;;;311        if (stk_size < OSCfg_StkSizeMin) {                      /* User must supply a valid minimum stack size            */
00002a  485b              LDR      r0,|L2.408|
00002c  6800              LDR      r0,[r0,#0]  ; OSCfg_StkSizeMin
00002e  4287              CMP      r7,r0
000030  d20b              BCS      |L2.74|
;;;312           *p_err = OS_ERR_STK_SIZE_INVALID;
000032  f6466030          MOV      r0,#0x6e30
;;;313            return;
000036  e01f              B        |L2.120|
                  |L2.56|
000038  f24710ad          MOV      r0,#0x71ad            ;300
00003c  e01c              B        |L2.120|
                  |L2.62|
00003e  f247104f          MOV      r0,#0x714f            ;304
000042  e019              B        |L2.120|
                  |L2.68|
000044  f646602f          MOV      r0,#0x6e2f            ;308
000048  e016              B        |L2.120|
                  |L2.74|
;;;314        }
;;;315        if (stk_limit >= stk_size) {                            /* User must supply a valid stack limit                   */
00004a  9812              LDR      r0,[sp,#0x48]
00004c  42b8              CMP      r0,r7
00004e  d302              BCC      |L2.86|
;;;316           *p_err = OS_ERR_STK_LIMIT_INVALID;
000050  f6466031          MOV      r0,#0x6e31
;;;317            return;
000054  e010              B        |L2.120|
                  |L2.86|
;;;318        }
;;;319        if (prio >= OS_CFG_PRIO_MAX) {                          /* Priority must be within 0 and OS_CFG_PRIO_MAX-1        */
;;;320           *p_err = OS_ERR_PRIO_INVALID;
000056  f2462073          MOV      r0,#0x6273
00005a  f1b80f40          CMP      r8,#0x40              ;319
00005e  d20b              BCS      |L2.120|
;;;321            return;
;;;322        }
;;;323    #endif
;;;324    
;;;325    #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
;;;326        if (prio == (OS_PRIO)0) {
000060  f1b80f00          CMP      r8,#0
000064  d003              BEQ      |L2.110|
;;;327            if (p_tcb != &OSIntQTaskTCB) {
;;;328               *p_err = OS_ERR_PRIO_INVALID;                    /* Not allowed to use priority 0                          */
;;;329                return;
;;;330            }
;;;331        }
;;;332    #endif
;;;333    
;;;334        if (prio == (OS_CFG_PRIO_MAX - 1u)) {
000066  f1b80f3f          CMP      r8,#0x3f
00006a  d002              BEQ      |L2.114|
00006c  e008              B        |L2.128|
                  |L2.110|
00006e  494b              LDR      r1,|L2.412|
000070  e000              B        |L2.116|
                  |L2.114|
;;;335            if (p_tcb != &OSIdleTaskTCB) {
000072  494b              LDR      r1,|L2.416|
                  |L2.116|
000074  428c              CMP      r4,r1                 ;327
000076  d003              BEQ      |L2.128|
                  |L2.120|
;;;336               *p_err = OS_ERR_PRIO_INVALID;                    /* Not allowed to use same priority as idle task          */
000078  8028              STRH     r0,[r5,#0]
;;;337                return;
;;;338            }
;;;339        }
;;;340    
;;;341        OS_TaskInitTCB(p_tcb);                                  /* Initialize the TCB to default values                   */
;;;342    
;;;343       *p_err = OS_ERR_NONE;
;;;344                                                                /* --------------- CLEAR THE TASK'S STACK --------------- */
;;;345        if ((opt & OS_OPT_TASK_STK_CHK) != (OS_OPT)0) {         /* See if stack checking has been enabled                 */
;;;346            if ((opt & OS_OPT_TASK_STK_CLR) != (OS_OPT)0) {     /* See if stack needs to be cleared                       */
;;;347                p_sp = p_stk_base;
;;;348                for (i = 0u; i < stk_size; i++) {               /* Stack grows from HIGH to LOW memory                    */
;;;349                   *p_sp = (CPU_STK)0;                          /* Clear from bottom of stack and up!                     */
;;;350                    p_sp++;
;;;351                }
;;;352            }
;;;353        }
;;;354                                                                /* ------- INITIALIZE THE STACK FRAME OF THE TASK ------- */
;;;355    #if (CPU_CFG_STK_GROWTH == CPU_STK_GROWTH_HI_TO_LO)
;;;356        p_stk_limit = p_stk_base + stk_limit;
;;;357    #else
;;;358        p_stk_limit = p_stk_base + (stk_size - 1u) - stk_limit;
;;;359    #endif
;;;360    
;;;361        p_sp = OSTaskStkInit(p_task,
;;;362                             p_arg,
;;;363                             p_stk_base,
;;;364                             p_stk_limit,
;;;365                             stk_size,
;;;366                             opt);
;;;367    
;;;368                                                                /* -------------- INITIALIZE THE TCB FIELDS ------------- */
;;;369        p_tcb->TaskEntryAddr = p_task;                          /* Save task entry point address                          */
;;;370        p_tcb->TaskEntryArg  = p_arg;                           /* Save task entry argument                               */
;;;371    
;;;372        p_tcb->NamePtr       = p_name;                          /* Save task name                                         */
;;;373    
;;;374        p_tcb->Prio          = prio;                            /* Save the task's priority                               */
;;;375    
;;;376        p_tcb->StkPtr        = p_sp;                            /* Save the new top-of-stack pointer                      */
;;;377        p_tcb->StkLimitPtr   = p_stk_limit;                     /* Save the stack limit pointer                           */
;;;378    
;;;379        p_tcb->TimeQuanta    = time_quanta;                     /* Save the #ticks for time slice (0 means not sliced)    */
;;;380    #if OS_CFG_SCHED_ROUND_ROBIN_EN > 0u
;;;381        if (time_quanta == (OS_TICK)0) {
;;;382            p_tcb->TimeQuantaCtr = OSSchedRoundRobinDfltTimeQuanta;
;;;383        } else {
;;;384            p_tcb->TimeQuantaCtr = time_quanta;
;;;385        }
;;;386    #endif
;;;387        p_tcb->ExtPtr        = p_ext;                           /* Save pointer to TCB extension                          */
;;;388        p_tcb->StkBasePtr    = p_stk_base;                      /* Save pointer to the base address of the stack          */
;;;389        p_tcb->StkSize       = stk_size;                        /* Save the stack size (in number of CPU_STK elements)    */
;;;390        p_tcb->Opt           = opt;                             /* Save task options                                      */
;;;391    
;;;392    #if OS_CFG_TASK_REG_TBL_SIZE > 0u
;;;393        for (reg_nbr = 0u; reg_nbr < OS_CFG_TASK_REG_TBL_SIZE; reg_nbr++) {
;;;394            p_tcb->RegTbl[reg_nbr] = (OS_REG)0;
;;;395        }
;;;396    #endif
;;;397    
;;;398    #if OS_CFG_TASK_Q_EN > 0u
;;;399        OS_MsgQInit(&p_tcb->MsgQ,                               /* Initialize the task's message queue                    */
;;;400                    q_size);
;;;401    #else
;;;402        (void)&q_size;
;;;403    #endif
;;;404    
;;;405        OSTaskCreateHook(p_tcb);                                /* Call user defined hook                                 */
;;;406    
;;;407    #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
;;;408        for (id = 0u; id < OS_CFG_TLS_TBL_SIZE; id++) {
;;;409            p_tcb->TLS_Tbl[id] = (OS_TLS)0;
;;;410        }
;;;411        OS_TLS_TaskCreate(p_tcb);                               /* Call TLS hook                                          */
;;;412    #endif
;;;413                                                                /* --------------- ADD TASK TO READY LIST --------------- */
;;;414        OS_CRITICAL_ENTER();
;;;415        OS_PrioInsert(p_tcb->Prio);
;;;416        OS_RdyListInsertTail(p_tcb);
;;;417    
;;;418    #if OS_CFG_DBG_EN > 0u
;;;419        OS_TaskDbgListAdd(p_tcb);
;;;420    #endif
;;;421    
;;;422        OSTaskQty++;                                            /* Increment the #tasks counter                           */
;;;423    
;;;424        if (OSRunning != OS_STATE_OS_RUNNING) {                 /* Return if multitasking has not started                 */
;;;425            OS_CRITICAL_EXIT();
;;;426            return;
;;;427        }
;;;428    
;;;429        OS_CRITICAL_EXIT_NO_SCHED();
;;;430    
;;;431        OSSched();
;;;432    }
00007a  b007              ADD      sp,sp,#0x1c
00007c  e8bd8ff0          POP      {r4-r11,pc}
                  |L2.128|
000080  4620              MOV      r0,r4                 ;341
000082  f7fffffe          BL       OS_TaskInitTCB
000086  f04f0b00          MOV      r11,#0                ;343
00008a  f8a5b000          STRH     r11,[r5,#0]           ;343
00008e  ea5f70c9          LSLS     r0,r9,#31             ;345
000092  d00a              BEQ      |L2.170|
000094  ea5f7089          LSLS     r0,r9,#30             ;346
000098  d507              BPL      |L2.170|
00009a  4630              MOV      r0,r6                 ;347
00009c  2100              MOVS     r1,#0                 ;348
00009e  465a              MOV      r2,r11                ;348
0000a0  e001              B        |L2.166|
                  |L2.162|
0000a2  c004              STM      r0!,{r2}              ;349
0000a4  1c49              ADDS     r1,r1,#1              ;348
                  |L2.166|
0000a6  42b9              CMP      r1,r7                 ;348
0000a8  d3fb              BCC      |L2.162|
                  |L2.170|
0000aa  9812              LDR      r0,[sp,#0x48]         ;356
0000ac  e9cd7900          STRD     r7,r9,[sp,#0]         ;361
0000b0  eb060580          ADD      r5,r6,r0,LSL #2       ;356
0000b4  e9dd0105          LDRD     r0,r1,[sp,#0x14]      ;361
0000b8  462b              MOV      r3,r5                 ;361
0000ba  4632              MOV      r2,r6                 ;361
0000bc  f7fffffe          BL       OSTaskStkInit
0000c0  9905              LDR      r1,[sp,#0x14]         ;369
0000c2  62a1              STR      r1,[r4,#0x28]         ;370
0000c4  9906              LDR      r1,[sp,#0x18]         ;370
0000c6  62e1              STR      r1,[r4,#0x2c]         ;372
0000c8  9904              LDR      r1,[sp,#0x10]         ;372
0000ca  6221              STR      r1,[r4,#0x20]         ;374
0000cc  f8848037          STRB     r8,[r4,#0x37]         ;374
0000d0  f8c4a054          STR      r10,[r4,#0x54]        ;381
0000d4  60a5              STR      r5,[r4,#8]            ;381
0000d6  6020              STR      r0,[r4,#0]            ;381
0000d8  f1ba0f00          CMP      r10,#0                ;381
0000dc  d03c              BEQ      |L2.344|
0000de  4650              MOV      r0,r10                ;384
                  |L2.224|
0000e0  65a0              STR      r0,[r4,#0x58]         ;387
0000e2  9816              LDR      r0,[sp,#0x58]         ;387
0000e4  63a7              STR      r7,[r4,#0x38]         ;390
0000e6  6266              STR      r6,[r4,#0x24]         ;390
0000e8  6060              STR      r0,[r4,#4]            ;390
0000ea  f8a4903c          STRH     r9,[r4,#0x3c]         ;390
0000ee  2000              MOVS     r0,#0                 ;393
0000f0  ea4f010b          MOV.W    r1,r11                ;393
                  |L2.244|
0000f4  eb040280          ADD      r2,r4,r0,LSL #2       ;394
0000f8  1c40              ADDS     r0,r0,#1              ;393
0000fa  67d1              STR      r1,[r2,#0x7c]         ;393
0000fc  f01000ff          ANDS     r0,r0,#0xff           ;393
000100  d0f8              BEQ      |L2.244|
000102  f1040064          ADD      r0,r4,#0x64           ;399
000106  9914              LDR      r1,[sp,#0x50]         ;399
000108  f7fffffe          BL       OS_MsgQInit
00010c  4620              MOV      r0,r4                 ;405
00010e  f7fffffe          BL       OSTaskCreateHook
000112  f7fffffe          BL       CPU_SR_Save
000116  4d23              LDR      r5,|L2.420|
000118  7829              LDRB     r1,[r5,#0]            ;414  ; OSSchedLockNestingCtr
00011a  1c49              ADDS     r1,r1,#1              ;414
00011c  7029              STRB     r1,[r5,#0]            ;414
00011e  f7fffffe          BL       CPU_SR_Restore
000122  f8940037          LDRB     r0,[r4,#0x37]         ;415
000126  f7fffffe          BL       OS_PrioInsert
00012a  4620              MOV      r0,r4                 ;416
00012c  f7fffffe          BL       OS_RdyListInsertTail
000130  4620              MOV      r0,r4                 ;419
000132  f7fffffe          BL       OS_TaskDbgListAdd
000136  491c              LDR      r1,|L2.424|
000138  8808              LDRH     r0,[r1,#0]            ;422  ; OSTaskQty
00013a  1c40              ADDS     r0,r0,#1              ;422
00013c  8008              STRH     r0,[r1,#0]            ;422
00013e  481b              LDR      r0,|L2.428|
000140  7800              LDRB     r0,[r0,#0]            ;424  ; OSRunning
000142  2801              CMP      r0,#1                 ;424
000144  d01a              BEQ      |L2.380|
000146  f7fffffe          BL       CPU_SR_Save
00014a  7829              LDRB     r1,[r5,#0]            ;425  ; OSSchedLockNestingCtr
00014c  1e49              SUBS     r1,r1,#1              ;425
00014e  f01101ff          ANDS     r1,r1,#0xff           ;425
000152  7029              STRB     r1,[r5,#0]            ;425
000154  d003              BEQ      |L2.350|
000156  e00c              B        |L2.370|
                  |L2.344|
000158  4815              LDR      r0,|L2.432|
00015a  6800              LDR      r0,[r0,#0]            ;382  ; OSSchedRoundRobinDfltTimeQuanta
00015c  e7c0              B        |L2.224|
                  |L2.350|
00015e  4915              LDR      r1,|L2.436|
000160  8809              LDRH     r1,[r1,#0]            ;425  ; OSIntQNbrEntries
000162  b131              CBZ      r1,|L2.370|
000164  f7fffffe          BL       CPU_SR_Restore
000168  b007              ADD      sp,sp,#0x1c           ;425
00016a  e8bd4ff0          POP      {r4-r11,lr}           ;425
00016e  f7ffbffe          B.W      OS_Sched0
                  |L2.370|
000172  b007              ADD      sp,sp,#0x1c           ;425
000174  e8bd4ff0          POP      {r4-r11,lr}           ;425
000178  f7ffbffe          B.W      CPU_SR_Restore
                  |L2.380|
00017c  f7fffffe          BL       CPU_SR_Save
000180  7829              LDRB     r1,[r5,#0]            ;429  ; OSSchedLockNestingCtr
000182  1e49              SUBS     r1,r1,#1              ;429
000184  7029              STRB     r1,[r5,#0]            ;429
000186  f7fffffe          BL       CPU_SR_Restore
00018a  b007              ADD      sp,sp,#0x1c           ;431
00018c  e8bd4ff0          POP      {r4-r11,lr}           ;431
000190  f7ffbffe          B.W      OSSched
;;;433    
                          ENDP

                  |L2.404|
                          DCD      OSIntNestingCtr
                  |L2.408|
                          DCD      OSCfg_StkSizeMin
                  |L2.412|
                          DCD      OSIntQTaskTCB
                  |L2.416|
                          DCD      OSIdleTaskTCB
                  |L2.420|
                          DCD      OSSchedLockNestingCtr
                  |L2.424|
                          DCD      OSTaskQty
                  |L2.428|
                          DCD      OSRunning
                  |L2.432|
                          DCD      OSSchedRoundRobinDfltTimeQuanta
                  |L2.436|
                          DCD      OSIntQNbrEntries

                          AREA ||i.OSTaskDel||, CODE, READONLY, ALIGN=2

                  OSTaskDel PROC
;;;459    #if OS_CFG_TASK_DEL_EN > 0u
;;;460    void  OSTaskDel (OS_TCB  *p_tcb,
000000  b570              PUSH     {r4-r6,lr}
;;;461                     OS_ERR  *p_err)
;;;462    {
000002  4604              MOV      r4,r0
;;;463        CPU_SR_ALLOC();
;;;464    
;;;465    
;;;466    
;;;467    #ifdef OS_SAFETY_CRITICAL
;;;468        if (p_err == (OS_ERR *)0) {
;;;469            OS_SAFETY_CRITICAL_EXCEPTION();
;;;470            return;
;;;471        }
;;;472    #endif
;;;473    
;;;474    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;475        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if trying to delete from ISR                       */
000004  483d              LDR      r0,|L3.252|
000006  460d              MOV      r5,r1                 ;462
000008  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
00000a  b110              CBZ      r0,|L3.18|
;;;476           *p_err = OS_ERR_TASK_DEL_ISR;
00000c  f247104e          MOV      r0,#0x714e
;;;477            return;
000010  e00a              B        |L3.40|
                  |L3.18|
;;;478        }
;;;479    #endif
;;;480    
;;;481        if (p_tcb == &OSIdleTaskTCB) {                          /* Not allowed to delete the idle task                    */
000012  483b              LDR      r0,|L3.256|
000014  4284              CMP      r4,r0
000016  d102              BNE      |L3.30|
;;;482           *p_err = OS_ERR_TASK_DEL_IDLE;
000018  f247104c          MOV      r0,#0x714c
;;;483            return;
00001c  e004              B        |L3.40|
                  |L3.30|
;;;484        }
;;;485    
;;;486    #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
;;;487        if (p_tcb == &OSIntQTaskTCB) {                          /* Cannot delete the ISR handler task                     */
00001e  4839              LDR      r0,|L3.260|
000020  4284              CMP      r4,r0
000022  d103              BNE      |L3.44|
;;;488           *p_err = OS_ERR_TASK_DEL_INVALID;
000024  f247104d          MOV      r0,#0x714d
                  |L3.40|
000028  8008              STRH     r0,[r1,#0]
;;;489            return;
;;;490        }
;;;491    #endif
;;;492    
;;;493        if (p_tcb == (OS_TCB *)0) {                             /* Delete 'Self'?                                         */
;;;494            CPU_CRITICAL_ENTER();
;;;495            p_tcb  = OSTCBCurPtr;                               /* Yes.                                                   */
;;;496            CPU_CRITICAL_EXIT();
;;;497        }
;;;498    
;;;499        OS_CRITICAL_ENTER();
;;;500        switch (p_tcb->TaskState) {
;;;501            case OS_TASK_STATE_RDY:
;;;502                 OS_RdyListRemove(p_tcb);
;;;503                 break;
;;;504    
;;;505            case OS_TASK_STATE_SUSPENDED:
;;;506                 break;
;;;507    
;;;508            case OS_TASK_STATE_DLY:                             /* Task is only delayed, not on any wait list             */
;;;509            case OS_TASK_STATE_DLY_SUSPENDED:
;;;510                 OS_TickListRemove(p_tcb);
;;;511                 break;
;;;512    
;;;513            case OS_TASK_STATE_PEND:
;;;514            case OS_TASK_STATE_PEND_SUSPENDED:
;;;515            case OS_TASK_STATE_PEND_TIMEOUT:
;;;516            case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
;;;517                 OS_TickListRemove(p_tcb);
;;;518                 switch (p_tcb->PendOn) {                       /* See what we are pending on                             */
;;;519                     case OS_TASK_PEND_ON_NOTHING:
;;;520                     case OS_TASK_PEND_ON_TASK_Q:               /* There is no wait list for these two                    */
;;;521                     case OS_TASK_PEND_ON_TASK_SEM:
;;;522                          break;
;;;523    
;;;524                     case OS_TASK_PEND_ON_FLAG:                 /* Remove from wait list                                  */
;;;525                     case OS_TASK_PEND_ON_MULTI:
;;;526                     case OS_TASK_PEND_ON_MUTEX:
;;;527                     case OS_TASK_PEND_ON_Q:
;;;528                     case OS_TASK_PEND_ON_SEM:
;;;529                          OS_PendListRemove(p_tcb);
;;;530                          break;
;;;531    
;;;532                     default:
;;;533                          break;
;;;534                 }
;;;535                 break;
;;;536    
;;;537            default:
;;;538                OS_CRITICAL_EXIT();
;;;539               *p_err = OS_ERR_STATE_INVALID;
;;;540                return;
;;;541        }
;;;542    
;;;543    #if OS_CFG_TASK_Q_EN > 0u
;;;544        (void)OS_MsgQFreeAll(&p_tcb->MsgQ);                     /* Free task's message queue messages                     */
;;;545    #endif
;;;546    
;;;547        OSTaskDelHook(p_tcb);                                   /* Call user defined hook                                 */
;;;548    
;;;549    #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
;;;550        OS_TLS_TaskDel(p_tcb);                                  /* Call TLS hook                                          */
;;;551    #endif
;;;552    
;;;553    #if OS_CFG_DBG_EN > 0u
;;;554        OS_TaskDbgListRemove(p_tcb);
;;;555    #endif
;;;556        OSTaskQty--;                                            /* One less task being managed                            */
;;;557    
;;;558        OS_TaskInitTCB(p_tcb);                                  /* Initialize the TCB to default values                   */
;;;559        p_tcb->TaskState = (OS_STATE)OS_TASK_STATE_DEL;         /* Indicate that the task was deleted                     */
;;;560    
;;;561        OS_CRITICAL_EXIT_NO_SCHED();
;;;562    
;;;563       *p_err = OS_ERR_NONE;                                    /* See Note #1.                                           */
;;;564    
;;;565        OSSched();                                              /* Find new highest priority task                         */
;;;566    }
00002a  bd70              POP      {r4-r6,pc}
                  |L3.44|
00002c  b92c              CBNZ     r4,|L3.58|
00002e  f7fffffe          BL       CPU_SR_Save
000032  4935              LDR      r1,|L3.264|
000034  680c              LDR      r4,[r1,#0]            ;496  ; OSTCBCurPtr
000036  f7fffffe          BL       CPU_SR_Restore
                  |L3.58|
00003a  f7fffffe          BL       CPU_SR_Save
00003e  4e33              LDR      r6,|L3.268|
000040  7831              LDRB     r1,[r6,#0]            ;499  ; OSSchedLockNestingCtr
000042  1c49              ADDS     r1,r1,#1              ;499
000044  7031              STRB     r1,[r6,#0]            ;499
000046  f7fffffe          BL       CPU_SR_Restore
00004a  f8940036          LDRB     r0,[r4,#0x36]         ;500
00004e  2808              CMP      r0,#8                 ;500
000050  d23e              BCS      |L3.208|
000052  e8dff000          TBB      [pc,r0]               ;500
000056  0408              DCB      0x04,0x08
000058  0c0c1c08          DCB      0x0c,0x0c,0x1c,0x08
00005c  0c0c              DCB      0x0c,0x0c
00005e  4620              MOV      r0,r4                 ;502
000060  f7fffffe          BL       OS_RdyListRemove
000064  e013              B        |L3.142|
000066  4620              MOV      r0,r4                 ;510
000068  f7fffffe          BL       OS_TickListRemove
00006c  e00f              B        |L3.142|
00006e  4620              MOV      r0,r4                 ;517
000070  f7fffffe          BL       OS_TickListRemove
000074  f8940034          LDRB     r0,[r4,#0x34]         ;518
000078  2807              CMP      r0,#7                 ;518
00007a  d208              BCS      |L3.142|
00007c  e8dff000          TBB      [pc,r0]               ;518
000080  07040704          DCB      0x07,0x04,0x07,0x04
000084  04040400          DCB      0x04,0x04,0x04,0x00
000088  4620              MOV      r0,r4                 ;529
00008a  f7fffffe          BL       OS_PendListRemove
                  |L3.142|
00008e  f1040064          ADD      r0,r4,#0x64           ;544
000092  f7fffffe          BL       OS_MsgQFreeAll
000096  4620              MOV      r0,r4                 ;547
000098  f7fffffe          BL       OSTaskDelHook
00009c  4620              MOV      r0,r4                 ;554
00009e  f7fffffe          BL       OS_TaskDbgListRemove
0000a2  491b              LDR      r1,|L3.272|
0000a4  8808              LDRH     r0,[r1,#0]            ;556  ; OSTaskQty
0000a6  1e40              SUBS     r0,r0,#1              ;556
0000a8  8008              STRH     r0,[r1,#0]            ;556
0000aa  4620              MOV      r0,r4                 ;558
0000ac  f7fffffe          BL       OS_TaskInitTCB
0000b0  20ff              MOVS     r0,#0xff              ;559
0000b2  f8840036          STRB     r0,[r4,#0x36]         ;559
0000b6  f7fffffe          BL       CPU_SR_Save
0000ba  7831              LDRB     r1,[r6,#0]            ;561  ; OSSchedLockNestingCtr
0000bc  1e49              SUBS     r1,r1,#1              ;561
0000be  7031              STRB     r1,[r6,#0]            ;561
0000c0  f7fffffe          BL       CPU_SR_Restore
0000c4  2000              MOVS     r0,#0                 ;563
0000c6  8028              STRH     r0,[r5,#0]            ;563
0000c8  e8bd4070          POP      {r4-r6,lr}            ;565
0000cc  f7ffbffe          B.W      OSSched
                  |L3.208|
0000d0  f7fffffe          BL       CPU_SR_Save
0000d4  7831              LDRB     r1,[r6,#0]            ;538  ; OSSchedLockNestingCtr
0000d6  1e49              SUBS     r1,r1,#1              ;538
0000d8  f01101ff          ANDS     r1,r1,#0xff           ;538
0000dc  7031              STRB     r1,[r6,#0]            ;538
0000de  d107              BNE      |L3.240|
0000e0  490c              LDR      r1,|L3.276|
0000e2  8809              LDRH     r1,[r1,#0]            ;538  ; OSIntQNbrEntries
0000e4  b121              CBZ      r1,|L3.240|
0000e6  f7fffffe          BL       CPU_SR_Restore
0000ea  f7fffffe          BL       OS_Sched0
0000ee  e001              B        |L3.244|
                  |L3.240|
0000f0  f7fffffe          BL       CPU_SR_Restore
                  |L3.244|
0000f4  f646602d          MOV      r0,#0x6e2d            ;539
0000f8  8028              STRH     r0,[r5,#0]            ;539
0000fa  bd70              POP      {r4-r6,pc}
;;;567    #endif
                          ENDP

                  |L3.252|
                          DCD      OSIntNestingCtr
                  |L3.256|
                          DCD      OSIdleTaskTCB
                  |L3.260|
                          DCD      OSIntQTaskTCB
                  |L3.264|
                          DCD      OSTCBCurPtr
                  |L3.268|
                          DCD      OSSchedLockNestingCtr
                  |L3.272|
                          DCD      OSTaskQty
                  |L3.276|
                          DCD      OSIntQNbrEntries

                          AREA ||i.OSTaskQFlush||, CODE, READONLY, ALIGN=2

                  OSTaskQFlush PROC
;;;593    #if OS_CFG_TASK_Q_EN > 0u
;;;594    OS_MSG_QTY  OSTaskQFlush (OS_TCB  *p_tcb,
000000  b570              PUSH     {r4-r6,lr}
;;;595                              OS_ERR  *p_err)
;;;596    {
000002  4604              MOV      r4,r0
;;;597        OS_MSG_QTY  entries;
;;;598        CPU_SR_ALLOC();
;;;599    
;;;600    
;;;601    
;;;602    #ifdef OS_SAFETY_CRITICAL
;;;603        if (p_err == (OS_ERR *)0) {
;;;604            OS_SAFETY_CRITICAL_EXCEPTION();
;;;605            return ((OS_MSG_QTY)0);
;;;606        }
;;;607    #endif
;;;608    
;;;609    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;610        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Can't flush a message queue from an ISR                */
000004  4819              LDR      r0,|L4.108|
000006  460e              MOV      r6,r1                 ;596
000008  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
00000a  b120              CBZ      r0,|L4.22|
;;;611           *p_err = OS_ERR_FLUSH_ISR;
00000c  f44f506c          MOV      r0,#0x3b00
000010  8008              STRH     r0,[r1,#0]
;;;612            return ((OS_MSG_QTY)0);
000012  2000              MOVS     r0,#0
;;;613        }
;;;614    #endif
;;;615    
;;;616        if (p_tcb == (OS_TCB *)0) {                             /* Flush message queue of calling task?                   */
;;;617            CPU_CRITICAL_ENTER();
;;;618            p_tcb = OSTCBCurPtr;
;;;619            CPU_CRITICAL_EXIT();
;;;620        }
;;;621    
;;;622        OS_CRITICAL_ENTER();
;;;623        entries = OS_MsgQFreeAll(&p_tcb->MsgQ);                 /* Return all OS_MSGs to the OS_MSG pool                  */
;;;624        OS_CRITICAL_EXIT();
;;;625       *p_err   = OS_ERR_NONE;
;;;626        return (entries);
;;;627    }
000014  bd70              POP      {r4-r6,pc}
                  |L4.22|
000016  b92c              CBNZ     r4,|L4.36|
000018  f7fffffe          BL       CPU_SR_Save
00001c  4914              LDR      r1,|L4.112|
00001e  680c              LDR      r4,[r1,#0]            ;619  ; OSTCBCurPtr
000020  f7fffffe          BL       CPU_SR_Restore
                  |L4.36|
000024  f7fffffe          BL       CPU_SR_Save
000028  4d12              LDR      r5,|L4.116|
00002a  7829              LDRB     r1,[r5,#0]            ;622  ; OSSchedLockNestingCtr
00002c  1c49              ADDS     r1,r1,#1              ;622
00002e  7029              STRB     r1,[r5,#0]            ;622
000030  f7fffffe          BL       CPU_SR_Restore
000034  f1040064          ADD      r0,r4,#0x64           ;623
000038  f7fffffe          BL       OS_MsgQFreeAll
00003c  4604              MOV      r4,r0                 ;623
00003e  f7fffffe          BL       CPU_SR_Save
000042  7829              LDRB     r1,[r5,#0]            ;624  ; OSSchedLockNestingCtr
000044  1e49              SUBS     r1,r1,#1              ;624
000046  f01101ff          ANDS     r1,r1,#0xff           ;624
00004a  7029              STRB     r1,[r5,#0]            ;624
00004c  d107              BNE      |L4.94|
00004e  490a              LDR      r1,|L4.120|
000050  8809              LDRH     r1,[r1,#0]            ;624  ; OSIntQNbrEntries
000052  b121              CBZ      r1,|L4.94|
000054  f7fffffe          BL       CPU_SR_Restore
000058  f7fffffe          BL       OS_Sched0
00005c  e001              B        |L4.98|
                  |L4.94|
00005e  f7fffffe          BL       CPU_SR_Restore
                  |L4.98|
000062  2000              MOVS     r0,#0                 ;625
000064  8030              STRH     r0,[r6,#0]            ;625
000066  4620              MOV      r0,r4                 ;626
000068  bd70              POP      {r4-r6,pc}
;;;628    #endif
                          ENDP

00006a  0000              DCW      0x0000
                  |L4.108|
                          DCD      OSIntNestingCtr
                  |L4.112|
                          DCD      OSTCBCurPtr
                  |L4.116|
                          DCD      OSSchedLockNestingCtr
                  |L4.120|
                          DCD      OSIntQNbrEntries

                          AREA ||i.OSTaskQPend||, CODE, READONLY, ALIGN=2

                  OSTaskQPend PROC
;;;671    #if OS_CFG_TASK_Q_EN > 0u
;;;672    void  *OSTaskQPend (OS_TICK       timeout,
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;673                        OS_OPT        opt,
;;;674                        OS_MSG_SIZE  *p_msg_size,
;;;675                        CPU_TS       *p_ts,
;;;676                        OS_ERR       *p_err)
;;;677    {
000004  4683              MOV      r11,r0
;;;678        OS_MSG_Q     *p_msg_q;
;;;679        void         *p_void;
;;;680        CPU_SR_ALLOC();
;;;681    
;;;682    
;;;683    
;;;684    #ifdef OS_SAFETY_CRITICAL
;;;685        if (p_err == (OS_ERR *)0) {
;;;686            OS_SAFETY_CRITICAL_EXCEPTION();
;;;687            return ((void *)0);
;;;688        }
;;;689    #endif
;;;690    
;;;691    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;692        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Can't Pend from an ISR                                 */
000006  4850              LDR      r0,|L5.328|
000008  9d0a              LDR      r5,[sp,#0x28]         ;677
00000a  460f              MOV      r7,r1                 ;677
00000c  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
00000e  461c              MOV      r4,r3                 ;677
000010  4616              MOV      r6,r2                 ;677
000012  b110              CBZ      r0,|L5.26|
;;;693           *p_err = OS_ERR_PEND_ISR;
000014  f24610ae          MOV      r0,#0x61ae
;;;694            return ((void *)0);
000018  e009              B        |L5.46|
                  |L5.26|
;;;695        }
;;;696    #endif
;;;697    
;;;698    #if OS_CFG_ARG_CHK_EN > 0u                                  /* ---------------- VALIDATE ARGUMENTS ------------------ */
;;;699        if (p_msg_size == (OS_MSG_SIZE *)0) {                   /* User must supply a valid destination for msg size      */
00001a  b136              CBZ      r6,|L5.42|
;;;700           *p_err = OS_ERR_PTR_INVALID;
;;;701            return ((void *)0);
;;;702        }
;;;703        switch (opt) {                                          /* User must supply a valid option                        */
00001c  b149              CBZ      r1,|L5.50|
00001e  f5b14f00          CMP      r1,#0x8000
000022  d006              BEQ      |L5.50|
;;;704            case OS_OPT_PEND_BLOCKING:
;;;705            case OS_OPT_PEND_NON_BLOCKING:
;;;706                 break;
;;;707    
;;;708            default:
;;;709                *p_err = OS_ERR_OPT_INVALID;
000024  f6456025          MOV      r0,#0x5e25
;;;710                 return ((void *)0);
000028  e001              B        |L5.46|
                  |L5.42|
00002a  f24620d5          MOV      r0,#0x62d5            ;700
                  |L5.46|
00002e  8028              STRH     r0,[r5,#0]            ;693
000030  e01c              B        |L5.108|
                  |L5.50|
000032  f04f0900          MOV      r9,#0                 ;693
;;;711        }
;;;712    #endif
;;;713    
;;;714        if (p_ts != (CPU_TS *)0) {
000036  b10c              CBZ      r4,|L5.60|
;;;715           *p_ts  = (CPU_TS  )0;                                /* Initialize the returned timestamp                      */
000038  f8c49000          STR      r9,[r4,#0]
                  |L5.60|
;;;716        }
;;;717    
;;;718        CPU_CRITICAL_ENTER();
00003c  f7fffffe          BL       CPU_SR_Save
;;;719        p_msg_q = &OSTCBCurPtr->MsgQ;                           /* Any message waiting in the message queue?              */
000040  f8df8108          LDR      r8,|L5.332|
000044  9000              STR      r0,[sp,#0]
;;;720        p_void  = OS_MsgQGet(p_msg_q,
000046  462b              MOV      r3,r5
000048  f8d80000          LDR      r0,[r8,#0]            ;719  ; OSTCBCurPtr
00004c  4622              MOV      r2,r4
00004e  3064              ADDS     r0,r0,#0x64           ;719
000050  4631              MOV      r1,r6
000052  f7fffffe          BL       OS_MsgQGet
000056  4682              MOV      r10,r0
;;;721                             p_msg_size,
;;;722                             p_ts,
;;;723                             p_err);
;;;724        if (*p_err == OS_ERR_NONE) {
000058  8828              LDRH     r0,[r5,#0]
00005a  b150              CBZ      r0,|L5.114|
;;;725    #if OS_CFG_TASK_PROFILE_EN > 0u
;;;726            if (p_ts != (CPU_TS *)0) {
;;;727                OSTCBCurPtr->MsgQPendTime = OS_TS_GET() - *p_ts;
;;;728                if (OSTCBCurPtr->MsgQPendTimeMax < OSTCBCurPtr->MsgQPendTime) {
;;;729                    OSTCBCurPtr->MsgQPendTimeMax = OSTCBCurPtr->MsgQPendTime;
;;;730                }
;;;731            }
;;;732    #endif
;;;733            CPU_CRITICAL_EXIT();
;;;734            return (p_void);                                    /* Yes, Return oldest message received                    */
;;;735        }
;;;736    
;;;737        if ((opt & OS_OPT_PEND_NON_BLOCKING) != (OS_OPT)0) {    /* Caller wants to block if not available?                */
00005c  0438              LSLS     r0,r7,#16
00005e  d519              BPL      |L5.148|
;;;738           *p_err = OS_ERR_PEND_WOULD_BLOCK;                    /* No                                                     */
000060  f24610b0          MOV      r0,#0x61b0
000064  8028              STRH     r0,[r5,#0]
;;;739            CPU_CRITICAL_EXIT();
000066  9800              LDR      r0,[sp,#0]
000068  f7fffffe          BL       CPU_SR_Restore
                  |L5.108|
;;;740            return ((void *)0);
;;;741        } else {                                                /* Yes                                                    */
;;;742            if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {    /*     Can't block when the scheduler is locked           */
;;;743                CPU_CRITICAL_EXIT();
;;;744               *p_err = OS_ERR_SCHED_LOCKED;
;;;745                return ((void *)0);
00006c  2000              MOVS     r0,#0
                  |L5.110|
;;;746            }
;;;747        }
;;;748    
;;;749        OS_CRITICAL_ENTER_CPU_CRITICAL_EXIT();                  /* Lock the scheduler/re-enable interrupts                */
;;;750        OS_Pend((OS_PEND_DATA *)0,                              /* Block task pending on Message                          */
;;;751                (OS_PEND_OBJ  *)0,
;;;752                (OS_STATE      )OS_TASK_PEND_ON_TASK_Q,
;;;753                (OS_TICK       )timeout);
;;;754        OS_CRITICAL_EXIT_NO_SCHED();
;;;755    
;;;756        OSSched();                                              /* Find the next highest priority task ready to run       */
;;;757    
;;;758        CPU_CRITICAL_ENTER();
;;;759        switch (OSTCBCurPtr->PendStatus) {
;;;760            case OS_STATUS_PEND_OK:                             /* Extract message from TCB (Put there by Post)           */
;;;761                 p_void      = OSTCBCurPtr->MsgPtr;
;;;762                *p_msg_size  = OSTCBCurPtr->MsgSize;
;;;763                 if (p_ts != (CPU_TS *)0) {
;;;764                    *p_ts  = OSTCBCurPtr->TS;
;;;765    #if OS_CFG_TASK_PROFILE_EN > 0u
;;;766                    OSTCBCurPtr->MsgQPendTime = OS_TS_GET() - OSTCBCurPtr->TS;
;;;767                    if (OSTCBCurPtr->MsgQPendTimeMax < OSTCBCurPtr->MsgQPendTime) {
;;;768                        OSTCBCurPtr->MsgQPendTimeMax = OSTCBCurPtr->MsgQPendTime;
;;;769                    }
;;;770    #endif
;;;771                 }
;;;772                *p_err = OS_ERR_NONE;
;;;773                 break;
;;;774    
;;;775            case OS_STATUS_PEND_ABORT:                          /* Indicate that we aborted                               */
;;;776                 p_void     = (void      *)0;
;;;777                *p_msg_size = (OS_MSG_SIZE)0;
;;;778                 if (p_ts  != (CPU_TS *)0) {
;;;779                    *p_ts   = (CPU_TS  )0;
;;;780                 }
;;;781                *p_err      =  OS_ERR_PEND_ABORT;
;;;782                 break;
;;;783    
;;;784            case OS_STATUS_PEND_TIMEOUT:                        /* Indicate that we didn't get event within TO            */
;;;785            default:
;;;786                 p_void     = (void      *)0;
;;;787                *p_msg_size = (OS_MSG_SIZE)0;
;;;788                 if (p_ts  != (CPU_TS *)0) {
;;;789                    *p_ts   =  OSTCBCurPtr->TS;
;;;790                 }
;;;791                *p_err      =  OS_ERR_TIMEOUT;
;;;792                 break;
;;;793        }
;;;794        CPU_CRITICAL_EXIT();
;;;795        return (p_void);                                        /* Return received message                                */
;;;796    }
00006e  e8bd8ff8          POP      {r3-r11,pc}
                  |L5.114|
000072  b154              CBZ      r4,|L5.138|
000074  f7fffffe          BL       CPU_TS_TmrRd
000078  6821              LDR      r1,[r4,#0]            ;727
00007a  1a40              SUBS     r0,r0,r1              ;727
00007c  f8d81000          LDR      r1,[r8,#0]            ;727  ; OSTCBCurPtr
000080  6748              STR      r0,[r1,#0x74]         ;728
000082  6f8a              LDR      r2,[r1,#0x78]         ;728
000084  4282              CMP      r2,r0                 ;728
000086  d200              BCS      |L5.138|
000088  6788              STR      r0,[r1,#0x78]         ;729
                  |L5.138|
00008a  9800              LDR      r0,[sp,#0]            ;733
00008c  f7fffffe          BL       CPU_SR_Restore
000090  4650              MOV      r0,r10                ;734
000092  e7ec              B        |L5.110|
                  |L5.148|
000094  482e              LDR      r0,|L5.336|
000096  7801              LDRB     r1,[r0,#0]            ;742  ; OSSchedLockNestingCtr
000098  b129              CBZ      r1,|L5.166|
00009a  9800              LDR      r0,[sp,#0]            ;743
00009c  f7fffffe          BL       CPU_SR_Restore
0000a0  f6465063          MOV      r0,#0x6d63            ;744
0000a4  e7c3              B        |L5.46|
                  |L5.166|
0000a6  4607              MOV      r7,r0                 ;749
0000a8  2001              MOVS     r0,#1                 ;749
0000aa  7038              STRB     r0,[r7,#0]            ;749
0000ac  9800              LDR      r0,[sp,#0]            ;749
0000ae  f7fffffe          BL       CPU_SR_Restore
0000b2  2100              MOVS     r1,#0                 ;750
0000b4  465b              MOV      r3,r11                ;750
0000b6  2202              MOVS     r2,#2                 ;750
0000b8  4608              MOV      r0,r1                 ;750
0000ba  f7fffffe          BL       OS_Pend
0000be  f7fffffe          BL       CPU_SR_Save
0000c2  7839              LDRB     r1,[r7,#0]            ;754  ; OSSchedLockNestingCtr
0000c4  1e49              SUBS     r1,r1,#1              ;754
0000c6  7039              STRB     r1,[r7,#0]            ;754
0000c8  f7fffffe          BL       CPU_SR_Restore
0000cc  f7fffffe          BL       OSSched
0000d0  f7fffffe          BL       CPU_SR_Save
0000d4  4682              MOV      r10,r0                ;758
0000d6  f8d80000          LDR      r0,[r8,#0]            ;759  ; OSTCBCurPtr
0000da  f8901035          LDRB     r1,[r0,#0x35]         ;759
0000de  b191              CBZ      r1,|L5.262|
0000e0  2901              CMP      r1,#1                 ;759
0000e2  f04f0700          MOV      r7,#0                 ;776
0000e6  d026              BEQ      |L5.310|
0000e8  f8a69000          STRH     r9,[r6,#0]            ;787
0000ec  b11c              CBZ      r4,|L5.246|
0000ee  f8d80000          LDR      r0,[r8,#0]            ;789  ; OSTCBCurPtr
0000f2  6c00              LDR      r0,[r0,#0x40]         ;789
0000f4  6020              STR      r0,[r4,#0]            ;789
                  |L5.246|
0000f6  f24720d9          MOV      r0,#0x72d9            ;791
                  |L5.250|
0000fa  8028              STRH     r0,[r5,#0]            ;781
                  |L5.252|
0000fc  4650              MOV      r0,r10                ;794
0000fe  f7fffffe          BL       CPU_SR_Restore
000102  4638              MOV      r0,r7                 ;795
000104  e7b3              B        |L5.110|
                  |L5.262|
000106  6dc7              LDR      r7,[r0,#0x5c]         ;762
000108  f8b00060          LDRH     r0,[r0,#0x60]         ;762
00010c  8030              STRH     r0,[r6,#0]            ;762
00010e  b17c              CBZ      r4,|L5.304|
000110  f8d80000          LDR      r0,[r8,#0]            ;764  ; OSTCBCurPtr
000114  6c00              LDR      r0,[r0,#0x40]         ;764
000116  6020              STR      r0,[r4,#0]            ;766
000118  f7fffffe          BL       CPU_TS_TmrRd
00011c  4601              MOV      r1,r0                 ;766
00011e  f8d80000          LDR      r0,[r8,#0]            ;766  ; OSTCBCurPtr
000122  6c02              LDR      r2,[r0,#0x40]         ;766
000124  1a89              SUBS     r1,r1,r2              ;766
000126  6741              STR      r1,[r0,#0x74]         ;767
000128  6f82              LDR      r2,[r0,#0x78]         ;767
00012a  428a              CMP      r2,r1                 ;767
00012c  d200              BCS      |L5.304|
00012e  6781              STR      r1,[r0,#0x78]         ;768
                  |L5.304|
000130  f8a59000          STRH     r9,[r5,#0]            ;772
000134  e7e2              B        |L5.252|
                  |L5.310|
000136  4648              MOV      r0,r9                 ;777
000138  f8a69000          STRH     r9,[r6,#0]            ;777
00013c  b104              CBZ      r4,|L5.320|
00013e  6020              STR      r0,[r4,#0]            ;779
                  |L5.320|
000140  f24610a9          MOV      r0,#0x61a9            ;781
000144  e7d9              B        |L5.250|
;;;797    #endif
                          ENDP

000146  0000              DCW      0x0000
                  |L5.328|
                          DCD      OSIntNestingCtr
                  |L5.332|
                          DCD      OSTCBCurPtr
                  |L5.336|
                          DCD      OSSchedLockNestingCtr

                          AREA ||i.OSTaskQPendAbort||, CODE, READONLY, ALIGN=2

                  OSTaskQPendAbort PROC
;;;827    #if (OS_CFG_TASK_Q_EN > 0u) && (OS_CFG_TASK_Q_PEND_ABORT_EN > 0u)
;;;828    CPU_BOOLEAN  OSTaskQPendAbort (OS_TCB  *p_tcb,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;829                                   OS_OPT   opt,
;;;830                                   OS_ERR  *p_err)
;;;831    {
000004  4605              MOV      r5,r0
;;;832        CPU_TS         ts;
;;;833        CPU_SR_ALLOC();
;;;834    
;;;835    
;;;836    
;;;837    #ifdef OS_SAFETY_CRITICAL
;;;838        if (p_err == (OS_ERR *)0) {
;;;839            OS_SAFETY_CRITICAL_EXCEPTION();
;;;840            return (DEF_FALSE);
;;;841        }
;;;842    #endif
;;;843    
;;;844    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;845        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from ISR ...                             */
000006  4822              LDR      r0,|L6.144|
000008  460f              MOV      r7,r1                 ;831
00000a  4614              MOV      r4,r2                 ;831
00000c  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
00000e  b110              CBZ      r0,|L6.22|
;;;846           *p_err = OS_ERR_PEND_ABORT_ISR;                      /* ... can't Pend Abort from an ISR                       */
000010  f24610aa          MOV      r0,#0x61aa
;;;847            return (DEF_FALSE);
000014  e005              B        |L6.34|
                  |L6.22|
;;;848        }
;;;849    #endif
;;;850    
;;;851    #if OS_CFG_ARG_CHK_EN > 0u                                  /* ---------------- VALIDATE ARGUMENTS ------------------ */
;;;852        switch (opt) {                                          /* User must supply a valid option                        */
000016  b137              CBZ      r7,|L6.38|
000018  f5b74f00          CMP      r7,#0x8000
00001c  d003              BEQ      |L6.38|
;;;853            case OS_OPT_POST_NONE:
;;;854            case OS_OPT_POST_NO_SCHED:
;;;855                 break;
;;;856    
;;;857            default:
;;;858                *p_err = OS_ERR_OPT_INVALID;
00001e  f6456025          MOV      r0,#0x5e25
                  |L6.34|
000022  8010              STRH     r0,[r2,#0]            ;846
000024  e014              B        |L6.80|
                  |L6.38|
;;;859                 return (DEF_FALSE);
;;;860        }
;;;861    #endif
;;;862    
;;;863        CPU_CRITICAL_ENTER();
000026  f7fffffe          BL       CPU_SR_Save
;;;864    #if OS_CFG_ARG_CHK_EN > 0u
;;;865        if ((p_tcb == (OS_TCB *)0) ||                           /* Pend abort self?                                       */
00002a  b11d              CBZ      r5,|L6.52|
;;;866            (p_tcb == OSTCBCurPtr)) {
00002c  4919              LDR      r1,|L6.148|
00002e  6809              LDR      r1,[r1,#0]  ; OSTCBCurPtr
000030  428d              CMP      r5,r1
000032  d104              BNE      |L6.62|
                  |L6.52|
;;;867            CPU_CRITICAL_EXIT();
000034  f7fffffe          BL       CPU_SR_Restore
;;;868           *p_err = OS_ERR_PEND_ABORT_SELF;                     /* ... doesn't make sense                                 */
000038  f24610ac          MOV      r0,#0x61ac
;;;869            return (DEF_FALSE);
00003c  e007              B        |L6.78|
                  |L6.62|
;;;870        }
;;;871    #endif
;;;872    
;;;873        if (p_tcb->PendOn != OS_TASK_PEND_ON_TASK_Q) {          /* Is task waiting for a message?                         */
00003e  f8951034          LDRB     r1,[r5,#0x34]
000042  2902              CMP      r1,#2
000044  d007              BEQ      |L6.86|
;;;874            CPU_CRITICAL_EXIT();                                /* No                                                     */
000046  f7fffffe          BL       CPU_SR_Restore
;;;875           *p_err = OS_ERR_PEND_ABORT_NONE;
00004a  f24610ab          MOV      r0,#0x61ab
                  |L6.78|
00004e  8020              STRH     r0,[r4,#0]
                  |L6.80|
;;;876            return (DEF_FALSE);
000050  2000              MOVS     r0,#0
                  |L6.82|
;;;877        }
;;;878    
;;;879        OS_CRITICAL_ENTER_CPU_CRITICAL_EXIT();
;;;880        ts = OS_TS_GET();                                       /* Get timestamp of when the abort occurred               */
;;;881        OS_PendAbort((OS_PEND_OBJ *)0,                          /* Abort the pend                                         */
;;;882                     p_tcb,
;;;883                     ts);
;;;884        OS_CRITICAL_EXIT_NO_SCHED();
;;;885        if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0) {
;;;886            OSSched();                                          /* Run the scheduler                                      */
;;;887        }
;;;888       *p_err = OS_ERR_NONE;
;;;889        return (DEF_TRUE);
;;;890    }
000052  e8bd81f0          POP      {r4-r8,pc}
                  |L6.86|
000056  4e10              LDR      r6,|L6.152|
000058  7831              LDRB     r1,[r6,#0]            ;879  ; OSSchedLockNestingCtr
00005a  1c49              ADDS     r1,r1,#1              ;879
00005c  7031              STRB     r1,[r6,#0]            ;879
00005e  f7fffffe          BL       CPU_SR_Restore
000062  f7fffffe          BL       CPU_TS_TmrRd
000066  4602              MOV      r2,r0                 ;880
000068  4629              MOV      r1,r5                 ;881
00006a  2000              MOVS     r0,#0                 ;881
00006c  f7fffffe          BL       OS_PendAbort
000070  f7fffffe          BL       CPU_SR_Save
000074  7831              LDRB     r1,[r6,#0]            ;884  ; OSSchedLockNestingCtr
000076  1e49              SUBS     r1,r1,#1              ;884
000078  7031              STRB     r1,[r6,#0]            ;884
00007a  f7fffffe          BL       CPU_SR_Restore
00007e  0438              LSLS     r0,r7,#16             ;885
000080  d401              BMI      |L6.134|
000082  f7fffffe          BL       OSSched
                  |L6.134|
000086  2000              MOVS     r0,#0                 ;888
000088  8020              STRH     r0,[r4,#0]            ;888
00008a  2001              MOVS     r0,#1                 ;889
00008c  e7e1              B        |L6.82|
;;;891    #endif
                          ENDP

00008e  0000              DCW      0x0000
                  |L6.144|
                          DCD      OSIntNestingCtr
                  |L6.148|
                          DCD      OSTCBCurPtr
                  |L6.152|
                          DCD      OSSchedLockNestingCtr

                          AREA ||i.OSTaskQPost||, CODE, READONLY, ALIGN=2

                  OSTaskQPost PROC
;;;929    #if OS_CFG_TASK_Q_EN > 0u
;;;930    void  OSTaskQPost (OS_TCB       *p_tcb,
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;931                       void         *p_void,
;;;932                       OS_MSG_SIZE   msg_size,
;;;933                       OS_OPT        opt,
;;;934                       OS_ERR       *p_err)
;;;935    {
000004  4616              MOV      r6,r2
000006  9d0a              LDR      r5,[sp,#0x28]
000008  001c              MOVS     r4,r3
00000a  460f              MOV      r7,r1
00000c  4680              MOV      r8,r0
00000e  d00d              BEQ      |L7.44|
;;;936        CPU_TS   ts;
;;;937    
;;;938    
;;;939    
;;;940    #ifdef OS_SAFETY_CRITICAL
;;;941        if (p_err == (OS_ERR *)0) {
;;;942            OS_SAFETY_CRITICAL_EXCEPTION();
;;;943            return;
;;;944        }
;;;945    #endif
;;;946    
;;;947    #if OS_CFG_ARG_CHK_EN > 0u                                  /* ---------------- VALIDATE ARGUMENTS ------------------ */
;;;948        switch (opt) {                                          /* User must supply a valid option                        */
000010  2c10              CMP      r4,#0x10
000012  d00b              BEQ      |L7.44|
000014  f5b44f00          CMP      r4,#0x8000
000018  d008              BEQ      |L7.44|
00001a  f5a44000          SUB      r0,r4,#0x8000
00001e  3810              SUBS     r0,r0,#0x10
000020  d004              BEQ      |L7.44|
;;;949            case OS_OPT_POST_FIFO:
;;;950            case OS_OPT_POST_LIFO:
;;;951            case OS_OPT_POST_FIFO | OS_OPT_POST_NO_SCHED:
;;;952            case OS_OPT_POST_LIFO | OS_OPT_POST_NO_SCHED:
;;;953                 break;
;;;954    
;;;955            default:
;;;956                *p_err = OS_ERR_OPT_INVALID;
000022  f6456025          MOV      r0,#0x5e25
000026  8028              STRH     r0,[r5,#0]
                  |L7.40|
;;;957                 return;
;;;958        }
;;;959    #endif
;;;960    
;;;961        ts = OS_TS_GET();                                       /* Get timestamp                                          */
;;;962    
;;;963    #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
;;;964        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {
;;;965            OS_IntQPost((OS_OBJ_TYPE)OS_OBJ_TYPE_TASK_MSG,      /* Post to ISR queue                                      */
;;;966                        (void      *)p_tcb,
;;;967                        (void      *)p_void,
;;;968                        (OS_MSG_SIZE)msg_size,
;;;969                        (OS_FLAGS   )0,
;;;970                        (OS_OPT     )opt,
;;;971                        (CPU_TS     )ts,
;;;972                        (OS_ERR    *)p_err);
;;;973            return;
;;;974        }
;;;975    #endif
;;;976    
;;;977        OS_TaskQPost(p_tcb,
;;;978                     p_void,
;;;979                     msg_size,
;;;980                     opt,
;;;981                     ts,
;;;982                     p_err);
;;;983    }
000028  e8bd81ff          POP      {r0-r8,pc}
                  |L7.44|
00002c  f7fffffe          BL       CPU_TS_TmrRd
000030  490b              LDR      r1,|L7.96|
000032  7809              LDRB     r1,[r1,#0]            ;964  ; OSIntNestingCtr
000034  b159              CBZ      r1,|L7.78|
000036  2100              MOVS     r1,#0                 ;965
000038  e9cd1400          STRD     r1,r4,[sp,#0]         ;965
00003c  e9cd0502          STRD     r0,r5,[sp,#8]         ;965
000040  4633              MOV      r3,r6                 ;965
000042  463a              MOV      r2,r7                 ;965
000044  4641              MOV      r1,r8                 ;965
000046  4807              LDR      r0,|L7.100|
000048  f7fffffe          BL       OS_IntQPost
00004c  e7ec              B        |L7.40|
                  |L7.78|
00004e  e9cd0500          STRD     r0,r5,[sp,#0]         ;977
000052  4623              MOV      r3,r4                 ;977
000054  4632              MOV      r2,r6                 ;977
000056  4639              MOV      r1,r7                 ;977
000058  4640              MOV      r0,r8                 ;977
00005a  f7fffffe          BL       OS_TaskQPost
00005e  e7e3              B        |L7.40|
;;;984    #endif
                          ENDP

                  |L7.96|
                          DCD      OSIntNestingCtr
                  |L7.100|
                          DCD      0x47534d54

                          AREA ||i.OSTaskRegGet||, CODE, READONLY, ALIGN=2

                  OSTaskRegGet PROC
;;;1010   #if OS_CFG_TASK_REG_TBL_SIZE > 0u
;;;1011   OS_REG  OSTaskRegGet (OS_TCB     *p_tcb,
000000  b570              PUSH     {r4-r6,lr}
;;;1012                         OS_REG_ID   id,
;;;1013                         OS_ERR     *p_err)
;;;1014   {
000002  4615              MOV      r5,r2
000004  4604              MOV      r4,r0
000006  b121              CBZ      r1,|L8.18|
;;;1015       OS_REG     value;
;;;1016       CPU_SR_ALLOC();
;;;1017   
;;;1018   
;;;1019   
;;;1020   #ifdef OS_SAFETY_CRITICAL
;;;1021       if (p_err == (OS_ERR *)0) {
;;;1022           OS_SAFETY_CRITICAL_EXCEPTION();
;;;1023           return ((OS_REG)0);
;;;1024       }
;;;1025   #endif
;;;1026   
;;;1027   #if OS_CFG_ARG_CHK_EN > 0u
;;;1028       if (id >= OS_CFG_TASK_REG_TBL_SIZE) {
;;;1029          *p_err = OS_ERR_REG_ID_INVALID;
000008  f6461079          MOV      r0,#0x6979
00000c  8010              STRH     r0,[r2,#0]
;;;1030           return ((OS_REG)0);
00000e  2000              MOVS     r0,#0
;;;1031       }
;;;1032   #endif
;;;1033   
;;;1034       CPU_CRITICAL_ENTER();
;;;1035       if (p_tcb == (OS_TCB *)0) {
;;;1036           p_tcb = OSTCBCurPtr;
;;;1037       }
;;;1038       value = p_tcb->RegTbl[id];
;;;1039       CPU_CRITICAL_EXIT();
;;;1040      *p_err = OS_ERR_NONE;
;;;1041       return ((OS_REG)value);
;;;1042   }
000010  bd70              POP      {r4-r6,pc}
                  |L8.18|
000012  f7fffffe          BL       CPU_SR_Save
000016  b90c              CBNZ     r4,|L8.28|
000018  4904              LDR      r1,|L8.44|
00001a  680c              LDR      r4,[r1,#0]            ;1036  ; OSTCBCurPtr
                  |L8.28|
00001c  6fe4              LDR      r4,[r4,#0x7c]         ;1038
00001e  f7fffffe          BL       CPU_SR_Restore
000022  2000              MOVS     r0,#0                 ;1040
000024  8028              STRH     r0,[r5,#0]            ;1040
000026  4620              MOV      r0,r4                 ;1041
000028  bd70              POP      {r4-r6,pc}
;;;1043   #endif
                          ENDP

00002a  0000              DCW      0x0000
                  |L8.44|
                          DCD      OSTCBCurPtr

                          AREA ||i.OSTaskRegGetID||, CODE, READONLY, ALIGN=2

                  OSTaskRegGetID PROC
;;;1063   #if OS_CFG_TASK_REG_TBL_SIZE > 0u
;;;1064   OS_REG_ID  OSTaskRegGetID (OS_ERR  *p_err)
000000  b510              PUSH     {r4,lr}
;;;1065   {
000002  4604              MOV      r4,r0
;;;1066       OS_REG_ID  id;
;;;1067       CPU_SR_ALLOC();
;;;1068   
;;;1069   
;;;1070   
;;;1071   #ifdef OS_SAFETY_CRITICAL
;;;1072       if (p_err == (OS_ERR *)0) {
;;;1073           OS_SAFETY_CRITICAL_EXCEPTION();
;;;1074           return ((OS_REG_ID)OS_CFG_TASK_REG_TBL_SIZE);
;;;1075       }
;;;1076   #endif
;;;1077   
;;;1078       CPU_CRITICAL_ENTER();
000004  f7fffffe          BL       CPU_SR_Save
;;;1079       if (OSTaskRegNextAvailID >= OS_CFG_TASK_REG_TBL_SIZE) {       /* See if we exceeded the number of IDs available   */
000008  4908              LDR      r1,|L9.44|
00000a  780a              LDRB     r2,[r1,#0]  ; OSTaskRegNextAvailID
00000c  b132              CBZ      r2,|L9.28|
;;;1080          *p_err = OS_ERR_NO_MORE_ID_AVAIL;                          /* Yes, cannot allocate more task register IDs      */
00000e  f64511da          MOV      r1,#0x59da
000012  8021              STRH     r1,[r4,#0]
;;;1081           CPU_CRITICAL_EXIT();
000014  f7fffffe          BL       CPU_SR_Restore
;;;1082           return ((OS_REG_ID)OS_CFG_TASK_REG_TBL_SIZE);
000018  2001              MOVS     r0,#1
;;;1083       }
;;;1084        
;;;1085       id    = OSTaskRegNextAvailID;								  /* Assign the next available ID                     */
;;;1086       OSTaskRegNextAvailID++;										  /* Increment available ID for next request          */
;;;1087       CPU_CRITICAL_EXIT();
;;;1088      *p_err = OS_ERR_NONE;
;;;1089       return (id);
;;;1090   }
00001a  bd10              POP      {r4,pc}
                  |L9.28|
00001c  2201              MOVS     r2,#1                 ;1086
00001e  700a              STRB     r2,[r1,#0]            ;1086
000020  f7fffffe          BL       CPU_SR_Restore
000024  2000              MOVS     r0,#0                 ;1088
000026  8020              STRH     r0,[r4,#0]            ;1088
000028  bd10              POP      {r4,pc}
;;;1091   #endif
                          ENDP

00002a  0000              DCW      0x0000
                  |L9.44|
                          DCD      OSTaskRegNextAvailID

                          AREA ||i.OSTaskRegSet||, CODE, READONLY, ALIGN=2

                  OSTaskRegSet PROC
;;;1119   #if OS_CFG_TASK_REG_TBL_SIZE > 0u
;;;1120   void  OSTaskRegSet (OS_TCB     *p_tcb,
000000  b570              PUSH     {r4-r6,lr}
;;;1121                       OS_REG_ID   id,
;;;1122                       OS_REG      value,
;;;1123                       OS_ERR     *p_err)
;;;1124   {
000002  461d              MOV      r5,r3
000004  4616              MOV      r6,r2
000006  4604              MOV      r4,r0
000008  b119              CBZ      r1,|L10.18|
;;;1125       CPU_SR_ALLOC();
;;;1126   
;;;1127   
;;;1128   
;;;1129   #ifdef OS_SAFETY_CRITICAL
;;;1130       if (p_err == (OS_ERR *)0) {
;;;1131           OS_SAFETY_CRITICAL_EXCEPTION();
;;;1132           return;
;;;1133       }
;;;1134   #endif
;;;1135   
;;;1136   #if OS_CFG_ARG_CHK_EN > 0u
;;;1137       if (id >= OS_CFG_TASK_REG_TBL_SIZE) {
;;;1138          *p_err = OS_ERR_REG_ID_INVALID;
00000a  f6461079          MOV      r0,#0x6979
00000e  8018              STRH     r0,[r3,#0]
;;;1139           return;
;;;1140       }
;;;1141   #endif
;;;1142   
;;;1143       CPU_CRITICAL_ENTER();
;;;1144       if (p_tcb == (OS_TCB *)0) {
;;;1145           p_tcb = OSTCBCurPtr;
;;;1146       }
;;;1147       p_tcb->RegTbl[id] = value;
;;;1148       CPU_CRITICAL_EXIT();
;;;1149      *p_err             = OS_ERR_NONE;
;;;1150   }
000010  bd70              POP      {r4-r6,pc}
                  |L10.18|
000012  f7fffffe          BL       CPU_SR_Save
000016  b90c              CBNZ     r4,|L10.28|
000018  4903              LDR      r1,|L10.40|
00001a  680c              LDR      r4,[r1,#0]            ;1145  ; OSTCBCurPtr
                  |L10.28|
00001c  67e6              STR      r6,[r4,#0x7c]         ;1148
00001e  f7fffffe          BL       CPU_SR_Restore
000022  2000              MOVS     r0,#0                 ;1149
000024  8028              STRH     r0,[r5,#0]            ;1149
000026  bd70              POP      {r4-r6,pc}
;;;1151   #endif
                          ENDP

                  |L10.40|
                          DCD      OSTCBCurPtr

                          AREA ||i.OSTaskResume||, CODE, READONLY, ALIGN=2

                  OSTaskResume PROC
;;;1175   #if OS_CFG_TASK_SUSPEND_EN > 0u
;;;1176   void  OSTaskResume (OS_TCB  *p_tcb,
000000  b57f              PUSH     {r0-r6,lr}
;;;1177                       OS_ERR  *p_err)
;;;1178   {
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
;;;1179       CPU_SR_ALLOC();
;;;1180   
;;;1181   
;;;1182   
;;;1183   #ifdef OS_SAFETY_CRITICAL
;;;1184       if (p_err == (OS_ERR *)0) {
;;;1185           OS_SAFETY_CRITICAL_EXCEPTION();
;;;1186           return;
;;;1187       }
;;;1188   #endif
;;;1189   
;;;1190   #if (OS_CFG_ISR_POST_DEFERRED_EN   == 0u) && \
;;;1191       (OS_CFG_CALLED_FROM_ISR_CHK_EN >  0u)
;;;1192       if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
;;;1193          *p_err = OS_ERR_TASK_RESUME_ISR;
;;;1194           return;
;;;1195       }
;;;1196   #endif
;;;1197   
;;;1198   
;;;1199       CPU_CRITICAL_ENTER();
000006  f7fffffe          BL       CPU_SR_Save
;;;1200   #if OS_CFG_ARG_CHK_EN > 0u
;;;1201       if ((p_tcb == (OS_TCB *)0) ||                           /* We cannot resume 'self'                                */
00000a  b11c              CBZ      r4,|L11.20|
;;;1202           (p_tcb == OSTCBCurPtr)) {
00000c  4910              LDR      r1,|L11.80|
00000e  6809              LDR      r1,[r1,#0]  ; OSTCBCurPtr
000010  428c              CMP      r4,r1
000012  d105              BNE      |L11.32|
                  |L11.20|
;;;1203           CPU_CRITICAL_EXIT();
000014  f7fffffe          BL       CPU_SR_Restore
;;;1204          *p_err  = OS_ERR_TASK_RESUME_SELF;
000018  f2471057          MOV      r0,#0x7157
00001c  8028              STRH     r0,[r5,#0]
;;;1205           return;
;;;1206       }
;;;1207   #endif
;;;1208       CPU_CRITICAL_EXIT();
;;;1209   
;;;1210   #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
;;;1211       if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from an ISR                              */
;;;1212           OS_IntQPost((OS_OBJ_TYPE)OS_OBJ_TYPE_TASK_RESUME,   /* Post to ISR queue                                      */
;;;1213                       (void      *)p_tcb,
;;;1214                       (void      *)0,
;;;1215                       (OS_MSG_SIZE)0,
;;;1216                       (OS_FLAGS   )0,
;;;1217                       (OS_OPT     )0,
;;;1218                       (CPU_TS     )0,
;;;1219                       (OS_ERR    *)p_err);
;;;1220           return;
;;;1221       }
;;;1222   #endif
;;;1223   
;;;1224       OS_TaskResume(p_tcb, p_err);
;;;1225   }
00001e  bd7f              POP      {r0-r6,pc}
                  |L11.32|
000020  f7fffffe          BL       CPU_SR_Restore
000024  480b              LDR      r0,|L11.84|
000026  7800              LDRB     r0,[r0,#0]            ;1211  ; OSIntNestingCtr
000028  b158              CBZ      r0,|L11.66|
00002a  2000              MOVS     r0,#0                 ;1212
00002c  e9cd0502          STRD     r0,r5,[sp,#8]         ;1212
000030  9000              STR      r0,[sp,#0]            ;1212
000032  4603              MOV      r3,r0                 ;1212
000034  4602              MOV      r2,r0                 ;1212
000036  9001              STR      r0,[sp,#4]            ;1212
000038  4621              MOV      r1,r4                 ;1212
00003a  4807              LDR      r0,|L11.88|
00003c  f7fffffe          BL       OS_IntQPost
000040  bd7f              POP      {r0-r6,pc}
                  |L11.66|
000042  b004              ADD      sp,sp,#0x10           ;1224
000044  4629              MOV      r1,r5                 ;1224
000046  4620              MOV      r0,r4                 ;1224
000048  e8bd4070          POP      {r4-r6,lr}            ;1224
00004c  f7ffbffe          B.W      OS_TaskResume
;;;1226   #endif
                          ENDP

                  |L11.80|
                          DCD      OSTCBCurPtr
                  |L11.84|
                          DCD      OSIntNestingCtr
                  |L11.88|
                          DCD      0x53455254

                          AREA ||i.OSTaskSemPend||, CODE, READONLY, ALIGN=2

                  OSTaskSemPend PROC
;;;1261   
;;;1262   OS_SEM_CTR  OSTaskSemPend (OS_TICK   timeout,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1263                              OS_OPT    opt,
;;;1264                              CPU_TS   *p_ts,
;;;1265                              OS_ERR   *p_err)
;;;1266   {
000004  4682              MOV      r10,r0
;;;1267       OS_SEM_CTR    ctr;
;;;1268       CPU_SR_ALLOC();
;;;1269   
;;;1270   
;;;1271   
;;;1272   #ifdef OS_SAFETY_CRITICAL
;;;1273       if (p_err == (OS_ERR *)0) {
;;;1274           OS_SAFETY_CRITICAL_EXCEPTION();
;;;1275           return ((OS_SEM_CTR)0);
;;;1276       }
;;;1277   #endif
;;;1278   
;;;1279   #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;1280       if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
000006  4849              LDR      r0,|L12.300|
000008  4614              MOV      r4,r2                 ;1266
00000a  4688              MOV      r8,r1                 ;1266
00000c  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
00000e  461e              MOV      r6,r3                 ;1266
000010  b110              CBZ      r0,|L12.24|
;;;1281          *p_err = OS_ERR_PEND_ISR;
000012  f24610ae          MOV      r0,#0x61ae
;;;1282           return ((OS_SEM_CTR)0);
000016  e005              B        |L12.36|
                  |L12.24|
;;;1283       }
;;;1284   #endif
;;;1285   
;;;1286   #if OS_CFG_ARG_CHK_EN > 0u
;;;1287       switch (opt) {                                          /* Validate 'opt'                                         */
000018  b131              CBZ      r1,|L12.40|
00001a  f5b14f00          CMP      r1,#0x8000
00001e  d003              BEQ      |L12.40|
;;;1288           case OS_OPT_PEND_BLOCKING:
;;;1289           case OS_OPT_PEND_NON_BLOCKING:
;;;1290                break;
;;;1291   
;;;1292           default:
;;;1293               *p_err = OS_ERR_OPT_INVALID;
000020  f6456025          MOV      r0,#0x5e25
                  |L12.36|
000024  8018              STRH     r0,[r3,#0]            ;1281
000026  e035              B        |L12.148|
                  |L12.40|
000028  2700              MOVS     r7,#0                 ;1281
;;;1294                return ((OS_SEM_CTR)0);
;;;1295       }
;;;1296   #endif
;;;1297   
;;;1298       if (p_ts != (CPU_TS *)0) {
00002a  b104              CBZ      r4,|L12.46|
;;;1299          *p_ts  = (CPU_TS  )0;                                /* Initialize the returned timestamp                      */
00002c  6027              STR      r7,[r4,#0]
                  |L12.46|
;;;1300       }
;;;1301   
;;;1302       CPU_CRITICAL_ENTER();
00002e  f7fffffe          BL       CPU_SR_Save
;;;1303       if (OSTCBCurPtr->SemCtr > (OS_SEM_CTR)0) {              /* See if task already been signaled                      */
000032  4d3f              LDR      r5,|L12.304|
000034  4681              MOV      r9,r0                 ;1302
000036  6829              LDR      r1,[r5,#0]  ; OSTCBCurPtr
000038  6c48              LDR      r0,[r1,#0x44]
00003a  b1c8              CBZ      r0,|L12.112|
;;;1304           OSTCBCurPtr->SemCtr--;
00003c  1e40              SUBS     r0,r0,#1
;;;1305           ctr    = OSTCBCurPtr->SemCtr;
00003e  4680              MOV      r8,r0
;;;1306           if (p_ts != (CPU_TS *)0) {
000040  6448              STR      r0,[r1,#0x44]
000042  b10c              CBZ      r4,|L12.72|
;;;1307              *p_ts  = OSTCBCurPtr->TS;
000044  6c08              LDR      r0,[r1,#0x40]
000046  6020              STR      r0,[r4,#0]
                  |L12.72|
;;;1308           }
;;;1309   #if OS_CFG_TASK_PROFILE_EN > 0u
;;;1310           OSTCBCurPtr->SemPendTime = OS_TS_GET() - OSTCBCurPtr->TS;
000048  f7fffffe          BL       CPU_TS_TmrRd
00004c  6829              LDR      r1,[r5,#0]  ; OSTCBCurPtr
00004e  6c0a              LDR      r2,[r1,#0x40]
000050  1a80              SUBS     r0,r0,r2
;;;1311           if (OSTCBCurPtr->SemPendTimeMax < OSTCBCurPtr->SemPendTime) {
000052  f8c100a4          STR      r0,[r1,#0xa4]
000056  f8d120a8          LDR      r2,[r1,#0xa8]
00005a  4282              CMP      r2,r0
00005c  d201              BCS      |L12.98|
;;;1312               OSTCBCurPtr->SemPendTimeMax = OSTCBCurPtr->SemPendTime;
00005e  f8c100a8          STR      r0,[r1,#0xa8]
                  |L12.98|
;;;1313           }
;;;1314   #endif
;;;1315           CPU_CRITICAL_EXIT();
000062  4648              MOV      r0,r9
000064  f7fffffe          BL       CPU_SR_Restore
;;;1316          *p_err = OS_ERR_NONE;
000068  8037              STRH     r7,[r6,#0]
;;;1317           return (ctr);
00006a  4640              MOV      r0,r8
                  |L12.108|
;;;1318       }
;;;1319   
;;;1320       if ((opt & OS_OPT_PEND_NON_BLOCKING) != (OS_OPT)0) {    /* Caller wants to block if not available?                */
;;;1321           CPU_CRITICAL_EXIT();
;;;1322          *p_err = OS_ERR_PEND_WOULD_BLOCK;                    /* No                                                     */
;;;1323           return ((OS_SEM_CTR)0);
;;;1324       } else {                                                /* Yes                                                    */
;;;1325           if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {    /* Can't pend when the scheduler is locked                */
;;;1326               CPU_CRITICAL_EXIT();
;;;1327              *p_err = OS_ERR_SCHED_LOCKED;
;;;1328               return ((OS_SEM_CTR)0);
;;;1329           }
;;;1330       }
;;;1331   
;;;1332       OS_CRITICAL_ENTER_CPU_CRITICAL_EXIT();                  /* Lock the scheduler/re-enable interrupts                */
;;;1333       OS_Pend((OS_PEND_DATA *)0,                              /* Block task pending on Signal                           */
;;;1334               (OS_PEND_OBJ  *)0,
;;;1335               (OS_STATE      )OS_TASK_PEND_ON_TASK_SEM,
;;;1336               (OS_TICK       )timeout);
;;;1337       OS_CRITICAL_EXIT_NO_SCHED();
;;;1338   
;;;1339       OSSched();                                              /* Find next highest priority task ready to run           */
;;;1340   
;;;1341       CPU_CRITICAL_ENTER();
;;;1342       switch (OSTCBCurPtr->PendStatus) {                      /* See if we timed-out or aborted                         */
;;;1343           case OS_STATUS_PEND_OK:
;;;1344                if (p_ts != (CPU_TS *)0) {
;;;1345                   *p_ts                    =  OSTCBCurPtr->TS;
;;;1346   #if OS_CFG_TASK_PROFILE_EN > 0u
;;;1347                   OSTCBCurPtr->SemPendTime = OS_TS_GET() - OSTCBCurPtr->TS;
;;;1348                   if (OSTCBCurPtr->SemPendTimeMax < OSTCBCurPtr->SemPendTime) {
;;;1349                       OSTCBCurPtr->SemPendTimeMax = OSTCBCurPtr->SemPendTime;
;;;1350                   }
;;;1351   #endif
;;;1352                }
;;;1353               *p_err = OS_ERR_NONE;
;;;1354                break;
;;;1355   
;;;1356           case OS_STATUS_PEND_ABORT:
;;;1357                if (p_ts != (CPU_TS *)0) {
;;;1358                   *p_ts  =  OSTCBCurPtr->TS;
;;;1359                }
;;;1360               *p_err = OS_ERR_PEND_ABORT;                     /* Indicate that we aborted                               */
;;;1361                break;
;;;1362   
;;;1363           case OS_STATUS_PEND_TIMEOUT:
;;;1364                if (p_ts != (CPU_TS *)0) {
;;;1365                   *p_ts  = (CPU_TS  )0;
;;;1366                }
;;;1367               *p_err = OS_ERR_TIMEOUT;                        /* Indicate that we didn't get event within TO            */
;;;1368                break;
;;;1369   
;;;1370           default:
;;;1371               *p_err = OS_ERR_STATUS_INVALID;
;;;1372                break;
;;;1373       }
;;;1374       ctr = OSTCBCurPtr->SemCtr;
;;;1375       CPU_CRITICAL_EXIT();
;;;1376       return (ctr);
;;;1377   }
00006c  e8bd87f0          POP      {r4-r10,pc}
                  |L12.112|
000070  ea5f4008          LSLS     r0,r8,#16             ;1320
000074  d505              BPL      |L12.130|
000076  4648              MOV      r0,r9                 ;1321
000078  f7fffffe          BL       CPU_SR_Restore
00007c  f24610b0          MOV      r0,#0x61b0            ;1322
000080  e007              B        |L12.146|
                  |L12.130|
000082  482c              LDR      r0,|L12.308|
000084  7801              LDRB     r1,[r0,#0]            ;1325  ; OSSchedLockNestingCtr
000086  b139              CBZ      r1,|L12.152|
000088  4648              MOV      r0,r9                 ;1326
00008a  f7fffffe          BL       CPU_SR_Restore
00008e  f6465063          MOV      r0,#0x6d63            ;1327
                  |L12.146|
000092  8030              STRH     r0,[r6,#0]            ;1327
                  |L12.148|
000094  2000              MOVS     r0,#0                 ;1328
000096  e7e9              B        |L12.108|
                  |L12.152|
000098  4680              MOV      r8,r0                 ;1332
00009a  2001              MOVS     r0,#1                 ;1332
00009c  f8880000          STRB     r0,[r8,#0]            ;1332
0000a0  4648              MOV      r0,r9                 ;1332
0000a2  f7fffffe          BL       CPU_SR_Restore
0000a6  2100              MOVS     r1,#0                 ;1333
0000a8  4653              MOV      r3,r10                ;1333
0000aa  2207              MOVS     r2,#7                 ;1333
0000ac  4608              MOV      r0,r1                 ;1333
0000ae  f7fffffe          BL       OS_Pend
0000b2  f7fffffe          BL       CPU_SR_Save
0000b6  f8981000          LDRB     r1,[r8,#0]            ;1337  ; OSSchedLockNestingCtr
0000ba  1e49              SUBS     r1,r1,#1              ;1337
0000bc  f8881000          STRB     r1,[r8,#0]            ;1337
0000c0  f7fffffe          BL       CPU_SR_Restore
0000c4  f7fffffe          BL       OSSched
0000c8  f7fffffe          BL       CPU_SR_Save
0000cc  4680              MOV      r8,r0                 ;1341
0000ce  6828              LDR      r0,[r5,#0]            ;1342  ; OSTCBCurPtr
0000d0  f8901035          LDRB     r1,[r0,#0x35]         ;1342
0000d4  b131              CBZ      r1,|L12.228|
0000d6  2901              CMP      r1,#1                 ;1342
0000d8  d016              BEQ      |L12.264|
0000da  2903              CMP      r1,#3                 ;1342
0000dc  d01a              BEQ      |L12.276|
0000de  f646602e          MOV      r0,#0x6e2e            ;1371
0000e2  e01b              B        |L12.284|
                  |L12.228|
0000e4  b174              CBZ      r4,|L12.260|
0000e6  6c00              LDR      r0,[r0,#0x40]         ;1345
0000e8  6020              STR      r0,[r4,#0]            ;1347
0000ea  f7fffffe          BL       CPU_TS_TmrRd
0000ee  6829              LDR      r1,[r5,#0]            ;1347  ; OSTCBCurPtr
0000f0  6c0a              LDR      r2,[r1,#0x40]         ;1347
0000f2  1a80              SUBS     r0,r0,r2              ;1347
0000f4  f8c100a4          STR      r0,[r1,#0xa4]         ;1348
0000f8  f8d120a8          LDR      r2,[r1,#0xa8]         ;1348
0000fc  4282              CMP      r2,r0                 ;1348
0000fe  d201              BCS      |L12.260|
000100  f8c100a8          STR      r0,[r1,#0xa8]         ;1349
                  |L12.260|
000104  8037              STRH     r7,[r6,#0]            ;1353
000106  e00a              B        |L12.286|
                  |L12.264|
000108  b10c              CBZ      r4,|L12.270|
00010a  6c00              LDR      r0,[r0,#0x40]         ;1358
00010c  6020              STR      r0,[r4,#0]            ;1358
                  |L12.270|
00010e  f24610a9          MOV      r0,#0x61a9            ;1360
000112  e003              B        |L12.284|
                  |L12.276|
000114  b104              CBZ      r4,|L12.280|
000116  6027              STR      r7,[r4,#0]            ;1365
                  |L12.280|
000118  f24720d9          MOV      r0,#0x72d9            ;1367
                  |L12.284|
00011c  8030              STRH     r0,[r6,#0]            ;1360
                  |L12.286|
00011e  6828              LDR      r0,[r5,#0]            ;1374  ; OSTCBCurPtr
000120  6c44              LDR      r4,[r0,#0x44]         ;1375
000122  4640              MOV      r0,r8                 ;1375
000124  f7fffffe          BL       CPU_SR_Restore
000128  4620              MOV      r0,r4                 ;1376
00012a  e79f              B        |L12.108|
;;;1378   
                          ENDP

                  |L12.300|
                          DCD      OSIntNestingCtr
                  |L12.304|
                          DCD      OSTCBCurPtr
                  |L12.308|
                          DCD      OSSchedLockNestingCtr

                          AREA ||i.OSTaskSemPendAbort||, CODE, READONLY, ALIGN=2

                  OSTaskSemPendAbort PROC
;;;1408   #if OS_CFG_TASK_SEM_PEND_ABORT_EN > 0u
;;;1409   CPU_BOOLEAN  OSTaskSemPendAbort (OS_TCB  *p_tcb,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1410                                    OS_OPT   opt,
;;;1411                                    OS_ERR  *p_err)
;;;1412   {
000004  4605              MOV      r5,r0
;;;1413       CPU_TS         ts;
;;;1414       CPU_SR_ALLOC();
;;;1415   
;;;1416   
;;;1417   
;;;1418   #ifdef OS_SAFETY_CRITICAL
;;;1419       if (p_err == (OS_ERR *)0) {
;;;1420           OS_SAFETY_CRITICAL_EXCEPTION();
;;;1421           return (DEF_FALSE);
;;;1422       }
;;;1423   #endif
;;;1424   
;;;1425   #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;1426       if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from ISR ...                             */
000006  4824              LDR      r0,|L13.152|
000008  460f              MOV      r7,r1                 ;1412
00000a  4614              MOV      r4,r2                 ;1412
00000c  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
00000e  b110              CBZ      r0,|L13.22|
;;;1427          *p_err = OS_ERR_PEND_ABORT_ISR;                      /* ... can't Pend Abort from an ISR                       */
000010  f24610aa          MOV      r0,#0x61aa
;;;1428           return (DEF_FALSE);
000014  e005              B        |L13.34|
                  |L13.22|
;;;1429       }
;;;1430   #endif
;;;1431   
;;;1432   #if OS_CFG_ARG_CHK_EN > 0u
;;;1433       switch (opt) {                                          /* Validate 'opt'                                         */
000016  b137              CBZ      r7,|L13.38|
000018  f5b74f00          CMP      r7,#0x8000
00001c  d003              BEQ      |L13.38|
;;;1434           case OS_OPT_POST_NONE:
;;;1435           case OS_OPT_POST_NO_SCHED:
;;;1436                break;
;;;1437   
;;;1438           default:
;;;1439               *p_err =  OS_ERR_OPT_INVALID;
00001e  f6456025          MOV      r0,#0x5e25
                  |L13.34|
000022  8010              STRH     r0,[r2,#0]            ;1427
000024  e014              B        |L13.80|
                  |L13.38|
;;;1440                return (DEF_FALSE);
;;;1441       }
;;;1442   #endif
;;;1443   
;;;1444       CPU_CRITICAL_ENTER();
000026  f7fffffe          BL       CPU_SR_Save
;;;1445       if ((p_tcb == (OS_TCB *)0) ||                           /* Pend abort self?                                       */
00002a  b11d              CBZ      r5,|L13.52|
;;;1446           (p_tcb == OSTCBCurPtr)) {
00002c  491b              LDR      r1,|L13.156|
00002e  6809              LDR      r1,[r1,#0]  ; OSTCBCurPtr
000030  428d              CMP      r5,r1
000032  d104              BNE      |L13.62|
                  |L13.52|
;;;1447           CPU_CRITICAL_EXIT();                                /* ... doesn't make sense!                                */
000034  f7fffffe          BL       CPU_SR_Restore
;;;1448          *p_err = OS_ERR_PEND_ABORT_SELF;
000038  f24610ac          MOV      r0,#0x61ac
;;;1449           return (DEF_FALSE);
00003c  e007              B        |L13.78|
                  |L13.62|
;;;1450       }
;;;1451   
;;;1452       if (p_tcb->PendOn != OS_TASK_PEND_ON_TASK_SEM) {        /* Is task waiting for a signal?                          */
00003e  f8951034          LDRB     r1,[r5,#0x34]
000042  2907              CMP      r1,#7
000044  d007              BEQ      |L13.86|
;;;1453           CPU_CRITICAL_EXIT();
000046  f7fffffe          BL       CPU_SR_Restore
;;;1454          *p_err = OS_ERR_PEND_ABORT_NONE;
00004a  f24610ab          MOV      r0,#0x61ab
                  |L13.78|
00004e  8020              STRH     r0,[r4,#0]
                  |L13.80|
;;;1455           return (DEF_FALSE);
000050  2000              MOVS     r0,#0
                  |L13.82|
;;;1456       }
;;;1457       CPU_CRITICAL_EXIT();
;;;1458   
;;;1459       OS_CRITICAL_ENTER();
;;;1460       ts = OS_TS_GET();
;;;1461       OS_PendAbort((OS_PEND_OBJ *)0,
;;;1462                    p_tcb,
;;;1463                    ts);
;;;1464       OS_CRITICAL_EXIT_NO_SCHED();
;;;1465       if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0) {
;;;1466           OSSched();                                          /* Run the scheduler                                      */
;;;1467       }
;;;1468      *p_err = OS_ERR_NONE;
;;;1469       return (DEF_TRUE);
;;;1470   }
000052  e8bd81f0          POP      {r4-r8,pc}
                  |L13.86|
000056  f7fffffe          BL       CPU_SR_Restore
00005a  f7fffffe          BL       CPU_SR_Save
00005e  4e10              LDR      r6,|L13.160|
000060  7831              LDRB     r1,[r6,#0]            ;1459  ; OSSchedLockNestingCtr
000062  1c49              ADDS     r1,r1,#1              ;1459
000064  7031              STRB     r1,[r6,#0]            ;1459
000066  f7fffffe          BL       CPU_SR_Restore
00006a  f7fffffe          BL       CPU_TS_TmrRd
00006e  4602              MOV      r2,r0                 ;1460
000070  4629              MOV      r1,r5                 ;1461
000072  2000              MOVS     r0,#0                 ;1461
000074  f7fffffe          BL       OS_PendAbort
000078  f7fffffe          BL       CPU_SR_Save
00007c  7831              LDRB     r1,[r6,#0]            ;1464  ; OSSchedLockNestingCtr
00007e  1e49              SUBS     r1,r1,#1              ;1464
000080  7031              STRB     r1,[r6,#0]            ;1464
000082  f7fffffe          BL       CPU_SR_Restore
000086  0438              LSLS     r0,r7,#16             ;1465
000088  d401              BMI      |L13.142|
00008a  f7fffffe          BL       OSSched
                  |L13.142|
00008e  2000              MOVS     r0,#0                 ;1468
000090  8020              STRH     r0,[r4,#0]            ;1468
000092  2001              MOVS     r0,#1                 ;1469
000094  e7dd              B        |L13.82|
;;;1471   #endif
                          ENDP

000096  0000              DCW      0x0000
                  |L13.152|
                          DCD      OSIntNestingCtr
                  |L13.156|
                          DCD      OSTCBCurPtr
                  |L13.160|
                          DCD      OSSchedLockNestingCtr

                          AREA ||i.OSTaskSemPost||, CODE, READONLY, ALIGN=2

                  OSTaskSemPost PROC
;;;1496   
;;;1497   OS_SEM_CTR  OSTaskSemPost (OS_TCB  *p_tcb,
000000  b57f              PUSH     {r0-r6,lr}
;;;1498                              OS_OPT   opt,
;;;1499                              OS_ERR  *p_err)
;;;1500   {
000002  000d              MOVS     r5,r1
000004  4606              MOV      r6,r0
000006  4614              MOV      r4,r2
000008  d006              BEQ      |L14.24|
;;;1501       OS_SEM_CTR  ctr;
;;;1502       CPU_TS      ts;
;;;1503   
;;;1504   
;;;1505   
;;;1506   #ifdef OS_SAFETY_CRITICAL
;;;1507       if (p_err == (OS_ERR *)0) {
;;;1508           OS_SAFETY_CRITICAL_EXCEPTION();
;;;1509           return ((OS_SEM_CTR)0);
;;;1510       }
;;;1511   #endif
;;;1512   
;;;1513   #if OS_CFG_ARG_CHK_EN > 0u
;;;1514       switch (opt) {                                          /* Validate 'opt'                                         */
00000a  f5b54f00          CMP      r5,#0x8000
00000e  d003              BEQ      |L14.24|
;;;1515           case OS_OPT_POST_NONE:
;;;1516           case OS_OPT_POST_NO_SCHED:
;;;1517                break;
;;;1518   
;;;1519           default:
;;;1520               *p_err =  OS_ERR_OPT_INVALID;
000010  f6456025          MOV      r0,#0x5e25
000014  8010              STRH     r0,[r2,#0]
;;;1521                return ((OS_SEM_CTR)0u);
000016  e00f              B        |L14.56|
                  |L14.24|
;;;1522       }
;;;1523   #endif
;;;1524   
;;;1525       ts = OS_TS_GET();                                       /* Get timestamp                                          */
000018  f7fffffe          BL       CPU_TS_TmrRd
00001c  4602              MOV      r2,r0
;;;1526   
;;;1527   #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
;;;1528       if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from an ISR                              */
00001e  480c              LDR      r0,|L14.80|
000020  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
000022  b160              CBZ      r0,|L14.62|
;;;1529           OS_IntQPost((OS_OBJ_TYPE)OS_OBJ_TYPE_TASK_SIGNAL,   /* Post to ISR queue                                      */
000024  2000              MOVS     r0,#0
000026  a901              ADD      r1,sp,#4
000028  9000              STR      r0,[sp,#0]
00002a  c115              STM      r1!,{r0,r2,r4}
00002c  4603              MOV      r3,r0
00002e  4602              MOV      r2,r0
000030  4631              MOV      r1,r6
000032  4808              LDR      r0,|L14.84|
000034  f7fffffe          BL       OS_IntQPost
                  |L14.56|
;;;1530                       (void      *)p_tcb,
;;;1531                       (void      *)0,
;;;1532                       (OS_MSG_SIZE)0,
;;;1533                       (OS_FLAGS   )0,
;;;1534                       (OS_OPT     )0,
;;;1535                       (CPU_TS     )ts,
;;;1536                       (OS_ERR    *)p_err);
;;;1537           return ((OS_SEM_CTR)0);
;;;1538       }
;;;1539   #endif
;;;1540   
;;;1541       ctr = OS_TaskSemPost(p_tcb,
;;;1542                            opt,
;;;1543                            ts,
;;;1544                            p_err);
;;;1545   
;;;1546       return (ctr);
;;;1547   }
000038  b004              ADD      sp,sp,#0x10
00003a  2000              MOVS     r0,#0                 ;1537
00003c  bd70              POP      {r4-r6,pc}
                  |L14.62|
00003e  b004              ADD      sp,sp,#0x10           ;1541
000040  4623              MOV      r3,r4                 ;1541
000042  4629              MOV      r1,r5                 ;1541
000044  4630              MOV      r0,r6                 ;1541
000046  e8bd4070          POP      {r4-r6,lr}            ;1541
00004a  f7ffbffe          B.W      OS_TaskSemPost
;;;1548   
                          ENDP

00004e  0000              DCW      0x0000
                  |L14.80|
                          DCD      OSIntNestingCtr
                  |L14.84|
                          DCD      0x47495354

                          AREA ||i.OSTaskSemSet||, CODE, READONLY, ALIGN=2

                  OSTaskSemSet PROC
;;;1569   
;;;1570   OS_SEM_CTR  OSTaskSemSet (OS_TCB      *p_tcb,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1571                             OS_SEM_CTR   cnt,
;;;1572                             OS_ERR      *p_err)
;;;1573   {
000004  4604              MOV      r4,r0
;;;1574       OS_SEM_CTR  ctr;
;;;1575       CPU_SR_ALLOC();
;;;1576   
;;;1577   
;;;1578   
;;;1579   #ifdef OS_SAFETY_CRITICAL
;;;1580       if (p_err == (OS_ERR *)0) {
;;;1581           OS_SAFETY_CRITICAL_EXCEPTION();
;;;1582           return ((OS_SEM_CTR)0);
;;;1583       }
;;;1584   #endif
;;;1585   
;;;1586   #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;1587       if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
000006  480c              LDR      r0,|L15.56|
000008  460f              MOV      r7,r1                 ;1573
00000a  4615              MOV      r5,r2                 ;1573
00000c  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
00000e  b128              CBZ      r0,|L15.28|
;;;1588          *p_err = OS_ERR_SET_ISR;
000010  f64650c6          MOV      r0,#0x6dc6
000014  8010              STRH     r0,[r2,#0]
;;;1589           return ((OS_SEM_CTR)0);
000016  2000              MOVS     r0,#0
                  |L15.24|
;;;1590       }
;;;1591   #endif
;;;1592   
;;;1593       CPU_CRITICAL_ENTER();
;;;1594       if (p_tcb == (OS_TCB *)0) {
;;;1595           p_tcb = OSTCBCurPtr;
;;;1596       }
;;;1597       ctr           = p_tcb->SemCtr;
;;;1598       p_tcb->SemCtr = (OS_SEM_CTR)cnt;
;;;1599       CPU_CRITICAL_EXIT();
;;;1600      *p_err         =  OS_ERR_NONE;
;;;1601       return (ctr);
;;;1602   }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L15.28|
00001c  f7fffffe          BL       CPU_SR_Save
000020  b90c              CBNZ     r4,|L15.38|
000022  4906              LDR      r1,|L15.60|
000024  680c              LDR      r4,[r1,#0]            ;1595  ; OSTCBCurPtr
                  |L15.38|
000026  6c66              LDR      r6,[r4,#0x44]         ;1598
000028  6467              STR      r7,[r4,#0x44]         ;1599
00002a  f7fffffe          BL       CPU_SR_Restore
00002e  2000              MOVS     r0,#0                 ;1600
000030  8028              STRH     r0,[r5,#0]            ;1600
000032  4630              MOV      r0,r6                 ;1601
000034  e7f0              B        |L15.24|
;;;1603   
                          ENDP

000036  0000              DCW      0x0000
                  |L15.56|
                          DCD      OSIntNestingCtr
                  |L15.60|
                          DCD      OSTCBCurPtr

                          AREA ||i.OSTaskStkChk||, CODE, READONLY, ALIGN=2

                  OSTaskStkChk PROC
;;;1629   #if OS_CFG_STAT_TASK_STK_CHK_EN > 0u
;;;1630   void  OSTaskStkChk (OS_TCB        *p_tcb,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1631                       CPU_STK_SIZE  *p_free,
;;;1632                       CPU_STK_SIZE  *p_used,
;;;1633                       OS_ERR        *p_err)
;;;1634   {
000004  4605              MOV      r5,r0
;;;1635       CPU_STK_SIZE  free_stk;
;;;1636       CPU_STK      *p_stk;
;;;1637       CPU_SR_ALLOC();
;;;1638   
;;;1639   
;;;1640   
;;;1641   #ifdef OS_SAFETY_CRITICAL
;;;1642       if (p_err == (OS_ERR *)0) {
;;;1643           OS_SAFETY_CRITICAL_EXCEPTION();
;;;1644           return;
;;;1645       }
;;;1646   #endif
;;;1647   
;;;1648   #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;1649       if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if trying to check stack from ISR                  */
000006  4821              LDR      r0,|L16.140|
000008  4616              MOV      r6,r2                 ;1634
00000a  460f              MOV      r7,r1                 ;1634
00000c  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
00000e  461c              MOV      r4,r3                 ;1634
000010  b110              CBZ      r0,|L16.24|
;;;1650          *p_err = OS_ERR_TASK_STK_CHK_ISR;
000012  f2471059          MOV      r0,#0x7159
;;;1651           return;
000016  e007              B        |L16.40|
                  |L16.24|
;;;1652       }
;;;1653   #endif
;;;1654   
;;;1655   #if OS_CFG_ARG_CHK_EN > 0u
;;;1656       if (p_free == (CPU_STK_SIZE*)0) {                       /* User must specify valid destinations for the sizes     */
;;;1657          *p_err  = OS_ERR_PTR_INVALID;
000018  f24620d5          MOV      r0,#0x62d5
00001c  b127              CBZ      r7,|L16.40|
;;;1658           return;
;;;1659       }
;;;1660   
;;;1661       if (p_used == (CPU_STK_SIZE*)0) {
00001e  b11e              CBZ      r6,|L16.40|
;;;1662          *p_err  = OS_ERR_PTR_INVALID;
;;;1663           return;
;;;1664       }
;;;1665   #endif
;;;1666   
;;;1667       CPU_CRITICAL_ENTER();
000020  f7fffffe          BL       CPU_SR_Save
;;;1668       if (p_tcb == (OS_TCB *)0) {                             /* Check the stack of the current task?                   */
000024  b11d              CBZ      r5,|L16.46|
000026  e004              B        |L16.50|
                  |L16.40|
000028  8018              STRH     r0,[r3,#0]            ;1662
                  |L16.42|
;;;1669           p_tcb = OSTCBCurPtr;                                /* Yes                                                    */
;;;1670       }
;;;1671   
;;;1672       if (p_tcb->StkPtr == (CPU_STK*)0) {                     /* Make sure task exist                                   */
;;;1673           CPU_CRITICAL_EXIT();
;;;1674          *p_free = (CPU_STK_SIZE)0;
;;;1675          *p_used = (CPU_STK_SIZE)0;
;;;1676          *p_err  =  OS_ERR_TASK_NOT_EXIST;
;;;1677           return;
;;;1678       }
;;;1679   
;;;1680       if ((p_tcb->Opt & OS_OPT_TASK_STK_CHK) == (OS_OPT)0) {  /* Make sure stack checking option is set                 */
;;;1681           CPU_CRITICAL_EXIT();
;;;1682          *p_free = (CPU_STK_SIZE)0;
;;;1683          *p_used = (CPU_STK_SIZE)0;
;;;1684          *p_err  =  OS_ERR_TASK_OPT;
;;;1685           return;
;;;1686       }
;;;1687       CPU_CRITICAL_EXIT();
;;;1688   
;;;1689       free_stk  = 0u;
;;;1690   #if CPU_CFG_STK_GROWTH == CPU_STK_GROWTH_HI_TO_LO
;;;1691       p_stk = p_tcb->StkBasePtr;                              /* Start at the lowest memory and go up                   */
;;;1692       while (*p_stk == (CPU_STK)0) {                          /* Compute the number of zero entries on the stk          */
;;;1693           p_stk++;
;;;1694           free_stk++;
;;;1695       }
;;;1696   #else
;;;1697       p_stk = p_tcb->StkBasePtr + p_tcb->StkSize - 1u;        /* Start at the highest memory and go down                */
;;;1698       while (*p_stk == (CPU_STK)0) {
;;;1699           free_stk++;
;;;1700           p_stk--;
;;;1701       }
;;;1702   #endif
;;;1703      *p_free = free_stk;
;;;1704      *p_used = (p_tcb->StkSize - free_stk);                   /* Compute number of entries used on the stack            */
;;;1705      *p_err  = OS_ERR_NONE;
;;;1706   }
00002a  e8bd81f0          POP      {r4-r8,pc}
                  |L16.46|
00002e  4918              LDR      r1,|L16.144|
000030  680d              LDR      r5,[r1,#0]            ;1669  ; OSTCBCurPtr
                  |L16.50|
000032  f04f0800          MOV      r8,#0                 ;1672
000036  6829              LDR      r1,[r5,#0]            ;1672
000038  b141              CBZ      r1,|L16.76|
00003a  f895103c          LDRB     r1,[r5,#0x3c]         ;1680
00003e  07c9              LSLS     r1,r1,#31             ;1680
000040  d00d              BEQ      |L16.94|
000042  f7fffffe          BL       CPU_SR_Restore
000046  2000              MOVS     r0,#0                 ;1689
000048  6a69              LDR      r1,[r5,#0x24]         ;1692
00004a  e014              B        |L16.118|
                  |L16.76|
00004c  f7fffffe          BL       CPU_SR_Restore
000050  f8c78000          STR      r8,[r7,#0]            ;1675
000054  f2471052          MOV      r0,#0x7152            ;1676
000058  f8c68000          STR      r8,[r6,#0]            ;1677
00005c  e007              B        |L16.110|
                  |L16.94|
00005e  f7fffffe          BL       CPU_SR_Restore
000062  f8c78000          STR      r8,[r7,#0]            ;1683
000066  f2471054          MOV      r0,#0x7154            ;1684
00006a  f8c68000          STR      r8,[r6,#0]            ;1684
                  |L16.110|
00006e  8020              STRH     r0,[r4,#0]            ;1684
000070  e7db              B        |L16.42|
                  |L16.114|
000072  1d09              ADDS     r1,r1,#4              ;1693
000074  1c40              ADDS     r0,r0,#1              ;1694
                  |L16.118|
000076  680a              LDR      r2,[r1,#0]            ;1692
000078  2a00              CMP      r2,#0                 ;1692
00007a  d0fa              BEQ      |L16.114|
00007c  6038              STR      r0,[r7,#0]            ;1704
00007e  6ba9              LDR      r1,[r5,#0x38]         ;1704
000080  1a08              SUBS     r0,r1,r0              ;1704
000082  6030              STR      r0,[r6,#0]            ;1705
000084  f8a48000          STRH     r8,[r4,#0]            ;1705
000088  e7cf              B        |L16.42|
;;;1707   #endif
                          ENDP

00008a  0000              DCW      0x0000
                  |L16.140|
                          DCD      OSIntNestingCtr
                  |L16.144|
                          DCD      OSTCBCurPtr

                          AREA ||i.OSTaskSuspend||, CODE, READONLY, ALIGN=2

                  OSTaskSuspend PROC
;;;1737   #if OS_CFG_TASK_SUSPEND_EN > 0u
;;;1738   void   OSTaskSuspend (OS_TCB  *p_tcb,
000000  b51f              PUSH     {r0-r4,lr}
;;;1739                         OS_ERR  *p_err)
;;;1740   {
;;;1741   #ifdef OS_SAFETY_CRITICAL
;;;1742       if (p_err == (OS_ERR *)0) {
;;;1743           OS_SAFETY_CRITICAL_EXCEPTION();
;;;1744           return;
;;;1745       }
;;;1746   #endif
;;;1747   
;;;1748   #if (OS_CFG_ISR_POST_DEFERRED_EN   == 0u) && \
;;;1749       (OS_CFG_CALLED_FROM_ISR_CHK_EN >  0u)
;;;1750       if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
;;;1751          *p_err = OS_ERR_TASK_SUSPEND_ISR;
;;;1752           return;
;;;1753       }
;;;1754   #endif
;;;1755   
;;;1756       if (p_tcb == &OSIdleTaskTCB) {                          /* Make sure not suspending the idle task                 */
000002  4a10              LDR      r2,|L17.68|
000004  4290              CMP      r0,r2
000006  d102              BNE      |L17.14|
;;;1757          *p_err = OS_ERR_TASK_SUSPEND_IDLE;
000008  f247105b          MOV      r0,#0x715b
;;;1758           return;
00000c  e004              B        |L17.24|
                  |L17.14|
;;;1759       }
;;;1760   
;;;1761   #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
;;;1762       if (p_tcb == &OSIntQTaskTCB) {                          /* Not allowed to suspend the ISR handler task            */
00000e  4a0e              LDR      r2,|L17.72|
000010  4290              CMP      r0,r2
000012  d103              BNE      |L17.28|
;;;1763          *p_err = OS_ERR_TASK_SUSPEND_INT_HANDLER;
000014  f247105c          MOV      r0,#0x715c
                  |L17.24|
000018  8008              STRH     r0,[r1,#0]
;;;1764           return;
;;;1765       }
;;;1766   
;;;1767       if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from an ISR                              */
;;;1768           OS_IntQPost((OS_OBJ_TYPE)OS_OBJ_TYPE_TASK_SUSPEND,  /* Post to ISR queue                                      */
;;;1769                       (void      *)p_tcb,
;;;1770                       (void      *)0,
;;;1771                       (OS_MSG_SIZE)0,
;;;1772                       (OS_FLAGS   )0,
;;;1773                       (OS_OPT     )0,
;;;1774                       (CPU_TS     )0,
;;;1775                       (OS_ERR    *)p_err);
;;;1776           return;
;;;1777       }
;;;1778   #endif
;;;1779   
;;;1780       OS_TaskSuspend(p_tcb, p_err);
;;;1781   }
00001a  bd1f              POP      {r0-r4,pc}
                  |L17.28|
00001c  4a0b              LDR      r2,|L17.76|
00001e  7812              LDRB     r2,[r2,#0]            ;1767  ; OSIntNestingCtr
000020  b152              CBZ      r2,|L17.56|
000022  2200              MOVS     r2,#0                 ;1768
000024  e9cd2102          STRD     r2,r1,[sp,#8]         ;1768
000028  4601              MOV      r1,r0                 ;1768
00002a  9200              STR      r2,[sp,#0]            ;1768
00002c  4613              MOV      r3,r2                 ;1768
00002e  9201              STR      r2,[sp,#4]            ;1768
000030  4807              LDR      r0,|L17.80|
000032  f7fffffe          BL       OS_IntQPost
000036  bd1f              POP      {r0-r4,pc}
                  |L17.56|
000038  b004              ADD      sp,sp,#0x10           ;1780
00003a  e8bd4010          POP      {r4,lr}               ;1780
00003e  f7ffbffe          B.W      OS_TaskSuspend
;;;1782   #endif
                          ENDP

000042  0000              DCW      0x0000
                  |L17.68|
                          DCD      OSIdleTaskTCB
                  |L17.72|
                          DCD      OSIntQTaskTCB
                  |L17.76|
                          DCD      OSIntNestingCtr
                  |L17.80|
                          DCD      0x53555354

                          AREA ||i.OSTaskTimeQuantaSet||, CODE, READONLY, ALIGN=2

                  OSTaskTimeQuantaSet PROC
;;;1805   #if OS_CFG_SCHED_ROUND_ROBIN_EN > 0u
;;;1806   void  OSTaskTimeQuantaSet (OS_TCB   *p_tcb,
000000  b570              PUSH     {r4-r6,lr}
;;;1807                              OS_TICK   time_quanta,
;;;1808                              OS_ERR   *p_err)
;;;1809   {
000002  4604              MOV      r4,r0
;;;1810       CPU_SR_ALLOC();
;;;1811   
;;;1812   
;;;1813   
;;;1814   #ifdef OS_SAFETY_CRITICAL
;;;1815       if (p_err == (OS_ERR *)0) {
;;;1816           OS_SAFETY_CRITICAL_EXCEPTION();
;;;1817           return;
;;;1818       }
;;;1819   #endif
;;;1820   
;;;1821   #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;1822       if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Can't call this function from an ISR                   */
000004  480e              LDR      r0,|L18.64|
000006  460e              MOV      r6,r1                 ;1809
000008  4615              MOV      r5,r2                 ;1809
00000a  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
00000c  b118              CBZ      r0,|L18.22|
;;;1823          *p_err = OS_ERR_SET_ISR;
00000e  f64650c6          MOV      r0,#0x6dc6
000012  8010              STRH     r0,[r2,#0]
;;;1824           return;
;;;1825       }
;;;1826   #endif
;;;1827   
;;;1828       CPU_CRITICAL_ENTER();
;;;1829       if (p_tcb == (OS_TCB *)0) {
;;;1830           p_tcb = OSTCBCurPtr;
;;;1831       }
;;;1832   
;;;1833       if (time_quanta == 0u) {
;;;1834           p_tcb->TimeQuanta    = OSSchedRoundRobinDfltTimeQuanta;
;;;1835       } else {
;;;1836           p_tcb->TimeQuanta    = time_quanta;
;;;1837       }
;;;1838       if (p_tcb->TimeQuanta > p_tcb->TimeQuantaCtr) {
;;;1839           p_tcb->TimeQuantaCtr = p_tcb->TimeQuanta;
;;;1840       }
;;;1841       CPU_CRITICAL_EXIT();
;;;1842      *p_err = OS_ERR_NONE;
;;;1843   }
000014  bd70              POP      {r4-r6,pc}
                  |L18.22|
000016  f7fffffe          BL       CPU_SR_Save
00001a  b90c              CBNZ     r4,|L18.32|
00001c  4909              LDR      r1,|L18.68|
00001e  680c              LDR      r4,[r1,#0]            ;1830  ; OSTCBCurPtr
                  |L18.32|
000020  b156              CBZ      r6,|L18.56|
000022  4631              MOV      r1,r6                 ;1838
000024  6566              STR      r6,[r4,#0x54]         ;1838
                  |L18.38|
000026  6da2              LDR      r2,[r4,#0x58]         ;1838
000028  4291              CMP      r1,r2                 ;1838
00002a  d900              BLS      |L18.46|
00002c  65a1              STR      r1,[r4,#0x58]         ;1839
                  |L18.46|
00002e  f7fffffe          BL       CPU_SR_Restore
000032  2000              MOVS     r0,#0                 ;1842
000034  8028              STRH     r0,[r5,#0]            ;1842
000036  bd70              POP      {r4-r6,pc}
                  |L18.56|
000038  4903              LDR      r1,|L18.72|
00003a  6809              LDR      r1,[r1,#0]            ;1834  ; OSSchedRoundRobinDfltTimeQuanta
00003c  6561              STR      r1,[r4,#0x54]         ;1834
00003e  e7f2              B        |L18.38|
;;;1844   #endif
                          ENDP

                  |L18.64|
                          DCD      OSIntNestingCtr
                  |L18.68|
                          DCD      OSTCBCurPtr
                  |L18.72|
                          DCD      OSSchedRoundRobinDfltTimeQuanta

                          AREA ||i.OS_TaskDbgListAdd||, CODE, READONLY, ALIGN=2

                  OS_TaskDbgListAdd PROC
;;;1861   #if OS_CFG_DBG_EN > 0u
;;;1862   void  OS_TaskDbgListAdd (OS_TCB  *p_tcb)
000000  4b07              LDR      r3,|L19.32|
;;;1863   {
;;;1864       p_tcb->DbgPrevPtr                = (OS_TCB *)0;
000002  2200              MOVS     r2,#0
;;;1865       if (OSTaskDbgListPtr == (OS_TCB *)0) {
000004  f8c020b8          STR      r2,[r0,#0xb8]
000008  6819              LDR      r1,[r3,#0]            ;1863  ; OSTaskDbgListPtr
00000a  b129              CBZ      r1,|L19.24|
;;;1866           p_tcb->DbgNextPtr            = (OS_TCB *)0;
;;;1867       } else {
;;;1868           p_tcb->DbgNextPtr            =  OSTaskDbgListPtr;
;;;1869           OSTaskDbgListPtr->DbgPrevPtr =  p_tcb;
00000c  f8c010bc          STR      r1,[r0,#0xbc]
000010  f8c100b8          STR      r0,[r1,#0xb8]
                  |L19.20|
;;;1870       }
;;;1871       OSTaskDbgListPtr                 =  p_tcb;
;;;1872   }
000014  6018              STR      r0,[r3,#0]  ; OSTaskDbgListPtr
000016  4770              BX       lr
                  |L19.24|
000018  f8c020bc          STR      r2,[r0,#0xbc]         ;1866
00001c  e7fa              B        |L19.20|
;;;1873   
                          ENDP

00001e  0000              DCW      0x0000
                  |L19.32|
                          DCD      OSTaskDbgListPtr

                          AREA ||i.OS_TaskDbgListRemove||, CODE, READONLY, ALIGN=2

                  OS_TaskDbgListRemove PROC
;;;1875   
;;;1876   void  OS_TaskDbgListRemove (OS_TCB  *p_tcb)
000000  e9d0212e          LDRD     r2,r1,[r0,#0xb8]
;;;1877   {
000004  2300              MOVS     r3,#0
000006  b142              CBZ      r2,|L20.26|
;;;1878       OS_TCB  *p_tcb_next;
;;;1879       OS_TCB  *p_tcb_prev;
;;;1880   
;;;1881   
;;;1882       p_tcb_prev = p_tcb->DbgPrevPtr;
;;;1883       p_tcb_next = p_tcb->DbgNextPtr;
;;;1884   
;;;1885       if (p_tcb_prev == (OS_TCB *)0) {
;;;1886           OSTaskDbgListPtr = p_tcb_next;
;;;1887           if (p_tcb_next != (OS_TCB *)0) {
;;;1888               p_tcb_next->DbgPrevPtr = (OS_TCB *)0;
;;;1889           }
;;;1890           p_tcb->DbgNextPtr = (OS_TCB *)0;
;;;1891   
;;;1892       } else if (p_tcb_next == (OS_TCB *)0) {
000008  b179              CBZ      r1,|L20.42|
;;;1893           p_tcb_prev->DbgNextPtr = (OS_TCB *)0;
;;;1894           p_tcb->DbgPrevPtr      = (OS_TCB *)0;
;;;1895   
;;;1896       } else {
;;;1897           p_tcb_prev->DbgNextPtr =  p_tcb_next;
;;;1898           p_tcb_next->DbgPrevPtr =  p_tcb_prev;
00000a  f8c210bc          STR      r1,[r2,#0xbc]
00000e  30b8              ADDS     r0,r0,#0xb8
;;;1899           p_tcb->DbgNextPtr      = (OS_TCB *)0;
000010  f8c120b8          STR      r2,[r1,#0xb8]
;;;1900           p_tcb->DbgPrevPtr      = (OS_TCB *)0;
000014  6043              STR      r3,[r0,#4]
000016  6003              STR      r3,[r0,#0]
;;;1901       }
;;;1902   }
000018  4770              BX       lr
                  |L20.26|
00001a  4a06              LDR      r2,|L20.52|
00001c  6011              STR      r1,[r2,#0]            ;1887  ; OSTaskDbgListPtr
00001e  b109              CBZ      r1,|L20.36|
000020  f8c130b8          STR      r3,[r1,#0xb8]         ;1888
                  |L20.36|
000024  f8c030bc          STR      r3,[r0,#0xbc]         ;1890
000028  4770              BX       lr
                  |L20.42|
00002a  f8c230bc          STR      r3,[r2,#0xbc]         ;1894
00002e  f8c030b8          STR      r3,[r0,#0xb8]         ;1894
000032  4770              BX       lr
;;;1903   #endif
                          ENDP

                  |L20.52|
                          DCD      OSTaskDbgListPtr

                          AREA ||i.OS_TaskInit||, CODE, READONLY, ALIGN=2

                  OS_TaskInit PROC
;;;1922   
;;;1923   void  OS_TaskInit (OS_ERR  *p_err)
000000  4a04              LDR      r2,|L21.20|
;;;1924   {
;;;1925   #ifdef OS_SAFETY_CRITICAL
;;;1926       if (p_err == (OS_ERR *)0) {
;;;1927           OS_SAFETY_CRITICAL_EXCEPTION();
;;;1928           return;
;;;1929       }
;;;1930   #endif
;;;1931   
;;;1932   #if OS_CFG_DBG_EN > 0u
;;;1933       OSTaskDbgListPtr = (OS_TCB      *)0;
000002  2100              MOVS     r1,#0
;;;1934   #endif
;;;1935   
;;;1936       OSTaskQty        = (OS_OBJ_QTY   )0;                    /* Clear the number of tasks                              */
000004  6011              STR      r1,[r2,#0]  ; OSTaskDbgListPtr
000006  4a04              LDR      r2,|L21.24|
000008  8011              STRH     r1,[r2,#0]
;;;1937       OSTaskCtxSwCtr   = (OS_CTX_SW_CTR)0;                    /* Clear the context switch counter                       */
00000a  4a04              LDR      r2,|L21.28|
;;;1938   
;;;1939      *p_err            = OS_ERR_NONE;
00000c  6011              STR      r1,[r2,#0]  ; OSTaskCtxSwCtr
00000e  8001              STRH     r1,[r0,#0]
;;;1940   }
000010  4770              BX       lr
;;;1941   
                          ENDP

000012  0000              DCW      0x0000
                  |L21.20|
                          DCD      OSTaskDbgListPtr
                  |L21.24|
                          DCD      OSTaskQty
                  |L21.28|
                          DCD      OSTaskCtxSwCtr

                          AREA ||i.OS_TaskInitTCB||, CODE, READONLY, ALIGN=2

                  OS_TaskInitTCB PROC
;;;1956   
;;;1957   void  OS_TaskInitTCB (OS_TCB  *p_tcb)
000000  b570              PUSH     {r4-r6,lr}
;;;1958   {
;;;1959   #if OS_CFG_TASK_REG_TBL_SIZE > 0u
;;;1960       OS_REG_ID   reg_id;
;;;1961   #endif
;;;1962   #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
;;;1963       OS_TLS_ID   id;
;;;1964   #endif
;;;1965   #if OS_CFG_TASK_PROFILE_EN > 0u
;;;1966       CPU_TS      ts;
;;;1967   #endif
;;;1968   
;;;1969   
;;;1970       p_tcb->StkPtr             = (CPU_STK       *)0;
000002  2500              MOVS     r5,#0
;;;1971       p_tcb->StkLimitPtr        = (CPU_STK       *)0;
000004  6005              STR      r5,[r0,#0]
;;;1972   
;;;1973       p_tcb->ExtPtr             = (void          *)0;
000006  6085              STR      r5,[r0,#8]
;;;1974   
;;;1975       p_tcb->NextPtr            = (OS_TCB        *)0;
000008  6045              STR      r5,[r0,#4]
;;;1976       p_tcb->PrevPtr            = (OS_TCB        *)0;
00000a  60c5              STR      r5,[r0,#0xc]
;;;1977   
;;;1978       p_tcb->TickNextPtr        = (OS_TCB        *)0;
00000c  6105              STR      r5,[r0,#0x10]
;;;1979       p_tcb->TickPrevPtr        = (OS_TCB        *)0;
00000e  6145              STR      r5,[r0,#0x14]
000010  4604              MOV      r4,r0                 ;1958
;;;1980       p_tcb->TickSpokePtr       = (OS_TICK_SPOKE *)0;
;;;1981   
;;;1982       p_tcb->NamePtr            = (CPU_CHAR      *)((void *)"?Task");
000012  6185              STR      r5,[r0,#0x18]
000014  a023              ADR      r0,|L22.164|
000016  e9c45007          STRD     r5,r0,[r4,#0x1c]
;;;1983   
;;;1984       p_tcb->StkBasePtr         = (CPU_STK       *)0;
;;;1985   
;;;1986       p_tcb->TaskEntryAddr      = (OS_TASK_PTR    )0;
00001a  6265              STR      r5,[r4,#0x24]
;;;1987       p_tcb->TaskEntryArg       = (void          *)0;
00001c  62a5              STR      r5,[r4,#0x28]
;;;1988   
;;;1989   #if (OS_CFG_PEND_MULTI_EN > 0u)
;;;1990       p_tcb->PendDataTblPtr     = (OS_PEND_DATA  *)0;
;;;1991       p_tcb->PendDataTblEntries = (OS_OBJ_QTY     )0u;
;;;1992   #endif
;;;1993   
;;;1994       p_tcb->TS                 = (CPU_TS         )0u;
00001e  62e5              STR      r5,[r4,#0x2c]
;;;1995   
;;;1996   #if (OS_MSG_EN > 0u)
;;;1997       p_tcb->MsgPtr             = (void          *)0;
000020  6425              STR      r5,[r4,#0x40]
;;;1998       p_tcb->MsgSize            = (OS_MSG_SIZE    )0u;
000022  65e5              STR      r5,[r4,#0x5c]
000024  f8a45060          STRH     r5,[r4,#0x60]
;;;1999   #endif
;;;2000   
;;;2001   #if OS_CFG_TASK_Q_EN > 0u
;;;2002       OS_MsgQInit(&p_tcb->MsgQ,
000028  4629              MOV      r1,r5
00002a  f1040064          ADD      r0,r4,#0x64
00002e  f7fffffe          BL       OS_MsgQInit
;;;2003                   (OS_MSG_QTY)0u);
;;;2004   #if OS_CFG_TASK_PROFILE_EN > 0u
;;;2005       p_tcb->MsgQPendTime       = (CPU_TS         )0u;
000032  f8445f74          STR      r5,[r4,#0x74]!
;;;2006       p_tcb->MsgQPendTimeMax    = (CPU_TS         )0u;
;;;2007   #endif
;;;2008   #endif
;;;2009   
;;;2010   #if OS_CFG_FLAG_EN > 0u
;;;2011       p_tcb->FlagsPend          = (OS_FLAGS       )0u;
000036  6065              STR      r5,[r4,#4]
;;;2012       p_tcb->FlagsOpt           = (OS_OPT         )0u;
000038  60e5              STR      r5,[r4,#0xc]
00003a  82a5              STRH     r5,[r4,#0x14]
;;;2013       p_tcb->FlagsRdy           = (OS_FLAGS       )0u;
00003c  6125              STR      r5,[r4,#0x10]
00003e  3c74              SUBS     r4,r4,#0x74
;;;2014   #endif
;;;2015   
;;;2016   #if OS_CFG_TASK_REG_TBL_SIZE > 0u
;;;2017       for (reg_id = 0u; reg_id < OS_CFG_TASK_REG_TBL_SIZE; reg_id++) {
000040  f05f0000          MOVS.W   r0,#0
                  |L22.68|
;;;2018           p_tcb->RegTbl[reg_id] = (OS_REG)0u;
000044  eb040180          ADD      r1,r4,r0,LSL #2
000048  1c40              ADDS     r0,r0,#1              ;2017
00004a  67cd              STR      r5,[r1,#0x7c]         ;2017
00004c  f01000ff          ANDS     r0,r0,#0xff           ;2017
000050  d0f8              BEQ      |L22.68|
000052  3434              ADDS     r4,r4,#0x34           ;2017
;;;2019       }
;;;2020   #endif
;;;2021   
;;;2022   #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
;;;2023       for (id = 0u; id < OS_CFG_TLS_TBL_SIZE; id++) {
;;;2024           p_tcb->TLS_Tbl[id]    = (OS_TLS)0;
;;;2025       }
;;;2026   #endif
;;;2027   
;;;2028       p_tcb->SemCtr             = (OS_SEM_CTR     )0u;
;;;2029   #if OS_CFG_TASK_PROFILE_EN > 0u
;;;2030       p_tcb->SemPendTime        = (CPU_TS         )0u;
;;;2031       p_tcb->SemPendTimeMax     = (CPU_TS         )0u;
;;;2032   #endif
;;;2033   
;;;2034       p_tcb->StkSize            = (CPU_STK_SIZE   )0u;
;;;2035   
;;;2036   
;;;2037   #if OS_CFG_TASK_SUSPEND_EN > 0u
;;;2038       p_tcb->SuspendCtr         = (OS_NESTING_CTR )0u;
;;;2039   #endif
;;;2040   
;;;2041   #if OS_CFG_STAT_TASK_STK_CHK_EN > 0u
;;;2042       p_tcb->StkFree            = (CPU_STK_SIZE   )0u;
;;;2043       p_tcb->StkUsed            = (CPU_STK_SIZE   )0u;
;;;2044   #endif
;;;2045   
;;;2046       p_tcb->Opt                = (OS_OPT         )0u;
;;;2047   
;;;2048       p_tcb->TickCtrPrev        = (OS_TICK        )OS_TICK_TH_INIT;
000054  f04f4000          MOV      r0,#0x80000000
000058  6125              STR      r5,[r4,#0x10]         ;2030
00005a  6725              STR      r5,[r4,#0x70]         ;2031
00005c  6765              STR      r5,[r4,#0x74]         ;2034
00005e  6065              STR      r5,[r4,#4]            ;2038
000060  f8845056          STRB     r5,[r4,#0x56]         ;2038
000064  67e5              STR      r5,[r4,#0x7c]         ;2043
000066  67a5              STR      r5,[r4,#0x78]         ;2046
000068  8125              STRH     r5,[r4,#8]            ;2046
00006a  e9c40505          STRD     r0,r5,[r4,#0x14]
;;;2049       p_tcb->TickCtrMatch       = (OS_TICK        )0u;
;;;2050       p_tcb->TickRemain         = (OS_TICK        )0u;
;;;2051   
;;;2052       p_tcb->TimeQuanta         = (OS_TICK        )0u;
00006e  61e5              STR      r5,[r4,#0x1c]
;;;2053       p_tcb->TimeQuantaCtr      = (OS_TICK        )0u;
000070  6225              STR      r5,[r4,#0x20]
;;;2054   
;;;2055   #if OS_CFG_TASK_PROFILE_EN > 0u
;;;2056       p_tcb->CPUUsage           = (OS_CPU_USAGE   )0u;
000072  6265              STR      r5,[r4,#0x24]
000074  f8a45058          STRH     r5,[r4,#0x58]
;;;2057       p_tcb->CPUUsageMax        = (OS_CPU_USAGE   )0u;
000078  f8a4505a          STRH     r5,[r4,#0x5a]
;;;2058       p_tcb->CtxSwCtr           = (OS_CTX_SW_CTR  )0u;
;;;2059       p_tcb->CyclesDelta        = (CPU_TS         )0u;
00007c  65e5              STR      r5,[r4,#0x5c]
;;;2060       ts                        = OS_TS_GET();                /* Read the current timestamp and save                    */
00007e  6625              STR      r5,[r4,#0x60]
000080  f7fffffe          BL       CPU_TS_TmrRd
000084  e9c40519          STRD     r0,r5,[r4,#0x64]
;;;2061       p_tcb->CyclesStart        = ts;
;;;2062       p_tcb->CyclesTotal        = (OS_CYCLES      )0u;
;;;2063   #endif
;;;2064   #ifdef CPU_CFG_INT_DIS_MEAS_EN
;;;2065       p_tcb->IntDisTimeMax      = (CPU_TS         )0u;
;;;2066   #endif
;;;2067   #if OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u
;;;2068       p_tcb->SchedLockTimeMax   = (CPU_TS         )0u;
;;;2069   #endif
;;;2070   
;;;2071       p_tcb->PendOn             = (OS_STATE       )OS_TASK_PEND_ON_NOTHING;
000088  f8c45080          STR      r5,[r4,#0x80]
00008c  7025              STRB     r5,[r4,#0]
;;;2072       p_tcb->PendStatus         = (OS_STATUS      )OS_STATUS_PEND_OK;
00008e  7065              STRB     r5,[r4,#1]
;;;2073       p_tcb->TaskState          = (OS_STATE       )OS_TASK_STATE_RDY;
000090  70a5              STRB     r5,[r4,#2]
;;;2074   
;;;2075       p_tcb->Prio               = (OS_PRIO        )OS_PRIO_INIT;
000092  2040              MOVS     r0,#0x40
000094  70e0              STRB     r0,[r4,#3]
;;;2076   
;;;2077   #if OS_CFG_DBG_EN > 0u
;;;2078       p_tcb->DbgPrevPtr         = (OS_TCB        *)0;
000096  f8c45084          STR      r5,[r4,#0x84]
00009a  3488              ADDS     r4,r4,#0x88
;;;2079       p_tcb->DbgNextPtr         = (OS_TCB        *)0;
;;;2080       p_tcb->DbgNamePtr         = (CPU_CHAR      *)((void *)" ");
00009c  a003              ADR      r0,|L22.172|
00009e  e9c45000          STRD     r5,r0,[r4,#0]
;;;2081   #endif
;;;2082   }
0000a2  bd70              POP      {r4-r6,pc}
;;;2083   
                          ENDP

                  |L22.164|
0000a4  3f546173          DCB      "?Task",0
0000a8  6b00    
0000aa  00                DCB      0
0000ab  00                DCB      0
                  |L22.172|
0000ac  2000              DCB      " ",0
0000ae  00                DCB      0
0000af  00                DCB      0

                          AREA ||i.OS_TaskQPost||, CODE, READONLY, ALIGN=2

                  OS_TaskQPost PROC
;;;2126   #if OS_CFG_TASK_Q_EN > 0u
;;;2127   void  OS_TaskQPost (OS_TCB       *p_tcb,
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;2128                       void         *p_void,
;;;2129                       OS_MSG_SIZE   msg_size,
;;;2130                       OS_OPT        opt,
;;;2131                       CPU_TS        ts,
;;;2132                       OS_ERR       *p_err)
;;;2133   {
000004  4692              MOV      r10,r2
000006  e9dd760c          LDRD     r7,r6,[sp,#0x30]
00000a  4699              MOV      r9,r3
00000c  468b              MOV      r11,r1
00000e  4605              MOV      r5,r0
;;;2134       CPU_SR_ALLOC();
;;;2135   
;;;2136   
;;;2137   
;;;2138       OS_CRITICAL_ENTER();
000010  f7fffffe          BL       CPU_SR_Save
000014  4c32              LDR      r4,|L23.224|
000016  7821              LDRB     r1,[r4,#0]  ; OSSchedLockNestingCtr
000018  1c49              ADDS     r1,r1,#1
00001a  7021              STRB     r1,[r4,#0]
00001c  f7fffffe          BL       CPU_SR_Restore
;;;2139       if (p_tcb == (OS_TCB *)0) {                             /* Post msg to 'self'?                                    */
000020  b90d              CBNZ     r5,|L23.38|
;;;2140           p_tcb = OSTCBCurPtr;
000022  4830              LDR      r0,|L23.228|
000024  6805              LDR      r5,[r0,#0]  ; OSTCBCurPtr
                  |L23.38|
;;;2141       }
;;;2142      *p_err  = OS_ERR_NONE;                                   /* Assume we won't have any errors                        */
000026  2000              MOVS     r0,#0
000028  8030              STRH     r0,[r6,#0]
;;;2143       switch (p_tcb->TaskState) {
00002a  f8950036          LDRB     r0,[r5,#0x36]
;;;2144           case OS_TASK_STATE_RDY:
;;;2145           case OS_TASK_STATE_DLY:
;;;2146           case OS_TASK_STATE_SUSPENDED:
;;;2147           case OS_TASK_STATE_DLY_SUSPENDED:
;;;2148                OS_MsgQPut(&p_tcb->MsgQ,                       /* Deposit the message in the queue                       */
;;;2149                           p_void,
;;;2150                           msg_size,
;;;2151                           opt,
;;;2152                           ts,
;;;2153                           p_err);
;;;2154                OS_CRITICAL_EXIT();
00002e  f8df80b8          LDR      r8,|L23.232|
000032  2808              CMP      r0,#8                 ;2143
000034  d23c              BCS      |L23.176|
000036  e8dff000          TBB      [pc,r0]               ;2143
00003a  0404              DCB      0x04,0x04
00003c  1e1e0404          DCB      0x1e,0x1e,0x04,0x04
000040  1e1e              DCB      0x1e,0x1e
                  |L23.66|
000042  e9cd7600          STRD     r7,r6,[sp,#0]         ;2148
000046  464b              MOV      r3,r9                 ;2148
000048  4652              MOV      r2,r10                ;2148
00004a  4659              MOV      r1,r11                ;2148
00004c  f1050064          ADD      r0,r5,#0x64           ;2148
000050  f7fffffe          BL       OS_MsgQPut
000054  f7fffffe          BL       CPU_SR_Save
000058  7821              LDRB     r1,[r4,#0]  ; OSSchedLockNestingCtr
00005a  1e49              SUBS     r1,r1,#1
00005c  f01101ff          ANDS     r1,r1,#0xff
000060  7021              STRB     r1,[r4,#0]
000062  d121              BNE      |L23.168|
000064  f8b81000          LDRH     r1,[r8,#0]  ; OSIntQNbrEntries
000068  b1f1              CBZ      r1,|L23.168|
;;;2155                break;
;;;2156   
;;;2157           case OS_TASK_STATE_PEND:
;;;2158           case OS_TASK_STATE_PEND_TIMEOUT:
;;;2159           case OS_TASK_STATE_PEND_SUSPENDED:
;;;2160           case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
;;;2161                if (p_tcb->PendOn == OS_TASK_PEND_ON_TASK_Q) { /* Is task waiting for a message to be sent to it?        */
;;;2162                    OS_Post((OS_PEND_OBJ *)0,
;;;2163                            p_tcb,
;;;2164                            p_void,
;;;2165                            msg_size,
;;;2166                            ts);
;;;2167                    OS_CRITICAL_EXIT_NO_SCHED();
;;;2168                    if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0u) {
;;;2169                        OSSched();                             /* Run the scheduler                                      */
;;;2170                    }
;;;2171                } else {
;;;2172                    OS_MsgQPut(&p_tcb->MsgQ,                   /* No,  Task is pending on something else ...             */
;;;2173                               p_void,                         /*      ... Deposit the message in the task's queue       */
;;;2174                               msg_size,
;;;2175                               opt,
;;;2176                               ts,
;;;2177                               p_err);
;;;2178                    OS_CRITICAL_EXIT();
00006a  f7fffffe          BL       CPU_SR_Restore
00006e  e8bd5ffc          POP      {r2-r12,lr}
000072  f7ffbffe          B.W      OS_Sched0
000076  f8950034          LDRB     r0,[r5,#0x34]         ;2161
00007a  2802              CMP      r0,#2                 ;2161
00007c  d1e1              BNE      |L23.66|
00007e  4653              MOV      r3,r10                ;2162
000080  465a              MOV      r2,r11                ;2162
000082  4629              MOV      r1,r5                 ;2162
000084  2000              MOVS     r0,#0                 ;2162
000086  9700              STR      r7,[sp,#0]            ;2162
000088  f7fffffe          BL       OS_Post
00008c  f7fffffe          BL       CPU_SR_Save
000090  7821              LDRB     r1,[r4,#0]            ;2167  ; OSSchedLockNestingCtr
000092  1e49              SUBS     r1,r1,#1              ;2167
000094  7021              STRB     r1,[r4,#0]            ;2167
000096  f7fffffe          BL       CPU_SR_Restore
00009a  ea5f4009          LSLS     r0,r9,#16             ;2168
00009e  d41c              BMI      |L23.218|
0000a0  e8bd5ffc          POP      {r2-r12,lr}           ;2169
0000a4  f7ffbffe          B.W      OSSched
                  |L23.168|
0000a8  e8bd5ffc          POP      {r2-r12,lr}
0000ac  f7ffbffe          B.W      CPU_SR_Restore
                  |L23.176|
;;;2179                }
;;;2180                break;
;;;2181   
;;;2182           default:
;;;2183                OS_CRITICAL_EXIT();
0000b0  f7fffffe          BL       CPU_SR_Save
0000b4  7821              LDRB     r1,[r4,#0]  ; OSSchedLockNestingCtr
0000b6  1e49              SUBS     r1,r1,#1
0000b8  f01101ff          ANDS     r1,r1,#0xff
0000bc  7021              STRB     r1,[r4,#0]
0000be  d107              BNE      |L23.208|
0000c0  f8b81000          LDRH     r1,[r8,#0]  ; OSIntQNbrEntries
0000c4  b121              CBZ      r1,|L23.208|
0000c6  f7fffffe          BL       CPU_SR_Restore
0000ca  f7fffffe          BL       OS_Sched0
0000ce  e001              B        |L23.212|
                  |L23.208|
0000d0  f7fffffe          BL       CPU_SR_Restore
                  |L23.212|
;;;2184               *p_err = OS_ERR_STATE_INVALID;
0000d4  f646602d          MOV      r0,#0x6e2d
0000d8  8030              STRH     r0,[r6,#0]
                  |L23.218|
;;;2185                break;
;;;2186       }
;;;2187   }
0000da  e8bd9ffc          POP      {r2-r12,pc}
;;;2188   #endif
                          ENDP

0000de  0000              DCW      0x0000
                  |L23.224|
                          DCD      OSSchedLockNestingCtr
                  |L23.228|
                          DCD      OSTCBCurPtr
                  |L23.232|
                          DCD      OSIntQNbrEntries

                          AREA ||i.OS_TaskResume||, CODE, READONLY, ALIGN=2

                  OS_TaskResume PROC
;;;2214   #if OS_CFG_TASK_SUSPEND_EN > 0u
;;;2215   void  OS_TaskResume (OS_TCB  *p_tcb,
000000  b570              PUSH     {r4-r6,lr}
;;;2216                        OS_ERR  *p_err)
;;;2217   {
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
;;;2218       CPU_SR_ALLOC();
;;;2219   
;;;2220   
;;;2221       CPU_CRITICAL_ENTER();
000006  f7fffffe          BL       CPU_SR_Save
;;;2222      *p_err  = OS_ERR_NONE;
00000a  2600              MOVS     r6,#0
00000c  802e              STRH     r6,[r5,#0]
;;;2223       switch (p_tcb->TaskState) {
00000e  f8941036          LDRB     r1,[r4,#0x36]
000012  2908              CMP      r1,#8
000014  d24a              BCS      |L24.172|
000016  e8dff001          TBB      [pc,r1]
00001a  0404              DCB      0x04,0x04
00001c  04040a23          DCB      0x04,0x04,0x0a,0x23
000020  333d              DCB      0x33,0x3d
;;;2224           case OS_TASK_STATE_RDY:
;;;2225           case OS_TASK_STATE_DLY:
;;;2226           case OS_TASK_STATE_PEND:
;;;2227           case OS_TASK_STATE_PEND_TIMEOUT:
;;;2228                CPU_CRITICAL_EXIT();
000022  f7fffffe          BL       CPU_SR_Restore
;;;2229               *p_err = OS_ERR_TASK_NOT_SUSPENDED;
000026  f2471053          MOV      r0,#0x7153
00002a  8028              STRH     r0,[r5,#0]
;;;2230                break;
00002c  e024              B        |L24.120|
;;;2231   
;;;2232           case OS_TASK_STATE_SUSPENDED:
;;;2233                OS_CRITICAL_ENTER_CPU_CRITICAL_EXIT();
00002e  4d22              LDR      r5,|L24.184|
000030  7829              LDRB     r1,[r5,#0]  ; OSSchedLockNestingCtr
000032  1c49              ADDS     r1,r1,#1
000034  7029              STRB     r1,[r5,#0]
000036  f7fffffe          BL       CPU_SR_Restore
;;;2234                p_tcb->SuspendCtr--;
00003a  f894008a          LDRB     r0,[r4,#0x8a]
00003e  1e40              SUBS     r0,r0,#1
000040  f01000ff          ANDS     r0,r0,#0xff
000044  f884008a          STRB     r0,[r4,#0x8a]
;;;2235                if (p_tcb->SuspendCtr == (OS_NESTING_CTR)0) {
000048  d104              BNE      |L24.84|
;;;2236                    p_tcb->TaskState = OS_TASK_STATE_RDY;
00004a  f8846036          STRB     r6,[r4,#0x36]
;;;2237                    OS_TaskRdy(p_tcb);
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       OS_TaskRdy
                  |L24.84|
;;;2238                }
;;;2239                OS_CRITICAL_EXIT_NO_SCHED();
000054  f7fffffe          BL       CPU_SR_Save
000058  7829              LDRB     r1,[r5,#0]  ; OSSchedLockNestingCtr
00005a  1e49              SUBS     r1,r1,#1
00005c  7029              STRB     r1,[r5,#0]
;;;2240                break;
00005e  e009              B        |L24.116|
;;;2241   
;;;2242           case OS_TASK_STATE_DLY_SUSPENDED:
;;;2243                p_tcb->SuspendCtr--;
000060  f894108a          LDRB     r1,[r4,#0x8a]
000064  1e49              SUBS     r1,r1,#1
000066  f01101ff          ANDS     r1,r1,#0xff
00006a  f884108a          STRB     r1,[r4,#0x8a]
;;;2244                if (p_tcb->SuspendCtr == (OS_NESTING_CTR)0) {
00006e  d101              BNE      |L24.116|
;;;2245                    p_tcb->TaskState = OS_TASK_STATE_DLY;
000070  2101              MOVS     r1,#1
000072  e018              B        |L24.166|
                  |L24.116|
;;;2246                }
;;;2247                CPU_CRITICAL_EXIT();
000074  f7fffffe          BL       CPU_SR_Restore
                  |L24.120|
;;;2248                break;
;;;2249   
;;;2250           case OS_TASK_STATE_PEND_SUSPENDED:
;;;2251                p_tcb->SuspendCtr--;
;;;2252                if (p_tcb->SuspendCtr == (OS_NESTING_CTR)0) {
;;;2253                    p_tcb->TaskState = OS_TASK_STATE_PEND;
;;;2254                }
;;;2255                CPU_CRITICAL_EXIT();
;;;2256                break;
;;;2257   
;;;2258           case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
;;;2259                p_tcb->SuspendCtr--;
;;;2260                if (p_tcb->SuspendCtr == (OS_NESTING_CTR)0) {
;;;2261                    p_tcb->TaskState = OS_TASK_STATE_PEND_TIMEOUT;
;;;2262                }
;;;2263                CPU_CRITICAL_EXIT();
;;;2264                break;
;;;2265   
;;;2266           default:
;;;2267                CPU_CRITICAL_EXIT();
;;;2268               *p_err = OS_ERR_STATE_INVALID;
;;;2269                return;
;;;2270       }
;;;2271   
;;;2272       OSSched();
000078  e8bd4070          POP      {r4-r6,lr}
00007c  f7ffbffe          B.W      OSSched
000080  f894108a          LDRB     r1,[r4,#0x8a]         ;2251
000084  1e49              SUBS     r1,r1,#1              ;2251
000086  f01101ff          ANDS     r1,r1,#0xff           ;2251
00008a  f884108a          STRB     r1,[r4,#0x8a]         ;2251
00008e  d1f1              BNE      |L24.116|
000090  2102              MOVS     r1,#2                 ;2253
000092  e008              B        |L24.166|
000094  f894108a          LDRB     r1,[r4,#0x8a]         ;2259
000098  1e49              SUBS     r1,r1,#1              ;2259
00009a  f01101ff          ANDS     r1,r1,#0xff           ;2259
00009e  f884108a          STRB     r1,[r4,#0x8a]         ;2259
0000a2  d1e7              BNE      |L24.116|
0000a4  2103              MOVS     r1,#3                 ;2261
                  |L24.166|
0000a6  f8841036          STRB     r1,[r4,#0x36]         ;2261
0000aa  e7e3              B        |L24.116|
                  |L24.172|
0000ac  f7fffffe          BL       CPU_SR_Restore
0000b0  f646602d          MOV      r0,#0x6e2d            ;2268
0000b4  8028              STRH     r0,[r5,#0]            ;2268
;;;2273   }
0000b6  bd70              POP      {r4-r6,pc}
;;;2274   #endif
                          ENDP

                  |L24.184|
                          DCD      OSSchedLockNestingCtr

                          AREA ||i.OS_TaskReturn||, CODE, READONLY, ALIGN=2

                  OS_TaskReturn PROC
;;;2291   
;;;2292   void  OS_TaskReturn (void)
000000  4804              LDR      r0,|L25.20|
;;;2293   {
000002  b508              PUSH     {r3,lr}
;;;2294       OS_ERR  err;
;;;2295   
;;;2296   
;;;2297   
;;;2298       OSTaskReturnHook(OSTCBCurPtr);                          /* Call hook to let user decide on what to do             */
000004  6800              LDR      r0,[r0,#0]  ; OSTCBCurPtr
000006  f7fffffe          BL       OSTaskReturnHook
;;;2299   #if OS_CFG_TASK_DEL_EN > 0u
;;;2300       OSTaskDel((OS_TCB *)0,                                  /* Delete task if it accidentally returns!                */
00000a  4669              MOV      r1,sp
00000c  2000              MOVS     r0,#0
00000e  f7fffffe          BL       OSTaskDel
;;;2301                 (OS_ERR *)&err);
;;;2302   #else
;;;2303       for (;;) {
;;;2304           OSTimeDly((OS_TICK )OSCfg_TickRate_Hz,
;;;2305                     (OS_OPT  )OS_OPT_TIME_DLY,
;;;2306                     (OS_ERR *)&err);
;;;2307       }
;;;2308   #endif
;;;2309   }
000012  bd08              POP      {r3,pc}
;;;2310   
                          ENDP

                  |L25.20|
                          DCD      OSTCBCurPtr

                          AREA ||i.OS_TaskSemPost||, CODE, READONLY, ALIGN=2

                  OS_TaskSemPost PROC
;;;2341   
;;;2342   OS_SEM_CTR  OS_TaskSemPost (OS_TCB  *p_tcb,
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;2343                               OS_OPT   opt,
;;;2344                               CPU_TS   ts,
;;;2345                               OS_ERR  *p_err)
;;;2346   {
000004  461e              MOV      r6,r3
000006  4690              MOV      r8,r2
000008  468a              MOV      r10,r1
00000a  4605              MOV      r5,r0
;;;2347       OS_SEM_CTR  ctr;
;;;2348       CPU_SR_ALLOC();
;;;2349   
;;;2350   
;;;2351   
;;;2352       OS_CRITICAL_ENTER();
00000c  f7fffffe          BL       CPU_SR_Save
000010  4c4e              LDR      r4,|L26.332|
000012  4601              MOV      r1,r0
000014  7820              LDRB     r0,[r4,#0]  ; OSSchedLockNestingCtr
000016  1c40              ADDS     r0,r0,#1
000018  7020              STRB     r0,[r4,#0]
00001a  4608              MOV      r0,r1
00001c  f7fffffe          BL       CPU_SR_Restore
;;;2353       if (p_tcb == (OS_TCB *)0) {                             /* Post signal to 'self'?                                 */
000020  b90d              CBNZ     r5,|L26.38|
;;;2354           p_tcb = OSTCBCurPtr;
000022  484b              LDR      r0,|L26.336|
000024  6805              LDR      r5,[r0,#0]  ; OSTCBCurPtr
                  |L26.38|
;;;2355       }
;;;2356       p_tcb->TS = ts;
;;;2357      *p_err     = OS_ERR_NONE;                                /* Assume we won't have any errors                        */
000026  2000              MOVS     r0,#0
;;;2358       switch (p_tcb->TaskState) {
;;;2359           case OS_TASK_STATE_RDY:
;;;2360           case OS_TASK_STATE_DLY:
;;;2361           case OS_TASK_STATE_SUSPENDED:
;;;2362           case OS_TASK_STATE_DLY_SUSPENDED:
;;;2363                switch (sizeof(OS_SEM_CTR)) {
;;;2364                    case 1u:
;;;2365                         if (p_tcb->SemCtr == DEF_INT_08U_MAX_VAL) {
;;;2366                             OS_CRITICAL_EXIT();
;;;2367                            *p_err = OS_ERR_SEM_OVF;
;;;2368                             return ((OS_SEM_CTR)0);
;;;2369                         }
;;;2370                         break;
;;;2371   
;;;2372                    case 2u:
;;;2373                         if (p_tcb->SemCtr == DEF_INT_16U_MAX_VAL) {
;;;2374                             OS_CRITICAL_EXIT();
;;;2375                            *p_err = OS_ERR_SEM_OVF;
;;;2376                             return ((OS_SEM_CTR)0);
;;;2377                         }
;;;2378                         break;
;;;2379   
;;;2380                    case 4u:
;;;2381                         if (p_tcb->SemCtr == DEF_INT_32U_MAX_VAL) {
;;;2382                             OS_CRITICAL_EXIT();
000028  4f4a              LDR      r7,|L26.340|
00002a  f8c58040          STR      r8,[r5,#0x40]         ;2357
00002e  8030              STRH     r0,[r6,#0]            ;2357
000030  f8950036          LDRB     r0,[r5,#0x36]         ;2358
;;;2383                            *p_err = OS_ERR_SEM_OVF;
000034  f64659c5          MOV      r9,#0x6dc5
000038  2808              CMP      r0,#8                 ;2358
00003a  d26f              BCS      |L26.284|
00003c  e8dff000          TBB      [pc,r0]               ;2358
000040  04042e2e          DCB      0x04,0x04,0x2e,0x2e
000044  04042e2e          DCB      0x04,0x04,0x2e,0x2e
000048  f8d58044          LDR      r8,[r5,#0x44]         ;2381
00004c  f1180001          ADDS     r0,r8,#1              ;2381
000050  d051              BEQ      |L26.246|
;;;2384                             return ((OS_SEM_CTR)0);
;;;2385                         }
;;;2386                         break;
;;;2387   
;;;2388                    default:
;;;2389                         break;
;;;2390                }
;;;2391                p_tcb->SemCtr++;                               /* Task signaled is not pending on anything               */
000052  4680              MOV      r8,r0
;;;2392                ctr = p_tcb->SemCtr;
;;;2393                OS_CRITICAL_EXIT();
000054  f8c58044          STR      r8,[r5,#0x44]
000058  f7fffffe          BL       CPU_SR_Save
00005c  7821              LDRB     r1,[r4,#0]  ; OSSchedLockNestingCtr
00005e  1e49              SUBS     r1,r1,#1
000060  f01101ff          ANDS     r1,r1,#0xff
000064  7021              STRB     r1,[r4,#0]
000066  d00e              BEQ      |L26.134|
000068  e015              B        |L26.150|
00006a  bf00              NOP                            ;2382
                  |L26.108|
00006c  f7fffffe          BL       CPU_SR_Restore
000070  f7fffffe          BL       OS_Sched0
000074  e002              B        |L26.124|
000076  bf00              NOP                            ;2382
                  |L26.120|
000078  f7fffffe          BL       CPU_SR_Restore
                  |L26.124|
;;;2394                break;
;;;2395   
;;;2396           case OS_TASK_STATE_PEND:
;;;2397           case OS_TASK_STATE_PEND_TIMEOUT:
;;;2398           case OS_TASK_STATE_PEND_SUSPENDED:
;;;2399           case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
;;;2400                if (p_tcb->PendOn == OS_TASK_PEND_ON_TASK_SEM) {   /* Is task signaled waiting for a signal?             */
;;;2401                    OS_Post((OS_PEND_OBJ *)0,                      /*      Task is pending on signal                     */
;;;2402                            (OS_TCB      *)p_tcb,
;;;2403                            (void        *)0,
;;;2404                            (OS_MSG_SIZE  )0u,
;;;2405                            (CPU_TS       )ts);
;;;2406                    ctr = p_tcb->SemCtr;
;;;2407                    OS_CRITICAL_EXIT_NO_SCHED();
;;;2408                    if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0) {
;;;2409                        OSSched();                                 /* Run the scheduler                                  */
;;;2410                    }
;;;2411                } else {
;;;2412                    switch (sizeof(OS_SEM_CTR)) {
;;;2413                        case 1u:
;;;2414                             if (p_tcb->SemCtr == DEF_INT_08U_MAX_VAL) {
;;;2415                                 OS_CRITICAL_EXIT();
;;;2416                                *p_err = OS_ERR_SEM_OVF;
;;;2417                                 return ((OS_SEM_CTR)0);
;;;2418                             }
;;;2419                             break;
;;;2420   
;;;2421                        case 2u:
;;;2422                             if (p_tcb->SemCtr == DEF_INT_16U_MAX_VAL) {
;;;2423                                 OS_CRITICAL_EXIT();
;;;2424                                *p_err = OS_ERR_SEM_OVF;
;;;2425                                 return ((OS_SEM_CTR)0);
;;;2426                             }
;;;2427                             break;
;;;2428   
;;;2429                        case 4u:
;;;2430                             if (p_tcb->SemCtr == DEF_INT_32U_MAX_VAL) {
;;;2431                                 OS_CRITICAL_EXIT();
;;;2432                                *p_err = OS_ERR_SEM_OVF;
00007c  f8a69000          STRH     r9,[r6,#0]
;;;2433                                 return ((OS_SEM_CTR)0);
000080  2000              MOVS     r0,#0
                  |L26.130|
;;;2434                             }
;;;2435                             break;
;;;2436   
;;;2437                        default:
;;;2438                             break;
;;;2439                    }
;;;2440                    p_tcb->SemCtr++;                           /* No,  Task signaled is NOT pending on semaphore ...     */
;;;2441                    ctr = p_tcb->SemCtr;                       /*      ... it must be waiting on something else          */
;;;2442                    OS_CRITICAL_EXIT();
;;;2443                }
;;;2444                break;
;;;2445   
;;;2446           default:
;;;2447                OS_CRITICAL_EXIT();
;;;2448               *p_err = OS_ERR_STATE_INVALID;
;;;2449                ctr   = (OS_SEM_CTR)0;
;;;2450                break;
;;;2451       }
;;;2452       return (ctr);
;;;2453   }
000082  e8bd8ff8          POP      {r3-r11,pc}
                  |L26.134|
000086  8839              LDRH     r1,[r7,#0]            ;2393  ; OSIntQNbrEntries
000088  b129              CBZ      r1,|L26.150|
00008a  bf00              NOP                            ;2393
                  |L26.140|
00008c  f7fffffe          BL       CPU_SR_Restore
000090  f7fffffe          BL       OS_Sched0
000094  e058              B        |L26.328|
                  |L26.150|
000096  f7fffffe          BL       CPU_SR_Restore
00009a  e055              B        |L26.328|
00009c  f8950034          LDRB     r0,[r5,#0x34]         ;2400
0000a0  2807              CMP      r0,#7                 ;2400
0000a2  d011              BEQ      |L26.200|
0000a4  f8d58044          LDR      r8,[r5,#0x44]         ;2430
0000a8  f1180001          ADDS     r0,r8,#1              ;2430
0000ac  d023              BEQ      |L26.246|
0000ae  4680              MOV      r8,r0                 ;2440
0000b0  f8c58044          STR      r8,[r5,#0x44]         ;2442
0000b4  f7fffffe          BL       CPU_SR_Save
0000b8  4601              MOV      r1,r0                 ;2442
0000ba  7820              LDRB     r0,[r4,#0]            ;2442  ; OSSchedLockNestingCtr
0000bc  1e40              SUBS     r0,r0,#1              ;2442
0000be  f01000ff          ANDS     r0,r0,#0xff           ;2442
0000c2  7020              STRB     r0,[r4,#0]            ;2442
0000c4  d023              BEQ      |L26.270|
0000c6  e026              B        |L26.278|
                  |L26.200|
0000c8  2300              MOVS     r3,#0                 ;2401
0000ca  461a              MOV      r2,r3                 ;2401
0000cc  4629              MOV      r1,r5                 ;2401
0000ce  4618              MOV      r0,r3                 ;2401
0000d0  f8cd8000          STR      r8,[sp,#0]            ;2401
0000d4  f7fffffe          BL       OS_Post
0000d8  f8d58044          LDR      r8,[r5,#0x44]         ;2407
0000dc  f7fffffe          BL       CPU_SR_Save
0000e0  7821              LDRB     r1,[r4,#0]            ;2407  ; OSSchedLockNestingCtr
0000e2  1e49              SUBS     r1,r1,#1              ;2407
0000e4  7021              STRB     r1,[r4,#0]            ;2407
0000e6  f7fffffe          BL       CPU_SR_Restore
0000ea  ea5f400a          LSLS     r0,r10,#16            ;2408
0000ee  d42b              BMI      |L26.328|
0000f0  f7fffffe          BL       OSSched
0000f4  e028              B        |L26.328|
                  |L26.246|
0000f6  f7fffffe          BL       CPU_SR_Save
0000fa  7821              LDRB     r1,[r4,#0]            ;2431  ; OSSchedLockNestingCtr
0000fc  1e49              SUBS     r1,r1,#1              ;2431
0000fe  f01101ff          ANDS     r1,r1,#0xff           ;2431
000102  7021              STRB     r1,[r4,#0]            ;2431
000104  d1b8              BNE      |L26.120|
000106  8839              LDRH     r1,[r7,#0]            ;2431  ; OSIntQNbrEntries
000108  2900              CMP      r1,#0                 ;2431
00010a  d0b5              BEQ      |L26.120|
00010c  e7ae              B        |L26.108|
                  |L26.270|
00010e  8838              LDRH     r0,[r7,#0]            ;2442  ; OSIntQNbrEntries
000110  b108              CBZ      r0,|L26.278|
000112  4608              MOV      r0,r1                 ;2442
000114  e7ba              B        |L26.140|
                  |L26.278|
000116  4608              MOV      r0,r1                 ;2442
000118  e7bd              B        |L26.150|
00011a  e7ff              B        |L26.284|
                  |L26.284|
00011c  f7fffffe          BL       CPU_SR_Save
000120  7821              LDRB     r1,[r4,#0]            ;2447  ; OSSchedLockNestingCtr
000122  1e49              SUBS     r1,r1,#1              ;2447
000124  f01101ff          ANDS     r1,r1,#0xff           ;2447
000128  7021              STRB     r1,[r4,#0]            ;2447
00012a  d106              BNE      |L26.314|
00012c  8839              LDRH     r1,[r7,#0]            ;2447  ; OSIntQNbrEntries
00012e  b121              CBZ      r1,|L26.314|
000130  f7fffffe          BL       CPU_SR_Restore
000134  f7fffffe          BL       OS_Sched0
000138  e001              B        |L26.318|
                  |L26.314|
00013a  f7fffffe          BL       CPU_SR_Restore
                  |L26.318|
00013e  f646602d          MOV      r0,#0x6e2d            ;2448
000142  8030              STRH     r0,[r6,#0]            ;2448
000144  f04f0800          MOV      r8,#0                 ;2449
                  |L26.328|
000148  4640              MOV      r0,r8                 ;2452
00014a  e79a              B        |L26.130|
;;;2454   
                          ENDP

                  |L26.332|
                          DCD      OSSchedLockNestingCtr
                  |L26.336|
                          DCD      OSTCBCurPtr
                  |L26.340|
                          DCD      OSIntQNbrEntries

                          AREA ||i.OS_TaskSuspend||, CODE, READONLY, ALIGN=2

                  OS_TaskSuspend PROC
;;;2485   #if OS_CFG_TASK_SUSPEND_EN > 0u
;;;2486   void   OS_TaskSuspend (OS_TCB  *p_tcb,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2487                          OS_ERR  *p_err)
;;;2488   {
000004  460f              MOV      r7,r1
000006  4604              MOV      r4,r0
;;;2489       CPU_SR_ALLOC();
;;;2490   
;;;2491   
;;;2492   
;;;2493       CPU_CRITICAL_ENTER();
000008  f7fffffe          BL       CPU_SR_Save
;;;2494       if (p_tcb == (OS_TCB *)0) {                             /* See if specified to suspend self                       */
;;;2495           p_tcb = OSTCBCurPtr;
00000c  4924              LDR      r1,|L27.160|
00000e  b904              CBNZ     r4,|L27.18|
000010  680c              LDR      r4,[r1,#0]  ; OSTCBCurPtr
                  |L27.18|
;;;2496       }
;;;2497   
;;;2498       if (p_tcb == OSTCBCurPtr) {
000012  6809              LDR      r1,[r1,#0]  ; OSTCBCurPtr
;;;2499           if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {    /* Can't suspend when the scheduler is locked             */
000014  4d23              LDR      r5,|L27.164|
000016  428c              CMP      r4,r1                 ;2498
000018  d106              BNE      |L27.40|
00001a  7829              LDRB     r1,[r5,#0]  ; OSSchedLockNestingCtr
00001c  b121              CBZ      r1,|L27.40|
;;;2500               CPU_CRITICAL_EXIT();
00001e  f7fffffe          BL       CPU_SR_Restore
;;;2501              *p_err = OS_ERR_SCHED_LOCKED;
000022  f6465063          MOV      r0,#0x6d63
;;;2502               return;
000026  e038              B        |L27.154|
                  |L27.40|
;;;2503           }
;;;2504       }
;;;2505   
;;;2506      *p_err = OS_ERR_NONE;
000028  2100              MOVS     r1,#0
00002a  8039              STRH     r1,[r7,#0]
;;;2507       switch (p_tcb->TaskState) {
00002c  f8941036          LDRB     r1,[r4,#0x36]
000030  2601              MOVS     r6,#1
000032  2908              CMP      r1,#8
000034  d22d              BCS      |L27.146|
000036  e8dff001          TBB      [pc,r1]
00003a  0417              DCB      0x04,0x17
00003c  1f212727          DCB      0x1f,0x21,0x27,0x27
000040  2727              DCB      0x27,0x27
;;;2508           case OS_TASK_STATE_RDY:
;;;2509                OS_CRITICAL_ENTER_CPU_CRITICAL_EXIT();
000042  7829              LDRB     r1,[r5,#0]  ; OSSchedLockNestingCtr
000044  1c49              ADDS     r1,r1,#1
000046  7029              STRB     r1,[r5,#0]
000048  f7fffffe          BL       CPU_SR_Restore
;;;2510                p_tcb->TaskState  =  OS_TASK_STATE_SUSPENDED;
00004c  2004              MOVS     r0,#4
00004e  f8840036          STRB     r0,[r4,#0x36]
;;;2511                p_tcb->SuspendCtr = (OS_NESTING_CTR)1;
000052  f884608a          STRB     r6,[r4,#0x8a]
;;;2512                OS_RdyListRemove(p_tcb);
000056  4620              MOV      r0,r4
000058  f7fffffe          BL       OS_RdyListRemove
;;;2513                OS_CRITICAL_EXIT_NO_SCHED();
00005c  f7fffffe          BL       CPU_SR_Save
000060  7829              LDRB     r1,[r5,#0]  ; OSSchedLockNestingCtr
000062  1e49              SUBS     r1,r1,#1
000064  7029              STRB     r1,[r5,#0]
;;;2514                break;
000066  e001              B        |L27.108|
;;;2515   
;;;2516           case OS_TASK_STATE_DLY:
;;;2517                p_tcb->TaskState  = OS_TASK_STATE_DLY_SUSPENDED;
000068  2105              MOVS     r1,#5
;;;2518                p_tcb->SuspendCtr = (OS_NESTING_CTR)1;
;;;2519                CPU_CRITICAL_EXIT();
;;;2520                break;
00006a  e008              B        |L27.126|
                  |L27.108|
00006c  f7fffffe          BL       CPU_SR_Restore
;;;2521   
;;;2522           case OS_TASK_STATE_PEND:
;;;2523                p_tcb->TaskState  = OS_TASK_STATE_PEND_SUSPENDED;
;;;2524                p_tcb->SuspendCtr = (OS_NESTING_CTR)1;
;;;2525                CPU_CRITICAL_EXIT();
;;;2526                break;
;;;2527   
;;;2528           case OS_TASK_STATE_PEND_TIMEOUT:
;;;2529                p_tcb->TaskState  = OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED;
;;;2530                p_tcb->SuspendCtr = (OS_NESTING_CTR)1;
;;;2531                CPU_CRITICAL_EXIT();
;;;2532                break;
;;;2533   
;;;2534           case OS_TASK_STATE_SUSPENDED:
;;;2535           case OS_TASK_STATE_DLY_SUSPENDED:
;;;2536           case OS_TASK_STATE_PEND_SUSPENDED:
;;;2537           case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
;;;2538                p_tcb->SuspendCtr++;
;;;2539                CPU_CRITICAL_EXIT();
;;;2540                break;
;;;2541   
;;;2542           default:
;;;2543                CPU_CRITICAL_EXIT();
;;;2544               *p_err = OS_ERR_STATE_INVALID;
;;;2545                return;
;;;2546       }
;;;2547   
;;;2548       OSSched();
000070  e8bd41f0          POP      {r4-r8,lr}
000074  f7ffbffe          B.W      OSSched
000078  2106              MOVS     r1,#6                 ;2523
00007a  e000              B        |L27.126|
00007c  2107              MOVS     r1,#7                 ;2529
                  |L27.126|
00007e  f8841036          STRB     r1,[r4,#0x36]         ;2529
000082  f884608a          STRB     r6,[r4,#0x8a]         ;2530
000086  e7f1              B        |L27.108|
000088  f8141f8a          LDRB     r1,[r4,#0x8a]!        ;2538
00008c  1c49              ADDS     r1,r1,#1              ;2538
00008e  7021              STRB     r1,[r4,#0]            ;2538
000090  e7ec              B        |L27.108|
                  |L27.146|
000092  f7fffffe          BL       CPU_SR_Restore
000096  f646602d          MOV      r0,#0x6e2d            ;2544
                  |L27.154|
00009a  8038              STRH     r0,[r7,#0]            ;2544
;;;2549   }
00009c  e8bd81f0          POP      {r4-r8,pc}
;;;2550   #endif
                          ENDP

                  |L27.160|
                          DCD      OSTCBCurPtr
                  |L27.164|
                          DCD      OSSchedLockNestingCtr
