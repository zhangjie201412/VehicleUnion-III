; generated by ARM C/C++ Compiler, 5.02 [Build 28]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\OBJ\lib_str.o --asm_dir=.\List\ --list_dir=.\List\ --depend=..\OBJ\lib_str.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\BSP -I..\CORE -I..\STM32F10x_FWLib\inc -I..\USER -I..\UCOSIII\uC-CPU -I..\UCOSIII\uC-CPU\ARM-Cortex-M3\RealView -I..\UCOSIII\uC-LIB -I..\UCOSIII\uC-LIB\Ports\ARM-Cortex-M3\RealView -I..\UCOSIII\uCOS-III -I..\UCOSIII\uCOS-III\Ports -I..\UCOSIII\uCOS-III\Ports\ARM-Cortex-M3\Generic\RealView -I..\UCOSIII\uCOS-III\Source -I..\UCOSIII\UCOS_BSP -I..\UCOSIII\uCOS_CONFIG -I..\UCOSIII-Task -I..\SYSTEM -I..\BSP\inc -I..\PAL -I..\PAL\vehicles -ID:\Keil_v4\ARM\RV31\INC -ID:\Keil_v4\ARM\CMSIS\Include -ID:\Keil_v4\ARM\Inc\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=..\OBJ\lib_str.crf ..\UCOSIII\uC-LIB\lib_str.c]
                          THUMB

                          AREA ||i.Str_Cat||, CODE, READONLY, ALIGN=1

                  Str_Cat PROC
;;;537    
;;;538    CPU_CHAR  *Str_Cat (       CPU_CHAR  *pstr_dest,
000000  f04f32ff          MOV      r2,#0xffffffff
;;;539                        const  CPU_CHAR  *pstr_cat)
;;;540    {
;;;541        CPU_CHAR  *pstr_rtn;
;;;542    
;;;543    
;;;544        pstr_rtn = Str_Cat_N(pstr_dest,
000004  f7ffbffe          B.W      Str_Cat_N
;;;545                             pstr_cat,
;;;546                             DEF_INT_CPU_U_MAX_VAL);
;;;547    
;;;548        return (pstr_rtn);
;;;549    }
;;;550    
                          ENDP


                          AREA ||i.Str_Cat_N||, CODE, READONLY, ALIGN=1

                  Str_Cat_N PROC
;;;619    
;;;620    CPU_CHAR  *Str_Cat_N (       CPU_CHAR    *pstr_dest,
000000  b530              PUSH     {r4,r5,lr}
;;;621                          const  CPU_CHAR    *pstr_cat,
;;;622                                 CPU_SIZE_T   len_max)
;;;623    {
000002  2800              CMP      r0,#0
000004  d00b              BEQ      |L2.30|
;;;624               CPU_CHAR    *pstr_cat_dest;
;;;625        const  CPU_CHAR    *pstr_cat_src;
;;;626               CPU_SIZE_T   len_cat;
;;;627    
;;;628                                                                    /* Rtn NULL if str ptr(s) NULL (see Note #3a1).         */
;;;629        if (pstr_dest == (CPU_CHAR *)0) {
;;;630            return ((CPU_CHAR *)0);
;;;631        }
;;;632        if (pstr_cat  == (const CPU_CHAR *)0) {
000006  b149              CBZ      r1,|L2.28|
;;;633            return ((CPU_CHAR *)0);
;;;634        }
;;;635    
;;;636        if (len_max < 1) {                                          /* Rtn dest str if cat len = 0 (see Note #3d2A).        */
000008  2a00              CMP      r2,#0
00000a  d008              BEQ      |L2.30|
;;;637            return ((CPU_CHAR *)pstr_dest);
;;;638        }
;;;639    
;;;640    
;;;641        pstr_cat_dest = pstr_dest;
00000c  4603              MOV      r3,r0
;;;642        while (( pstr_cat_dest != (CPU_CHAR *)  0 ) &&              /* Adv to end of cur dest str until NULL ptr ...        */
00000e  e001              B        |L2.20|
                  |L2.16|
;;;643               (*pstr_cat_dest != (CPU_CHAR  )'\0')) {              /* ... or NULL char found..                             */
;;;644            pstr_cat_dest++;
000010  1c5b              ADDS     r3,r3,#1
000012  d003              BEQ      |L2.28|
                  |L2.20|
000014  781c              LDRB     r4,[r3,#0]            ;643
000016  2c00              CMP      r4,#0                 ;643
000018  d1fa              BNE      |L2.16|
00001a  e007              B        |L2.44|
                  |L2.28|
;;;645        }
;;;646        if (pstr_cat_dest == (CPU_CHAR *)0) {                       /* Rtn NULL if NULL ptr found (see Note #3b1).          */
;;;647            return ((CPU_CHAR *)0);
00001c  2000              MOVS     r0,#0
                  |L2.30|
;;;648        }
;;;649    
;;;650        pstr_cat_src = pstr_cat;
;;;651        len_cat      = 0u;
;;;652    
;;;653        while (( pstr_cat_dest != (      CPU_CHAR *)  0 ) &&        /* Cat str until NULL ptr(s)  [see Note #3b]  ...       */
;;;654               ( pstr_cat_src  != (const CPU_CHAR *)  0 ) &&
;;;655               (*pstr_cat_src  != (      CPU_CHAR  )'\0') &&        /* ... or NULL char found     (see Note #3c); ...       */
;;;656               ( len_cat       <  (      CPU_SIZE_T)len_max)) {     /* ... or max nbr chars cat'd (see Note #3d).           */
;;;657           *pstr_cat_dest = *pstr_cat_src;
;;;658            pstr_cat_dest++;
;;;659            pstr_cat_src++;
;;;660            len_cat++;
;;;661        }
;;;662                                                                    /* Rtn NULL if NULL ptr(s) found (see Note #3b1).       */
;;;663        if ((pstr_cat_dest == (      CPU_CHAR *)0) ||
;;;664            (pstr_cat_src  == (const CPU_CHAR *)0)) {
;;;665             return ((CPU_CHAR *)0);
;;;666        }
;;;667    
;;;668       *pstr_cat_dest = (CPU_CHAR)'\0';                             /* Append NULL char    (see Note #2a2C).                */
;;;669    
;;;670    
;;;671        return (pstr_dest);                                         /* Rtn ptr to dest str (see Note #2b1).                 */
;;;672    }
00001e  bd30              POP      {r4,r5,pc}
                  |L2.32|
000020  f8035b01          STRB     r5,[r3],#1            ;657
000024  1c49              ADDS     r1,r1,#1              ;659
000026  1c64              ADDS     r4,r4,#1              ;660
000028  2b00              CMP      r3,#0                 ;660
00002a  d0f7              BEQ      |L2.28|
                  |L2.44|
00002c  2900              CMP      r1,#0                 ;654
00002e  d0f5              BEQ      |L2.28|
000030  780d              LDRB     r5,[r1,#0]            ;655
000032  b10d              CBZ      r5,|L2.56|
000034  4294              CMP      r4,r2                 ;656
000036  d3f3              BCC      |L2.32|
                  |L2.56|
000038  2100              MOVS     r1,#0                 ;668
00003a  7019              STRB     r1,[r3,#0]            ;668
00003c  bd30              POP      {r4,r5,pc}
;;;673    
                          ENDP


                          AREA ||i.Str_Char||, CODE, READONLY, ALIGN=1

                  Str_Char PROC
;;;1264   
;;;1265   CPU_CHAR  *Str_Char (const  CPU_CHAR  *pstr,
000000  460a              MOV      r2,r1
;;;1266                               CPU_CHAR   srch_char)
;;;1267   {
;;;1268       CPU_CHAR  *pstr_rtn;
;;;1269   
;;;1270   
;;;1271       pstr_rtn = Str_Char_N(pstr,
000002  f04f31ff          MOV      r1,#0xffffffff
000006  f7ffbffe          B.W      Str_Char_N
;;;1272                             DEF_INT_CPU_U_MAX_VAL,
;;;1273                             srch_char);
;;;1274   
;;;1275       return (pstr_rtn);
;;;1276   }
;;;1277   
                          ENDP


                          AREA ||i.Str_Char_Last||, CODE, READONLY, ALIGN=1

                  Str_Char_Last PROC
;;;1441   
;;;1442   CPU_CHAR  *Str_Char_Last (const  CPU_CHAR  *pstr,
000000  460a              MOV      r2,r1
;;;1443                                    CPU_CHAR   srch_char)
;;;1444   {
;;;1445       CPU_CHAR  *pstr_rtn;
;;;1446   
;;;1447   
;;;1448       pstr_rtn = Str_Char_Last_N(pstr,
000002  f04f31ff          MOV      r1,#0xffffffff
000006  f7ffbffe          B.W      Str_Char_Last_N
;;;1449                                  DEF_INT_CPU_U_MAX_VAL,
;;;1450                                  srch_char);
;;;1451   
;;;1452       return (pstr_rtn);
;;;1453   }
;;;1454   
                          ENDP


                          AREA ||i.Str_Char_Last_N||, CODE, READONLY, ALIGN=1

                  Str_Char_Last_N PROC
;;;1523   
;;;1524   CPU_CHAR  *Str_Char_Last_N (const  CPU_CHAR    *pstr,
000000  b530              PUSH     {r4,r5,lr}
;;;1525                                      CPU_SIZE_T   len_max,
;;;1526                                      CPU_CHAR     srch_char)
;;;1527   {
000002  4615              MOV      r5,r2
000004  0004              MOVS     r4,r0
000006  d00f              BEQ      |L5.40|
;;;1528       const  CPU_CHAR    *pstr_char;
;;;1529              CPU_SIZE_T   str_len_max;
;;;1530              CPU_SIZE_T   str_len;
;;;1531   
;;;1532   
;;;1533       if (pstr == (const CPU_CHAR *)0) {                          /* Rtn NULL if srch str ptr NULL (see Note #3a1).       */
;;;1534           return ((CPU_CHAR *)0);
;;;1535       }
;;;1536   
;;;1537       if (len_max < 1) {                                          /* Rtn NULL if srch len = 0      (see Note #3e1).       */
000008  b171              CBZ      r1,|L5.40|
;;;1538           return ((CPU_CHAR *)0);
;;;1539       }
;;;1540   
;;;1541   
;;;1542       pstr_char    = pstr;
;;;1543        str_len_max = len_max - sizeof((CPU_CHAR)'\0');            /* Str len adj'd for NULL char len.                     */
00000a  1e49              SUBS     r1,r1,#1
;;;1544        str_len     = Str_Len_N(pstr_char, str_len_max);
00000c  f7fffffe          BL       Str_Len_N
;;;1545       pstr_char   += str_len;
000010  1820              ADDS     r0,r4,r0
;;;1546   
;;;1547       if (pstr_char == (const CPU_CHAR *)0) {                     /* Rtn NULL if NULL ptr found        (see Note #3b1).   */
000012  d00a              BEQ      |L5.42|
000014  e000              B        |L5.24|
                  |L5.22|
;;;1548           return ((CPU_CHAR *)0);
;;;1549       }
;;;1550   
;;;1551       while (( pstr_char != pstr) &&                              /* Srch str from end until beginning (see Note #3c) ... */
;;;1552              (*pstr_char != srch_char)) {                         /* ... until srch char found         (see Note #3d).    */
;;;1553           pstr_char--;
000016  1e40              SUBS     r0,r0,#1
                  |L5.24|
000018  42a0              CMP      r0,r4                 ;1551
00001a  d002              BEQ      |L5.34|
00001c  7801              LDRB     r1,[r0,#0]            ;1552
00001e  42a9              CMP      r1,r5                 ;1552
000020  d1f9              BNE      |L5.22|
                  |L5.34|
;;;1554       }
;;;1555   
;;;1556   
;;;1557       if (*pstr_char != srch_char) {                              /* Rtn NULL if srch char NOT found   (see Note #3c1).   */
000022  7801              LDRB     r1,[r0,#0]
000024  42a9              CMP      r1,r5
000026  d000              BEQ      |L5.42|
                  |L5.40|
;;;1558            return ((CPU_CHAR *)0);
000028  2000              MOVS     r0,#0
                  |L5.42|
;;;1559       }
;;;1560   
;;;1561   
;;;1562       return ((CPU_CHAR *)pstr_char);                             /* Else rtn ptr to found srch char   (see Note #3d1).   */
;;;1563   }
00002a  bd30              POP      {r4,r5,pc}
;;;1564   
                          ENDP


                          AREA ||i.Str_Char_N||, CODE, READONLY, ALIGN=1

                  Str_Char_N PROC
;;;1344   
;;;1345   CPU_CHAR  *Str_Char_N (const  CPU_CHAR    *pstr,
000000  b510              PUSH     {r4,lr}
;;;1346                                 CPU_SIZE_T   len_max,
;;;1347                                 CPU_CHAR     srch_char)
;;;1348   {
000002  2800              CMP      r0,#0
000004  d012              BEQ      |L6.44|
;;;1349       const  CPU_CHAR    *pstr_char;
;;;1350              CPU_SIZE_T   len_srch;
;;;1351   
;;;1352   
;;;1353       if (pstr == (const CPU_CHAR *)0) {                          /* Rtn NULL if srch str ptr NULL (see Note #3a1).       */
;;;1354           return ((CPU_CHAR *)0);
;;;1355       }
;;;1356   
;;;1357       if (len_max < 1) {                                          /* Rtn NULL if srch len = 0      (see Note #3e1).       */
000006  b181              CBZ      r1,|L6.42|
;;;1358           return ((CPU_CHAR *)0);
;;;1359       }
;;;1360   
;;;1361   
;;;1362       pstr_char = pstr;
;;;1363       len_srch  = 0u;
000008  2300              MOVS     r3,#0
;;;1364   
;;;1365       while (( pstr_char != (const CPU_CHAR *)  0 )      &&       /* Srch str until NULL ptr     [see Note #3b]  ...      */
00000a  e003              B        |L6.20|
                  |L6.12|
;;;1366              (*pstr_char != (      CPU_CHAR  )'\0')      &&       /* ... or NULL char            (see Note #3c)  ...      */
;;;1367              (*pstr_char != (      CPU_CHAR  )srch_char) &&       /* ... or srch char found      (see Note #3d); ...      */
;;;1368              ( len_srch  <  (      CPU_SIZE_T)len_max)) {         /* ... or max nbr chars srch'd (see Note #3e).          */
;;;1369           pstr_char++;
00000c  1c40              ADDS     r0,r0,#1
;;;1370           len_srch++;
00000e  f1030301          ADD      r3,r3,#1
000012  d00b              BEQ      |L6.44|
                  |L6.20|
000014  7804              LDRB     r4,[r0,#0]            ;1366
000016  b11c              CBZ      r4,|L6.32|
000018  4294              CMP      r4,r2                 ;1367
00001a  d001              BEQ      |L6.32|
00001c  428b              CMP      r3,r1                 ;1368
00001e  d3f5              BCC      |L6.12|
                  |L6.32|
;;;1371       }
;;;1372   
;;;1373   
;;;1374       if (pstr_char == (const CPU_CHAR *)0) {                     /* Rtn NULL if NULL ptr found      (see Note #3b1).     */
;;;1375           return ((CPU_CHAR *)0);
;;;1376       }
;;;1377   
;;;1378       if (len_srch >= len_max) {                                  /* Rtn NULL if srch char NOT found ...                  */
000020  428b              CMP      r3,r1
000022  d202              BCS      |L6.42|
;;;1379           return ((CPU_CHAR *)0);                                 /* ... within max nbr of chars     (see Note #3e1).     */
;;;1380       }
;;;1381   
;;;1382       if (*pstr_char != srch_char) {                              /* Rtn NULL if srch char NOT found (see Note #3c1).     */
000024  b2e1              UXTB     r1,r4
000026  4291              CMP      r1,r2
000028  d000              BEQ      |L6.44|
                  |L6.42|
;;;1383            return ((CPU_CHAR *)0);
00002a  2000              MOVS     r0,#0
                  |L6.44|
;;;1384       }
;;;1385   
;;;1386   
;;;1387       return ((CPU_CHAR *)pstr_char);                             /* Else rtn ptr to found srch char (see Note #3d1).     */
;;;1388   }
00002c  bd10              POP      {r4,pc}
;;;1389   
                          ENDP


                          AREA ||i.Str_Char_Replace||, CODE, READONLY, ALIGN=1

                  Str_Char_Replace PROC
;;;1602   
;;;1603   CPU_CHAR  *Str_Char_Replace (CPU_CHAR  *pstr,
000000  f04f33ff          MOV      r3,#0xffffffff
;;;1604                                CPU_CHAR   char_srch,
;;;1605                                CPU_CHAR   char_replace)
;;;1606   {
;;;1607       CPU_CHAR  *pstr_rtn;
;;;1608   
;;;1609   
;;;1610       pstr_rtn = Str_Char_Replace_N(pstr,
000004  f7ffbffe          B.W      Str_Char_Replace_N
;;;1611                                     char_srch,
;;;1612                                     char_replace,
;;;1613                                     DEF_INT_CPU_U_MAX_VAL);
;;;1614   
;;;1615       return (pstr_rtn);
;;;1616   }
;;;1617   
                          ENDP


                          AREA ||i.Str_Char_Replace_N||, CODE, READONLY, ALIGN=1

                  Str_Char_Replace_N PROC
;;;1664   
;;;1665   CPU_CHAR  *Str_Char_Replace_N (CPU_CHAR    *pstr,
000000  b530              PUSH     {r4,r5,lr}
;;;1666                                  CPU_CHAR     char_srch,
;;;1667                                  CPU_CHAR     char_replace,
;;;1668                                  CPU_SIZE_T   len_max)
;;;1669   {
000002  2800              CMP      r0,#0
000004  d003              BEQ      |L8.14|
;;;1670       CPU_CHAR    *pstr_char;
;;;1671       CPU_SIZE_T   len;
;;;1672   
;;;1673   
;;;1674       if (pstr == (const CPU_CHAR *)0) {                          /* Rtn NULL if srch str ptr NULL (see Note #2a1).       */
;;;1675           return ((CPU_CHAR *)0);
;;;1676       }
;;;1677   
;;;1678       if (len_max < 1) {                                          /* Rtn NULL if srch len = 0      (see Note #2e1).       */
000006  b10b              CBZ      r3,|L8.12|
;;;1679           return ((CPU_CHAR *)0);
;;;1680       }
;;;1681   
;;;1682       pstr_char = pstr;
000008  4604              MOV      r4,r0
;;;1683       len       = len_max;
;;;1684   
;;;1685       while (( pstr_char != (const CPU_CHAR *)0) &&               /* Srch str until NULL ptr     [see Note #2b]  ...      */
00000a  e008              B        |L8.30|
                  |L8.12|
00000c  2000              MOVS     r0,#0                 ;1679
                  |L8.14|
;;;1686              (*pstr_char !=  ASCII_CHAR_NULL   ) &&               /* ... or NULL char            (see Note #2c)  ...      */
;;;1687              ( len        >                   0)) {               /* ... or max nbr chars srch'd (see Note #2e).          */
;;;1688   
;;;1689           if (*pstr_char == char_srch) {
;;;1690               *pstr_char  = char_replace;                         /* Replace char if srch char is found.                  */
;;;1691           }
;;;1692   
;;;1693           pstr_char++;
;;;1694           len--;
;;;1695       }
;;;1696   
;;;1697       return (pstr);
;;;1698   }
00000e  bd30              POP      {r4,r5,pc}
                  |L8.16|
000010  428d              CMP      r5,r1                 ;1689
000012  d100              BNE      |L8.22|
000014  7022              STRB     r2,[r4,#0]            ;1690
                  |L8.22|
000016  1c64              ADDS     r4,r4,#1              ;1693
000018  f1a30301          SUB      r3,r3,#1              ;1694
00001c  d0f7              BEQ      |L8.14|
                  |L8.30|
00001e  7825              LDRB     r5,[r4,#0]            ;1686
000020  2d00              CMP      r5,#0                 ;1686
000022  d0f4              BEQ      |L8.14|
000024  2b00              CMP      r3,#0                 ;1687
000026  d1f3              BNE      |L8.16|
000028  bd30              POP      {r4,r5,pc}
;;;1699   
                          ENDP


                          AREA ||i.Str_Cmp||, CODE, READONLY, ALIGN=1

                  Str_Cmp PROC
;;;749    
;;;750    CPU_INT16S  Str_Cmp (const  CPU_CHAR  *p1_str,
000000  f04f32ff          MOV      r2,#0xffffffff
;;;751                         const  CPU_CHAR  *p2_str)
;;;752    {
;;;753        CPU_INT16S  cmp_val;
;;;754    
;;;755    
;;;756        cmp_val = Str_Cmp_N(p1_str,
000004  f7ffbffe          B.W      Str_Cmp_N
;;;757                            p2_str,
;;;758                            DEF_INT_CPU_U_MAX_VAL);
;;;759    
;;;760        return (cmp_val);
;;;761    }
;;;762    
                          ENDP


                          AREA ||i.Str_CmpIgnoreCase||, CODE, READONLY, ALIGN=1

                  Str_CmpIgnoreCase PROC
;;;1014   
;;;1015   CPU_INT16S  Str_CmpIgnoreCase (const  CPU_CHAR  *p1_str,
000000  f04f32ff          MOV      r2,#0xffffffff
;;;1016                                  const  CPU_CHAR  *p2_str)
;;;1017   {
;;;1018       CPU_INT16S  cmp_val;
;;;1019   
;;;1020   
;;;1021       cmp_val = Str_CmpIgnoreCase_N(p1_str,
000004  f7ffbffe          B.W      Str_CmpIgnoreCase_N
;;;1022                                     p2_str,
;;;1023                                     DEF_INT_CPU_U_MAX_VAL);
;;;1024   
;;;1025       return (cmp_val);
;;;1026   }
;;;1027   
                          ENDP


                          AREA ||i.Str_CmpIgnoreCase_N||, CODE, READONLY, ALIGN=2

                  Str_CmpIgnoreCase_N PROC
;;;1125   
;;;1126   CPU_INT16S  Str_CmpIgnoreCase_N (const  CPU_CHAR    *p1_str,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1127                                    const  CPU_CHAR    *p2_str,
;;;1128                                           CPU_SIZE_T   len_max)
;;;1129   {
000004  ea5f0a02          MOVS     r10,r2
000008  d03b              BEQ      |L11.130|
;;;1130       const  CPU_CHAR    *p1_str_cmp;
;;;1131       const  CPU_CHAR    *p2_str_cmp;
;;;1132       const  CPU_CHAR    *p1_str_cmp_next;
;;;1133       const  CPU_CHAR    *p2_str_cmp_next;
;;;1134              CPU_CHAR     char_1;
;;;1135              CPU_CHAR     char_2;
;;;1136              CPU_INT16S   cmp_val;
;;;1137              CPU_SIZE_T   cmp_len;
;;;1138   
;;;1139   
;;;1140       if (len_max < 1) {                                          /* If cmp len = 0,        rtn 0       (see Note #3d1A). */
;;;1141           return (0);
;;;1142       }
;;;1143   
;;;1144       if (p1_str == (const CPU_CHAR *)0) {
00000a  b178              CBZ      r0,|L11.44|
;;;1145           if (p2_str == (const CPU_CHAR *)0) {
;;;1146               return (0);                                         /* If BOTH str ptrs NULL, rtn 0       (see Note #3a1A). */
;;;1147           }
;;;1148           char_2  =  ASCII_ToLower(*p2_str);
;;;1149           cmp_val = (CPU_INT16S)0 - (CPU_INT16S)char_2;
;;;1150           return (cmp_val);                                       /* If p1_str NULL, rtn neg p2_str val (see Note #3a1B1).*/
;;;1151       }
;;;1152       if (p2_str == (const CPU_CHAR *)0) {
00000c  b189              CBZ      r1,|L11.50|
;;;1153           char_1  =  ASCII_ToLower(*p1_str);
;;;1154           cmp_val = (CPU_INT16S)char_1;
;;;1155           return (cmp_val);                                       /* If p2_str NULL, rtn pos p1_str val (see Note #3a1B2).*/
;;;1156       }
;;;1157   
;;;1158   
;;;1159       p1_str_cmp      = p1_str;
00000e  4606              MOV      r6,r0
;;;1160       p2_str_cmp      = p2_str;
;;;1161       p1_str_cmp_next = p1_str_cmp;
;;;1162       p2_str_cmp_next = p2_str_cmp;
;;;1163       p1_str_cmp_next++;
000010  1c45              ADDS     r5,r0,#1
000012  4688              MOV      r8,r1                 ;1160
;;;1164       p2_str_cmp_next++;
000014  1c4c              ADDS     r4,r1,#1
;;;1165       char_1          = ASCII_ToLower(*p1_str_cmp);
000016  7800              LDRB     r0,[r0,#0]
000018  f7fffffe          BL       ASCII_ToLower
00001c  4607              MOV      r7,r0
;;;1166       char_2          = ASCII_ToLower(*p2_str_cmp);
00001e  f8980000          LDRB     r0,[r8,#0]
000022  f7fffffe          BL       ASCII_ToLower
;;;1167       cmp_len         = 0u;
000026  f04f0900          MOV      r9,#0
;;;1168   
;;;1169       while (( char_1          ==  char_2)                &&      /* Cmp strs until non-matching chars (see Note #3c) ... */
00002a  e014              B        |L11.86|
                  |L11.44|
00002c  b349              CBZ      r1,|L11.130|
00002e  7808              LDRB     r0,[r1,#0]            ;1148
000030  e02c              B        |L11.140|
                  |L11.50|
000032  7800              LDRB     r0,[r0,#0]            ;1153
000034  e021              B        |L11.122|
;;;1170              (*p1_str_cmp      != (      CPU_CHAR  )'\0') &&      /* ... or NULL chars                 (see Note #3b) ... */
;;;1171              ( p1_str_cmp_next != (const CPU_CHAR *)  0 ) &&      /* ... or NULL ptr(s) found          (see Note #3a2).   */
;;;1172              ( p2_str_cmp_next != (const CPU_CHAR *)  0 ) &&
;;;1173              ( cmp_len         <  (      CPU_SIZE_T)len_max)) {   /* ... or max nbr chars cmp'd        (see Note #3d2).   */
;;;1174           p1_str_cmp++;
;;;1175           p2_str_cmp++;
000036  bf00              NOP      
                  |L11.56|
000038  f1080801          ADD      r8,r8,#1
;;;1176           p1_str_cmp_next++;
00003c  1c6d              ADDS     r5,r5,#1
;;;1177           p2_str_cmp_next++;
00003e  1c64              ADDS     r4,r4,#1
;;;1178           cmp_len++;
000040  f1090901          ADD      r9,r9,#1
;;;1179           char_1 = ASCII_ToLower(*p1_str_cmp);
000044  f8160f01          LDRB     r0,[r6,#1]!
000048  f7fffffe          BL       ASCII_ToLower
00004c  4607              MOV      r7,r0
;;;1180           char_2 = ASCII_ToLower(*p2_str_cmp);
00004e  f8980000          LDRB     r0,[r8,#0]
000052  f7fffffe          BL       ASCII_ToLower
                  |L11.86|
000056  4287              CMP      r7,r0                 ;1169
000058  d105              BNE      |L11.102|
00005a  7831              LDRB     r1,[r6,#0]            ;1170
00005c  b119              CBZ      r1,|L11.102|
00005e  b115              CBZ      r5,|L11.102|
000060  b10c              CBZ      r4,|L11.102|
000062  45d1              CMP      r9,r10                ;1173
000064  d3e8              BCC      |L11.56|
                  |L11.102|
;;;1181       }
;;;1182   
;;;1183   
;;;1184       if (cmp_len == len_max) {                                   /* If strs     identical for max len nbr of chars, ...  */
000066  45d1              CMP      r9,r10
000068  d00b              BEQ      |L11.130|
;;;1185           return (0);                                             /* ... rtn 0                 (see Note #3d2A).          */
;;;1186       }
;;;1187   
;;;1188       if (char_1 != char_2) {                                     /* If strs NOT identical, ...                           */
00006a  4287              CMP      r7,r0
00006c  d002              BEQ      |L11.116|
;;;1189            cmp_val = (CPU_INT16S)char_1 - (CPU_INT16S)char_2;     /* ... calc & rtn char diff  (see Note #3c1).           */
00006e  1a38              SUBS     r0,r7,r0
                  |L11.112|
;;;1190   
;;;1191       } else if (char_1 == (CPU_CHAR)'\0') {                      /* If NULL char(s) found, ...                           */
;;;1192            cmp_val = (CPU_INT16S)0;                               /* ... strs identical; rtn 0 (see Note #3b).            */
;;;1193   
;;;1194       } else {
;;;1195           if (p1_str_cmp_next == (const CPU_CHAR *)0) {
;;;1196               if (p2_str_cmp_next == (const CPU_CHAR *)0) {       /* If BOTH next str ptrs NULL, ...                      */
;;;1197                   cmp_val = (CPU_INT16S)0;                        /* ... rtn 0                       (see Note #3a2A).    */
;;;1198               } else {                                            /* If p1_str_cmp_next NULL, ...                         */
;;;1199                   char_2  =  ASCII_ToLower(*p2_str_cmp_next);
;;;1200                   cmp_val = (CPU_INT16S)0 - (CPU_INT16S)char_2;   /* ... rtn neg p2_str_cmp_next val (see Note #3a2B1).   */
;;;1201               }
;;;1202           } else {                                                /* If p2_str_cmp_next NULL, ...                         */
;;;1203               char_1  =  ASCII_ToLower(*p1_str_cmp_next);
;;;1204               cmp_val = (CPU_INT16S)char_1;                       /* ... rtn pos p1_str_cmp_next val (see Note #3a2B2).   */
;;;1205           }
;;;1206       }
;;;1207   
;;;1208   
;;;1209       return (cmp_val);
;;;1210   }
000070  e8bd87f0          POP      {r4-r10,pc}
                  |L11.116|
000074  b12f              CBZ      r7,|L11.130|
000076  b135              CBZ      r5,|L11.134|
000078  7828              LDRB     r0,[r5,#0]            ;1203
                  |L11.122|
00007a  e8bd47f0          POP      {r4-r10,lr}           ;1203
00007e  f7ffbffe          B.W      ASCII_ToLower
                  |L11.130|
000082  2000              MOVS     r0,#0                 ;1192
000084  e7f4              B        |L11.112|
                  |L11.134|
000086  2c00              CMP      r4,#0                 ;1196
000088  d0fb              BEQ      |L11.130|
00008a  7820              LDRB     r0,[r4,#0]            ;1199
                  |L11.140|
00008c  f7fffffe          BL       ASCII_ToLower
000090  4240              RSBS     r0,r0,#0              ;1200
000092  e7ed              B        |L11.112|
;;;1211   
                          ENDP


                          AREA ||i.Str_Cmp_N||, CODE, READONLY, ALIGN=1

                  Str_Cmp_N PROC
;;;850    
;;;851    CPU_INT16S  Str_Cmp_N (const  CPU_CHAR    *p1_str,
000000  b5f0              PUSH     {r4-r7,lr}
;;;852                           const  CPU_CHAR    *p2_str,
;;;853                                  CPU_SIZE_T   len_max)
;;;854    {
000002  b31a              CBZ      r2,|L12.76|
;;;855        const  CPU_CHAR    *p1_str_cmp;
;;;856        const  CPU_CHAR    *p2_str_cmp;
;;;857        const  CPU_CHAR    *p1_str_cmp_next;
;;;858        const  CPU_CHAR    *p2_str_cmp_next;
;;;859               CPU_INT16S   cmp_val;
;;;860               CPU_SIZE_T   cmp_len;
;;;861    
;;;862    
;;;863        if (len_max < 1) {                                          /* If cmp len = 0,        rtn 0       (see Note #3d1A). */
;;;864            return (0);
;;;865        }
;;;866    
;;;867        if (p1_str == (const CPU_CHAR *)0) {
000004  b128              CBZ      r0,|L12.18|
;;;868            if (p2_str == (const CPU_CHAR *)0) {
;;;869                return (0);                                         /* If BOTH str ptrs NULL, rtn 0       (see Note #3a1A). */
;;;870            }
;;;871            cmp_val = (CPU_INT16S)0 - (CPU_INT16S)(*p2_str);
;;;872            return (cmp_val);                                       /* If p1_str NULL, rtn neg p2_str val (see Note #3a1B1).*/
;;;873        }
;;;874        if (p2_str == (const CPU_CHAR *)0) {
000006  b1f9              CBZ      r1,|L12.72|
;;;875            cmp_val = (CPU_INT16S)(*p1_str);
;;;876            return (cmp_val);                                       /* If p2_str NULL, rtn pos p1_str val (see Note #3a1B2).*/
;;;877        }
;;;878    
;;;879    
;;;880        p1_str_cmp      = p1_str;
000008  4603              MOV      r3,r0
;;;881        p2_str_cmp      = p2_str;
;;;882        p1_str_cmp_next = p1_str_cmp;
;;;883        p2_str_cmp_next = p2_str_cmp;
;;;884        p1_str_cmp_next++;
00000a  1c40              ADDS     r0,r0,#1
;;;885        p2_str_cmp_next++;
00000c  1c4c              ADDS     r4,r1,#1
;;;886        cmp_len         = 0u;
00000e  2500              MOVS     r5,#0
;;;887    
;;;888        while ((*p1_str_cmp      == *p2_str_cmp)            &&      /* Cmp strs until non-matching chars (see Note #3c) ... */
000010  e007              B        |L12.34|
                  |L12.18|
000012  b1d9              CBZ      r1,|L12.76|
000014  7808              LDRB     r0,[r1,#0]            ;871
000016  e01e              B        |L12.86|
                  |L12.24|
;;;889               (*p1_str_cmp      != (      CPU_CHAR  )'\0') &&      /* ... or NULL chars                 (see Note #3b) ... */
;;;890               ( p1_str_cmp_next != (const CPU_CHAR *)  0 ) &&      /* ... or NULL ptr(s) found          (see Note #3a2).   */
;;;891               ( p2_str_cmp_next != (const CPU_CHAR *)  0 ) &&
;;;892               ( cmp_len         <  (      CPU_SIZE_T)len_max)) {   /* ... or max nbr chars cmp'd        (see Note #3d2).   */
;;;893            p1_str_cmp++;
000018  1c5b              ADDS     r3,r3,#1
;;;894            p2_str_cmp++;
00001a  1c49              ADDS     r1,r1,#1
;;;895            p1_str_cmp_next++;
00001c  1c40              ADDS     r0,r0,#1
;;;896            p2_str_cmp_next++;
00001e  1c64              ADDS     r4,r4,#1
;;;897            cmp_len++;
000020  1c6d              ADDS     r5,r5,#1
                  |L12.34|
000022  781e              LDRB     r6,[r3,#0]            ;888
000024  780f              LDRB     r7,[r1,#0]            ;888
000026  42be              CMP      r6,r7                 ;888
000028  d104              BNE      |L12.52|
00002a  b11e              CBZ      r6,|L12.52|
00002c  b110              CBZ      r0,|L12.52|
00002e  b10c              CBZ      r4,|L12.52|
000030  4295              CMP      r5,r2                 ;892
000032  d3f1              BCC      |L12.24|
                  |L12.52|
;;;898        }
;;;899    
;;;900    
;;;901        if (cmp_len == len_max) {                                   /* If strs     identical for max len nbr of chars, ...  */
000034  4295              CMP      r5,r2
000036  d009              BEQ      |L12.76|
;;;902            return (0);                                             /* ... rtn 0                 (see Note #3d2A).          */
;;;903        }
;;;904    
;;;905        if (*p1_str_cmp != *p2_str_cmp) {                           /* If strs NOT identical, ...                           */
000038  b2f2              UXTB     r2,r6
00003a  b2f9              UXTB     r1,r7
00003c  428a              CMP      r2,r1
00003e  d001              BEQ      |L12.68|
;;;906                                                                    /* ... calc & rtn char diff  (see Note #3c1).           */
;;;907             cmp_val = (CPU_INT16S)(*p1_str_cmp) - (CPU_INT16S)(*p2_str_cmp);
000040  1a70              SUBS     r0,r6,r1
;;;908    
;;;909        } else if (*p1_str_cmp  == (CPU_CHAR)'\0') {                /* If NULL char(s) found, ...                           */
;;;910             cmp_val = (CPU_INT16S)0;                               /* ... strs identical; rtn 0 (see Note #3b).            */
;;;911    
;;;912        } else {
;;;913            if (p1_str_cmp_next == (const CPU_CHAR *)0) {
;;;914                if (p2_str_cmp_next == (const CPU_CHAR *)0) {       /* If BOTH next str ptrs NULL, ...                      */
;;;915                    cmp_val = (CPU_INT16S)0;                        /* ... rtn 0                       (see Note #3a2A).    */
;;;916                } else {                                            /* If p1_str_cmp_next NULL, ...                         */
;;;917                                                                    /* ... rtn neg p2_str_cmp_next val (see Note #3a2B1).   */
;;;918                    cmp_val = (CPU_INT16S)0 - (CPU_INT16S)(*p2_str_cmp_next);
;;;919                }
;;;920            } else {                                                /* If p2_str_cmp_next NULL, ...                         */
;;;921                cmp_val = (CPU_INT16S)(*p1_str_cmp_next);           /* ... rtn pos p1_str_cmp_next val (see Note #3a2B2).   */
;;;922            }
;;;923        }
;;;924    
;;;925    
;;;926        return (cmp_val);
;;;927    }
000042  bdf0              POP      {r4-r7,pc}
                  |L12.68|
000044  b116              CBZ      r6,|L12.76|
000046  b118              CBZ      r0,|L12.80|
                  |L12.72|
000048  7800              LDRB     r0,[r0,#0]            ;921
00004a  bdf0              POP      {r4-r7,pc}
                  |L12.76|
00004c  2000              MOVS     r0,#0                 ;910
00004e  bdf0              POP      {r4-r7,pc}
                  |L12.80|
000050  2c00              CMP      r4,#0                 ;914
000052  d0fb              BEQ      |L12.76|
000054  7820              LDRB     r0,[r4,#0]            ;918
                  |L12.86|
000056  4240              RSBS     r0,r0,#0              ;918
000058  bdf0              POP      {r4-r7,pc}
;;;928    
                          ENDP


                          AREA ||i.Str_Copy||, CODE, READONLY, ALIGN=1

                  Str_Copy PROC
;;;346    
;;;347    CPU_CHAR  *Str_Copy (       CPU_CHAR  *pstr_dest,
000000  f04f32ff          MOV      r2,#0xffffffff
;;;348                         const  CPU_CHAR  *pstr_src)
;;;349    {
;;;350        CPU_CHAR  *pstr_rtn;
;;;351    
;;;352    
;;;353        pstr_rtn = Str_Copy_N(pstr_dest,
000004  f7ffbffe          B.W      Str_Copy_N
;;;354                              pstr_src,
;;;355                              DEF_INT_CPU_U_MAX_VAL);
;;;356    
;;;357        return (pstr_rtn);
;;;358    }
;;;359    
                          ENDP


                          AREA ||i.Str_Copy_N||, CODE, READONLY, ALIGN=2

                  Str_Copy_N PROC
;;;436    
;;;437    CPU_CHAR  *Str_Copy_N (       CPU_CHAR    *pstr_dest,
000000  b530              PUSH     {r4,r5,lr}
;;;438                           const  CPU_CHAR    *pstr_src,
;;;439                                  CPU_SIZE_T   len_max)
;;;440    {
000002  2800              CMP      r0,#0
000004  d012              BEQ      |L14.44|
;;;441               CPU_CHAR    *pstr_copy_dest;
;;;442        const  CPU_CHAR    *pstr_copy_src;
;;;443               CPU_SIZE_T   len_copy;
;;;444    
;;;445                                                                    /* Rtn NULL if str ptr(s) NULL (see Note #3a1).         */
;;;446        if (pstr_dest == (CPU_CHAR *)0) {
;;;447            return ((CPU_CHAR *)0);
;;;448        }
;;;449        if (pstr_src  == (const CPU_CHAR *)0) {
000006  b191              CBZ      r1,|L14.46|
;;;450            return ((CPU_CHAR *)0);
;;;451        }
;;;452    
;;;453    
;;;454        pstr_copy_dest = pstr_dest;
000008  4603              MOV      r3,r0
;;;455        pstr_copy_src  = pstr_src;
;;;456        len_copy       = 0u;
00000a  2400              MOVS     r4,#0
;;;457    
;;;458        while (( pstr_copy_dest != (      CPU_CHAR *)  0 ) &&       /* Copy str until NULL ptr(s)  [see Note #3b]  ...      */
00000c  e006              B        |L14.28|
;;;459               ( pstr_copy_src  != (const CPU_CHAR *)  0 ) &&
;;;460               (*pstr_copy_src  != (      CPU_CHAR  )'\0') &&       /* ... or NULL char found      (see Note #3c); ...      */
;;;461               ( len_copy       <  (      CPU_SIZE_T)len_max)) {    /* ... or max nbr chars copied (see Note #3d).          */
;;;462           *pstr_copy_dest = *pstr_copy_src;
00000e  bf00              NOP      
                  |L14.16|
;;;463            pstr_copy_dest++;
;;;464            pstr_copy_src++;
000010  1c49              ADDS     r1,r1,#1
000012  f8035b01          STRB     r5,[r3],#1            ;462
;;;465            len_copy++;
000016  1c64              ADDS     r4,r4,#1
000018  b14b              CBZ      r3,|L14.46|
00001a  b141              CBZ      r1,|L14.46|
                  |L14.28|
00001c  780d              LDRB     r5,[r1,#0]            ;460
00001e  b10d              CBZ      r5,|L14.36|
000020  4294              CMP      r4,r2                 ;461
000022  d3f5              BCC      |L14.16|
                  |L14.36|
;;;466        }
;;;467                                                                    /* Rtn NULL if NULL ptr(s) found  (see Note #3b1).      */
;;;468        if ((pstr_copy_dest == (      CPU_CHAR *)0) ||
;;;469            (pstr_copy_src  == (const CPU_CHAR *)0)) {
;;;470             return ((CPU_CHAR *)0);
;;;471        }
;;;472    
;;;473        if (len_copy < len_max) {                                   /* If  copy str len < max buf len (see Note #2a2A), ... */
000024  4294              CMP      r4,r2
000026  d201              BCS      |L14.44|
;;;474           *pstr_copy_dest = (CPU_CHAR)'\0';                        /* ... copy NULL char  (see Note #3c1).                 */
000028  2100              MOVS     r1,#0
00002a  7019              STRB     r1,[r3,#0]
                  |L14.44|
;;;475        }
;;;476    
;;;477    
;;;478        return (pstr_dest);                                         /* Rtn ptr to dest str (see Note #2b1).                 */
;;;479    }
00002c  bd30              POP      {r4,r5,pc}
                  |L14.46|
00002e  2000              MOVS     r0,#0                 ;470
000030  bd30              POP      {r4,r5,pc}
;;;480    
                          ENDP


                          AREA ||i.Str_FmtNbr_Int32||, CODE, READONLY, ALIGN=1

                  Str_FmtNbr_Int32 PROC
;;;3442   
;;;3443   static  CPU_CHAR  *Str_FmtNbr_Int32 (CPU_INT32U    nbr,
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;3444                                        CPU_INT08U    nbr_dig,
;;;3445                                        CPU_INT08U    nbr_base,
;;;3446                                        CPU_BOOLEAN   nbr_neg,
;;;3447                                        CPU_CHAR      lead_char,
;;;3448                                        CPU_BOOLEAN   lower_case,
;;;3449                                        CPU_BOOLEAN   nul,
;;;3450                                        CPU_CHAR     *pstr)
;;;3451   {
000004  4682              MOV      r10,r0
;;;3452       CPU_CHAR     *pstr_fmt;
;;;3453       CPU_DATA      i;
;;;3454       CPU_INT32U    nbr_fmt;
;;;3455       CPU_INT32U    nbr_log;
;;;3456       CPU_INT08U    nbr_dig_max;
;;;3457       CPU_INT08U    nbr_dig_min;
;;;3458       CPU_INT08U    nbr_dig_fmtd;
;;;3459       CPU_INT08U    nbr_neg_sign;
;;;3460       CPU_INT08U    nbr_lead_char;
;;;3461       CPU_INT08U    dig_val;
;;;3462       CPU_INT08U    lead_char_delta_0;
;;;3463       CPU_INT08U    lead_char_delta_a;
;;;3464       CPU_BOOLEAN   lead_char_dig;
;;;3465       CPU_BOOLEAN   lead_char_0;
;;;3466       CPU_BOOLEAN   fmt_invalid;
;;;3467       CPU_BOOLEAN   print_char;
;;;3468       CPU_BOOLEAN   nbr_neg_fmtd;
;;;3469   
;;;3470   
;;;3471                                                                   /* ---------------- VALIDATE FMT ARGS ----------------- */
;;;3472       if (pstr == (CPU_CHAR *)0) {                                /* Rtn NULL if str ptr NULL (see Note #6a).             */
000006  f8dd9044          LDR      r9,[sp,#0x44]
00000a  9c0e              LDR      r4,[sp,#0x38]
00000c  460d              MOV      r5,r1                 ;3451
00000e  4617              MOV      r7,r2                 ;3451
000010  ea5f0009          MOVS     r0,r9
000014  d075              BEQ      |L15.258|
;;;3473           return ((CPU_CHAR *)0);
;;;3474       }
;;;3475   
;;;3476       fmt_invalid = DEF_NO;
000016  2600              MOVS     r6,#0
;;;3477       lead_char_0 = DEF_NO;
000018  46b0              MOV      r8,r6
;;;3478   
;;;3479       if (nbr_dig < 1) {                                          /* If nbr digs = 0, ...                                 */
00001a  b905              CBNZ     r5,|L15.30|
;;;3480           fmt_invalid = DEF_YES;                                  /* ... fmt invalid str (see Note #6b).                  */
00001c  2601              MOVS     r6,#1
                  |L15.30|
;;;3481       }
;;;3482                                                                   /* If invalid base, ...                                 */
;;;3483       if ((nbr_base <  2u) ||
00001e  1eb8              SUBS     r0,r7,#2
000020  2823              CMP      r0,#0x23
000022  d300              BCC      |L15.38|
;;;3484           (nbr_base > 36u)) {
;;;3485           fmt_invalid = DEF_YES;                                  /* ... fmt invalid str (see Note #6d).                  */
000024  2601              MOVS     r6,#1
                  |L15.38|
;;;3486       }
;;;3487   
;;;3488       if (lead_char != (CPU_CHAR)'\0') {
000026  b1fc              CBZ      r4,|L15.104|
;;;3489           print_char =  ASCII_IsPrint(lead_char);
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       ASCII_IsPrint
;;;3490           if (print_char != DEF_YES) {                            /* If lead char non-printable (see Note #3a1), ...      */
00002e  2801              CMP      r0,#1
000030  d001              BEQ      |L15.54|
                  |L15.50|
;;;3491               fmt_invalid = DEF_YES;                              /* ... fmt invalid str        (see Note #6e).           */
000032  2601              MOVS     r6,#1
000034  e044              B        |L15.192|
                  |L15.54|
;;;3492   
;;;3493           } else if (lead_char != '0') {                          /* Chk lead char for non-0 nbr base dig.                */
000036  2c30              CMP      r4,#0x30
000038  d018              BEQ      |L15.108|
;;;3494               lead_char_delta_0 = (CPU_INT08U)(lead_char - '0');
;;;3495               if (lower_case != DEF_YES) {
00003a  990f              LDR      r1,[sp,#0x3c]
00003c  f1a40030          SUB      r0,r4,#0x30           ;3494
000040  b2c0              UXTB     r0,r0                 ;3494
000042  2901              CMP      r1,#1
000044  d002              BEQ      |L15.76|
;;;3496                   lead_char_delta_a = (CPU_INT08U)(lead_char - 'A');
000046  f1a40141          SUB      r1,r4,#0x41
00004a  e001              B        |L15.80|
                  |L15.76|
;;;3497               } else {
;;;3498                   lead_char_delta_a = (CPU_INT08U)(lead_char - 'a');
00004c  f1a40161          SUB      r1,r4,#0x61
                  |L15.80|
000050  b2c9              UXTB     r1,r1
;;;3499               }
;;;3500   
;;;3501               lead_char_dig = (((nbr_base <= 10u) &&  (lead_char_delta_0 <  nbr_base))      ||
000052  2f0a              CMP      r7,#0xa
000054  d802              BHI      |L15.92|
000056  42b8              CMP      r0,r7
000058  d307              BCC      |L15.106|
00005a  e007              B        |L15.108|
                  |L15.92|
;;;3502                                ((nbr_base >  10u) && ((lead_char_delta_0 <             10u) ||
00005c  280a              CMP      r0,#0xa
00005e  d304              BCC      |L15.106|
;;;3503                                                       (lead_char_delta_a < (nbr_base - 10u))))) ? DEF_YES : DEF_NO;
000060  f1a7000a          SUB      r0,r7,#0xa
000064  4281              CMP      r1,r0
000066  d3e4              BCC      |L15.50|
                  |L15.104|
000068  e000              B        |L15.108|
                  |L15.106|
;;;3504   
;;;3505               if (lead_char_dig == DEF_YES) {                     /* If lead char non-0 nbr base dig (see Note #3a2A), ...*/
;;;3506                   fmt_invalid = DEF_YES;                          /* ... fmt invalid str             (see Note #6e).      */
00006a  2601              MOVS     r6,#1
                  |L15.108|
;;;3507               }
;;;3508           }
;;;3509       }
;;;3510   
;;;3511   
;;;3512                                                                   /* ----------------- PREPARE NBR FMT ------------------ */
;;;3513       pstr_fmt = pstr;
00006c  464b              MOV      r3,r9
;;;3514   
;;;3515       if (fmt_invalid == DEF_NO) {
00006e  bb3e              CBNZ     r6,|L15.192|
;;;3516           nbr_fmt     = nbr;
000070  4651              MOV      r1,r10
;;;3517           nbr_log     = nbr;
;;;3518           nbr_dig_max = 1u;
000072  2001              MOVS     r0,#1
;;;3519           while (nbr_log >= nbr_base) {                           /* While nbr base digs avail, ...                       */
000074  e003              B        |L15.126|
                  |L15.118|
;;;3520               nbr_dig_max++;                                      /* ... calc max nbr digs.                               */
;;;3521               nbr_log /= nbr_base;
000076  fbb1f1f7          UDIV     r1,r1,r7
00007a  1c40              ADDS     r0,r0,#1              ;3520
00007c  b2c0              UXTB     r0,r0                 ;3520
                  |L15.126|
00007e  42b9              CMP      r1,r7                 ;3519
000080  d2f9              BCS      |L15.118|
;;;3522           }
;;;3523   
;;;3524           nbr_neg_sign = (nbr_neg == DEF_YES) ? 1u : 0u;
000082  9903              LDR      r1,[sp,#0xc]
000084  2901              CMP      r1,#1
000086  d014              BEQ      |L15.178|
000088  2200              MOVS     r2,#0
                  |L15.138|
;;;3525           if (nbr_dig >= (nbr_dig_max + nbr_neg_sign)) {          /* If req'd nbr digs >= (max nbr digs + neg sign), ...  */
00008a  1881              ADDS     r1,r0,r2
00008c  42a9              CMP      r1,r5
00008e  d8d0              BHI      |L15.50|
;;;3526               nbr_neg_fmtd = DEF_NO;
000090  f04f0b00          MOV      r11,#0
;;;3527               nbr_dig_min  = DEF_MIN(nbr_dig_max, nbr_dig);
000094  42a8              CMP      r0,r5
000096  d300              BCC      |L15.154|
000098  4628              MOV      r0,r5
                  |L15.154|
;;;3528                                                                   /* ... calc nbr digs to fmt & nbr lead chars.           */
;;;3529               if (lead_char != (CPU_CHAR)'\0') {
00009a  b164              CBZ      r4,|L15.182|
;;;3530                   nbr_dig_fmtd  = nbr_dig;
;;;3531                   nbr_lead_char = nbr_dig     -
00009c  1a28              SUBS     r0,r5,r0
00009e  1a80              SUBS     r0,r0,r2
0000a0  4629              MOV      r1,r5
0000a2  f0100fff          TST      r0,#0xff
0000a6  d001              BEQ      |L15.172|
;;;3532                                   nbr_dig_min - nbr_neg_sign;
;;;3533               } else {
;;;3534                   nbr_dig_fmtd  = nbr_dig_min + nbr_neg_sign;
;;;3535                   nbr_lead_char = 0u;
;;;3536               }
;;;3537   
;;;3538               if (nbr_lead_char > 0) {                            /* If lead chars to fmt, ...                            */
;;;3539                   lead_char_0 = (lead_char == '0')                /* ... chk if lead char a '0' dig (see Note #3a2B).     */
0000a8  2c30              CMP      r4,#0x30
0000aa  d013              BEQ      |L15.212|
                  |L15.172|
;;;3540                               ?  DEF_YES : DEF_NO;
;;;3541               } else {
;;;3542                   lead_char_0 =  DEF_NO;
0000ac  2000              MOVS     r0,#0
                  |L15.174|
0000ae  4680              MOV      r8,r0
0000b0  e007              B        |L15.194|
                  |L15.178|
0000b2  2201              MOVS     r2,#1                 ;3524
0000b4  e7e9              B        |L15.138|
                  |L15.182|
0000b6  4410              ADD      r0,r0,r2              ;3534
0000b8  b2c1              UXTB     r1,r0                 ;3534
0000ba  f04f0800          MOV      r8,#0
0000be  b106              CBZ      r6,|L15.194|
                  |L15.192|
;;;3543               }
;;;3544   
;;;3545           } else {                                                /* Else if nbr trunc'd, ...                             */
;;;3546               fmt_invalid = DEF_YES;                              /* ... fmt invalid str (see Note #6c).                  */
;;;3547           }
;;;3548       }
;;;3549   
;;;3550       if (fmt_invalid != DEF_NO) {
;;;3551           nbr_dig_fmtd = nbr_dig;
0000c0  4629              MOV      r1,r5
                  |L15.194|
;;;3552       }
;;;3553   
;;;3554   
;;;3555                                                                   /* ------------------- FMT NBR STR -------------------- */
;;;3556       pstr_fmt += nbr_dig_fmtd;                                   /* Start fmt @ least-sig dig.                           */
;;;3557   
;;;3558       if (nul != DEF_NO) {                                        /* If NOT DISABLED, append NULL char (see Note #4).     */
0000c2  9a10              LDR      r2,[sp,#0x40]
0000c4  eb090001          ADD      r0,r9,r1              ;3556
0000c8  b10a              CBZ      r2,|L15.206|
;;;3559          *pstr_fmt = (CPU_CHAR)'\0';
0000ca  2200              MOVS     r2,#0
0000cc  7002              STRB     r2,[r0,#0]
                  |L15.206|
;;;3560       }
;;;3561       pstr_fmt--;
0000ce  1e40              SUBS     r0,r0,#1
;;;3562   
;;;3563   
;;;3564       for (i = 0u; i < nbr_dig_fmtd; i++) {                       /* Fmt str for desired nbr digs :                       */
0000d0  2300              MOVS     r3,#0
0000d2  e036              B        |L15.322|
                  |L15.212|
0000d4  2001              MOVS     r0,#1                 ;3540
0000d6  e7ea              B        |L15.174|
                  |L15.216|
;;;3565           if (fmt_invalid == DEF_NO) {
0000d8  b116              CBZ      r6,|L15.224|
;;;3566               if ((nbr_fmt > 0) ||                                /* If fmt nbr > 0                               ...     */
;;;3567                   (i == 0u)) {                                    /* ... OR on one's  dig to fmt (see Note #3c1), ...     */
;;;3568                                                                   /* ... calc & fmt dig val;                      ...     */
;;;3569                   dig_val = (CPU_INT08U)(nbr_fmt % nbr_base);
;;;3570                   if (dig_val < 10u) {
;;;3571                      *pstr_fmt-- = (CPU_CHAR)(dig_val + '0');
;;;3572                   } else {
;;;3573                       if (lower_case !=  DEF_YES) {
;;;3574                          *pstr_fmt--  = (CPU_CHAR)((dig_val - 10u) + 'A');
;;;3575                       } else {
;;;3576                          *pstr_fmt--  = (CPU_CHAR)((dig_val - 10u) + 'a');
;;;3577                       }
;;;3578                   }
;;;3579   
;;;3580                   nbr_fmt /= nbr_base;                            /* Shift to next more-sig dig.                          */
;;;3581   
;;;3582               } else if ((nbr_neg      == DEF_YES)  &&            /* ... else if nbr neg             AND          ...     */
;;;3583                        (((lead_char_0  == DEF_NO )  &&            /* ... lead char NOT a '0' dig                  ...     */
;;;3584                          (nbr_neg_fmtd == DEF_NO )) ||            /* ... but neg sign NOT yet fmt'd  OR           ...     */
;;;3585                         ((lead_char_0  != DEF_NO )  &&            /* ... lead char is  a '0' dig                  ...     */
;;;3586                          (i == (nbr_dig_fmtd - 1u))))) {          /* ... & on most-sig dig to fmt,                ...     */
;;;3587   
;;;3588                  *pstr_fmt--   = '-';                             /* ... prepend neg sign (see Note #3b);         ...     */
;;;3589                   nbr_neg_fmtd = DEF_YES;
;;;3590   
;;;3591               } else if (lead_char != (CPU_CHAR)'\0') {           /* ... else if avail,                           ...     */
;;;3592                  *pstr_fmt-- = lead_char;                         /* ... fmt lead char.                                   */
;;;3593               }
;;;3594   
;;;3595           } else {                                                /* Else fmt '?' for invalid str (see Note #7).          */
;;;3596              *pstr_fmt-- = '?';
0000da  223f              MOVS     r2,#0x3f
0000dc  7002              STRB     r2,[r0,#0]
0000de  e02e              B        |L15.318|
                  |L15.224|
0000e0  ea5f020a          MOVS     r2,r10                ;3566
0000e4  d104              BNE      |L15.240|
0000e6  b11b              CBZ      r3,|L15.240|
0000e8  9a03              LDR      r2,[sp,#0xc]          ;3582
0000ea  2a01              CMP      r2,#1                 ;3582
0000ec  d016              BEQ      |L15.284|
0000ee  e024              B        |L15.314|
                  |L15.240|
0000f0  fbb2f5f7          UDIV     r5,r2,r7              ;3569
0000f4  fb07a215          MLS      r2,r7,r5,r10          ;3569
0000f8  b2d2              UXTB     r2,r2                 ;3569
0000fa  2a0a              CMP      r2,#0xa               ;3570
0000fc  d202              BCS      |L15.260|
0000fe  3230              ADDS     r2,r2,#0x30           ;3571
000100  e008              B        |L15.276|
                  |L15.258|
000102  e022              B        |L15.330|
                  |L15.260|
000104  f8ddc03c          LDR      r12,[sp,#0x3c]        ;3573
000108  f1bc0f01          CMP      r12,#1                ;3573
00010c  d001              BEQ      |L15.274|
00010e  3237              ADDS     r2,r2,#0x37           ;3574
000110  e000              B        |L15.276|
                  |L15.274|
000112  3257              ADDS     r2,r2,#0x57           ;3576
                  |L15.276|
000114  f8002901          STRB     r2,[r0],#-1           ;3574
000118  46aa              MOV      r10,r5                ;3580
00011a  e011              B        |L15.320|
                  |L15.284|
00011c  ea58020b          ORRS     r2,r8,r11             ;3583
000120  d005              BEQ      |L15.302|
000122  f1b80f00          CMP      r8,#0                 ;3585
000126  d008              BEQ      |L15.314|
000128  1e4a              SUBS     r2,r1,#1              ;3586
00012a  4293              CMP      r3,r2                 ;3586
00012c  d105              BNE      |L15.314|
                  |L15.302|
00012e  222d              MOVS     r2,#0x2d              ;3588
000130  f8002901          STRB     r2,[r0],#-1           ;3588
000134  f04f0b01          MOV      r11,#1                ;3589
000138  e002              B        |L15.320|
                  |L15.314|
00013a  b10c              CBZ      r4,|L15.320|
00013c  7004              STRB     r4,[r0,#0]            ;3592
                  |L15.318|
00013e  1e40              SUBS     r0,r0,#1              ;3592
                  |L15.320|
000140  1c5b              ADDS     r3,r3,#1              ;3564
                  |L15.322|
000142  428b              CMP      r3,r1                 ;3564
000144  d3c8              BCC      |L15.216|
;;;3597           }
;;;3598       }
;;;3599   
;;;3600   
;;;3601       if (fmt_invalid != DEF_NO) {                                /* Rtn NULL for invalid str fmt (see Notes #6a - #6e).  */
000146  b11e              CBZ      r6,|L15.336|
;;;3602           return ((CPU_CHAR *)0);
000148  2000              MOVS     r0,#0
                  |L15.330|
;;;3603       }
;;;3604   
;;;3605   
;;;3606       return (pstr);                                              /* Rtn ptr to fmt'd str (see Note #6f).                 */
;;;3607   }
00014a  b004              ADD      sp,sp,#0x10
00014c  e8bd9ff0          POP      {r4-r12,pc}
                  |L15.336|
000150  4648              MOV      r0,r9                 ;3606
000152  e7fa              B        |L15.330|
;;;3608   
                          ENDP


                          AREA ||i.Str_FmtNbr_Int32S||, CODE, READONLY, ALIGN=1

                  Str_FmtNbr_Int32S PROC
;;;2253   
;;;2254   CPU_CHAR  *Str_FmtNbr_Int32S (CPU_INT32S    nbr,
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;2255                                 CPU_INT08U    nbr_dig,
;;;2256                                 CPU_INT08U    nbr_base,
;;;2257                                 CPU_CHAR      lead_char,
;;;2258                                 CPU_BOOLEAN   lower_case,
;;;2259                                 CPU_BOOLEAN   nul,
;;;2260                                 CPU_CHAR     *pstr)
;;;2261   {
000004  461c              MOV      r4,r3
000006  e9dd650a          LDRD     r6,r5,[sp,#0x28]
;;;2262       CPU_CHAR     *pstr_fmt;
;;;2263       CPU_INT32S    nbr_fmt;
;;;2264       CPU_BOOLEAN   nbr_neg;
;;;2265   
;;;2266   
;;;2267       if (nbr < 0) {                                              /* If nbr neg, ...                                      */
00000a  9f0c              LDR      r7,[sp,#0x30]
00000c  2800              CMP      r0,#0
00000e  da02              BGE      |L16.22|
;;;2268           nbr_fmt = -nbr;                                         /* ... negate nbr.                                      */
000010  4240              RSBS     r0,r0,#0
;;;2269           nbr_neg =  DEF_YES;
000012  2301              MOVS     r3,#1
000014  e000              B        |L16.24|
                  |L16.22|
;;;2270       } else {
;;;2271           nbr_fmt =  nbr;
;;;2272           nbr_neg =  DEF_NO;
000016  2300              MOVS     r3,#0
                  |L16.24|
000018  e9cd4600          STRD     r4,r6,[sp,#0]
00001c  e9cd5702          STRD     r5,r7,[sp,#8]
;;;2273       }
;;;2274   
;;;2275       pstr_fmt = Str_FmtNbr_Int32((CPU_INT32U)nbr_fmt,            /* Fmt signed int into str.                             */
000020  f7fffffe          BL       Str_FmtNbr_Int32
;;;2276                                               nbr_dig,
;;;2277                                               nbr_base,
;;;2278                                               nbr_neg,
;;;2279                                               lead_char,
;;;2280                                               lower_case,
;;;2281                                               nul,
;;;2282                                               pstr);
;;;2283   
;;;2284       return (pstr_fmt);
;;;2285   }
000024  b004              ADD      sp,sp,#0x10
000026  e8bd81f0          POP      {r4-r8,pc}
;;;2286   
                          ENDP


                          AREA ||i.Str_FmtNbr_Int32U||, CODE, READONLY, ALIGN=1

                  Str_FmtNbr_Int32U PROC
;;;2037   
;;;2038   CPU_CHAR  *Str_FmtNbr_Int32U (CPU_INT32U    nbr,
000000  b57f              PUSH     {r0-r6,lr}
;;;2039                                 CPU_INT08U    nbr_dig,
;;;2040                                 CPU_INT08U    nbr_base,
;;;2041                                 CPU_CHAR      lead_char,
;;;2042                                 CPU_BOOLEAN   lower_case,
;;;2043                                 CPU_BOOLEAN   nul,
;;;2044                                 CPU_CHAR     *pstr)
;;;2045   {
000002  f10d0c20          ADD      r12,sp,#0x20
000006  e8bc0070          LDM      r12!,{r4-r6}
00000a  e88d0078          STM      sp,{r3-r6}
;;;2046       CPU_CHAR  *pstr_fmt;
;;;2047   
;;;2048   
;;;2049       pstr_fmt = Str_FmtNbr_Int32(nbr,                            /* Fmt unsigned int into str.                           */
00000e  2300              MOVS     r3,#0
000010  f7fffffe          BL       Str_FmtNbr_Int32
;;;2050                                   nbr_dig,
;;;2051                                   nbr_base,
;;;2052                                   DEF_NO,
;;;2053                                   lead_char,
;;;2054                                   lower_case,
;;;2055                                   nul,
;;;2056                                   pstr);
;;;2057   
;;;2058       return (pstr_fmt);
;;;2059   }
000014  b004              ADD      sp,sp,#0x10
000016  bd70              POP      {r4-r6,pc}
;;;2060   
                          ENDP


                          AREA ||i.Str_Len||, CODE, READONLY, ALIGN=1

                  Str_Len PROC
;;;215    
;;;216    CPU_SIZE_T  Str_Len (const  CPU_CHAR  *pstr)
000000  f04f31ff          MOV      r1,#0xffffffff
;;;217    {
;;;218        CPU_SIZE_T  len;
;;;219    
;;;220    
;;;221        len = Str_Len_N(pstr,
000004  f7ffbffe          B.W      Str_Len_N
;;;222                        DEF_INT_CPU_U_MAX_VAL);
;;;223    
;;;224        return (len);
;;;225    }
;;;226    
                          ENDP


                          AREA ||i.Str_Len_N||, CODE, READONLY, ALIGN=1

                  Str_Len_N PROC
;;;274    
;;;275    CPU_SIZE_T  Str_Len_N (const  CPU_CHAR    *pstr,
000000  2200              MOVS     r2,#0
;;;276                                  CPU_SIZE_T   len_max)
;;;277    {
000002  e001              B        |L19.8|
                  |L19.4|
;;;278        const  CPU_CHAR    *pstr_len;
;;;279               CPU_SIZE_T   len;
;;;280    
;;;281    
;;;282        pstr_len = pstr;
;;;283        len      = 0u;
;;;284        while (( pstr_len != (const CPU_CHAR *)  0 ) &&             /* Calc str len until NULL ptr (see Note #3a) ...       */
;;;285               (*pstr_len != (      CPU_CHAR  )'\0') &&             /* ... or NULL char found      (see Note #3b) ...       */
;;;286               ( len      <  (      CPU_SIZE_T)len_max)) {          /* ... or max nbr chars srch'd (see Note #3c).          */
;;;287            pstr_len++;
000004  1c40              ADDS     r0,r0,#1
;;;288            len++;
000006  1c52              ADDS     r2,r2,#1
                  |L19.8|
000008  b118              CBZ      r0,|L19.18|
00000a  7803              LDRB     r3,[r0,#0]            ;285
00000c  b10b              CBZ      r3,|L19.18|
00000e  428a              CMP      r2,r1                 ;286
000010  d3f8              BCC      |L19.4|
                  |L19.18|
;;;289        }
;;;290    
;;;291        return (len);                                               /* Rtn str len (see Note #3b1).                         */
000012  4610              MOV      r0,r2
;;;292    }
000014  4770              BX       lr
;;;293    
                          ENDP


                          AREA ||i.Str_ParseNbr_Int32||, CODE, READONLY, ALIGN=2

                  Str_ParseNbr_Int32 PROC
;;;3835   
;;;3836   static  CPU_INT32U  Str_ParseNbr_Int32 (const  CPU_CHAR      *pstr,
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;3837                                                  CPU_CHAR     **pstr_next,
;;;3838                                                  CPU_INT08U     nbr_base,
;;;3839                                                  CPU_BOOLEAN    nbr_signed,
;;;3840                                                  CPU_BOOLEAN   *pnbr_neg)
;;;3841   {
000004  4615              MOV      r5,r2
000006  f8dd9038          LDR      r9,[sp,#0x38]
00000a  4698              MOV      r8,r3
00000c  000f              MOVS     r7,r1
00000e  4606              MOV      r6,r0
000010  d100              BNE      |L20.20|
;;;3842       const  CPU_CHAR     *pstr_parse;
;;;3843       const  CPU_CHAR     *pstr_parse_nbr;
;;;3844              CPU_CHAR     *pstr_parse_unused;
;;;3845              CPU_CHAR      parse_char;
;;;3846              CPU_INT08U    parse_dig;
;;;3847              CPU_INT32U    nbr;
;;;3848              CPU_BOOLEAN   nbr_neg_unused;
;;;3849              CPU_BOOLEAN   nbr_dig;
;;;3850              CPU_BOOLEAN   nbr_alpha;
;;;3851              CPU_BOOLEAN   nbr_hex;
;;;3852              CPU_BOOLEAN   nbr_hex_lower;
;;;3853              CPU_BOOLEAN   whitespace;
;;;3854              CPU_BOOLEAN   neg;
;;;3855              CPU_BOOLEAN   ovf;
;;;3856              CPU_BOOLEAN   done;
;;;3857   
;;;3858                                                                   /* --------------- VALIDATE PARSE ARGS ---------------- */
;;;3859       if (pstr_next == (CPU_CHAR **) 0) {                         /* If NOT avail, ...                                    */
;;;3860           pstr_next  = (CPU_CHAR **)&pstr_parse_unused;           /* ... re-cfg NULL rtn ptr to unused local var.         */
000012  af02              ADD      r7,sp,#8
                  |L20.20|
;;;3861          (void)&pstr_parse_unused;                                /* Prevent possible 'variable unused' warning.          */
;;;3862       }
;;;3863      *pstr_next = (CPU_CHAR *)pstr;                               /* Init rtn str for err (see Note #5).                  */
;;;3864   
;;;3865       if (pnbr_neg == (CPU_BOOLEAN *) 0) {                        /* If NOT avail, ...                                    */
000014  f1b90f00          CMP      r9,#0
000018  603e              STR      r6,[r7,#0]
00001a  d101              BNE      |L20.32|
;;;3866           pnbr_neg  = (CPU_BOOLEAN *)&nbr_neg_unused;             /* ... re-cfg NULL rtn ptr to unused local var.         */
00001c  f10d090c          ADD      r9,sp,#0xc
                  |L20.32|
;;;3867          (void)&nbr_neg_unused;                                   /* Prevent possible 'variable unused' warning.          */
;;;3868       }
;;;3869      *pnbr_neg = DEF_NO;                                          /* Init nbr neg for err (see Note #5).                  */
000020  2100              MOVS     r1,#0
000022  f8891000          STRB     r1,[r9,#0]
;;;3870   
;;;3871   
;;;3872       if (pstr == (CPU_CHAR *)0) {                                /* Rtn zero if str ptr NULL (see Note #4b1).            */
000026  b11e              CBZ      r6,|L20.48|
;;;3873           return (0u);
;;;3874       }
;;;3875                                                                   /* Rtn zero if invalid base (see Note #4a).             */
;;;3876       if ((nbr_base == 1u) ||
000028  2d01              CMP      r5,#1
00002a  d001              BEQ      |L20.48|
;;;3877           (nbr_base > 36u)) {
00002c  2d24              CMP      r5,#0x24
00002e  d903              BLS      |L20.56|
                  |L20.48|
;;;3878           return (0u);
000030  2000              MOVS     r0,#0
                  |L20.50|
;;;3879       }
;;;3880   
;;;3881   
;;;3882                                                                   /* ------------- IGNORE PRECEDING CHAR(S) ------------- */
;;;3883       pstr_parse = pstr;                                          /* Save ptr to init'l str for err (see Note #2a2A2).    */
;;;3884   
;;;3885       whitespace = ASCII_IsSpace(*pstr_parse);
;;;3886       while (whitespace == DEF_YES) {                             /* Ignore initial white-space char(s) [see Note #2a1A]. */
;;;3887           pstr_parse++;
;;;3888           whitespace = ASCII_IsSpace(*pstr_parse);
;;;3889       }
;;;3890   
;;;3891       switch (*pstr_parse) {
;;;3892           case '+':                                               /* Ignore   pos sign (see Note #2a1B2).                 */
;;;3893                pstr_parse++;
;;;3894                neg = DEF_NO;
;;;3895                break;
;;;3896   
;;;3897   
;;;3898           case '-':                                               /* Validate neg sign (see Note #2a1B2a).                */
;;;3899                if (nbr_signed == DEF_YES) {
;;;3900                    pstr_parse++;
;;;3901                }
;;;3902                neg = DEF_YES;
;;;3903                break;
;;;3904   
;;;3905   
;;;3906           default:
;;;3907                neg = DEF_NO;
;;;3908                break;
;;;3909       }
;;;3910   
;;;3911   
;;;3912                                                                   /* --------- IGNORE NBR BASE PRECEDING CHAR(S) -------- */
;;;3913       pstr_parse_nbr = pstr_parse;                                /* Save ptr to str's nbr (see Note #2a1A1).             */
;;;3914   
;;;3915       switch (nbr_base) {
;;;3916           case  0u:                                               /* Determine unspecified nbr base (see Notes #2a1B1a).  */
;;;3917                if (*pstr_parse == '0') {                          /* If avail, ...                                        */
;;;3918                     pstr_parse++;                                 /* ... adv past '0'  prefix (see Note #2a1B1b2).        */
;;;3919                     switch (*pstr_parse) {
;;;3920                         case 'x':                                 /* For '0x' prefix, ...                                 */
;;;3921                         case 'X':
;;;3922                              nbr_base   = 16u;                    /* ... set nbr base = 16    (see Note #2a1B1a3).        */
;;;3923                              parse_char = (CPU_CHAR)(*(pstr_parse + 1));
;;;3924                              nbr_hex    =  ASCII_IsDigHex(parse_char);
;;;3925                              if (nbr_hex == DEF_YES) {            /* If next char is valid hex dig, ...                   */
;;;3926                                  pstr_parse++;                    /* ... adv past '0x' prefix (see Note #2a1B1b2A).       */
;;;3927                              }
;;;3928                              break;
;;;3929   
;;;3930   
;;;3931                         default:                                  /* For '0'  prefix, ...                                 */
;;;3932                              nbr_base =  8u;                      /* ... set nbr base =  8    (see Note #2a1B1a2).        */
;;;3933                              break;
;;;3934                     }
;;;3935   
;;;3936                } else {                                           /* For non-'0' prefix, ...                              */
;;;3937                    nbr_base = 10u;                                /* ... set nbr base = 10    (see Note #2a1B1a1).        */
;;;3938                }
;;;3939                break;
;;;3940   
;;;3941   
;;;3942           case  8u:                                               /* See Note #2a1B1a2.                                   */
;;;3943                if (*pstr_parse == '0') {                          /* If avail, ...                                        */
;;;3944                     pstr_parse++;                                 /* ... adv past '0'  prefix (see Note #2a1B1b2B).       */
;;;3945                }
;;;3946                break;
;;;3947   
;;;3948   
;;;3949           case 16u:                                               /* See Note #2a1B1a3.                                   */
;;;3950                if (*pstr_parse == '0') {                          /* If avail, ...                                        */
;;;3951                     pstr_parse++;                                 /* ... adv past '0'  prefix (see Note #2a1B1b2).        */
;;;3952                     switch (*pstr_parse) {
;;;3953                         case 'x':
;;;3954                         case 'X':
;;;3955                              parse_char = (CPU_CHAR)(*(pstr_parse + 1));
;;;3956                              nbr_hex    =  ASCII_IsDigHex(parse_char);
;;;3957                              if (nbr_hex == DEF_YES) {            /* If next char is valid hex dig, ...                   */
;;;3958                                  pstr_parse++;                    /* ... adv past '0x' prefix (see Note #2a1B1b2A).       */
;;;3959                              }
;;;3960                              break;
;;;3961   
;;;3962   
;;;3963                         default:
;;;3964                              break;
;;;3965                     }
;;;3966                }
;;;3967                break;
;;;3968   
;;;3969   
;;;3970           default:                                                /* See Note #2a1B1b.                                    */
;;;3971                break;
;;;3972       }
;;;3973   
;;;3974   
;;;3975                                                                   /* ------------------ PARSE INT STR ------------------- */
;;;3976       nbr  = 0u;
;;;3977       ovf  = DEF_NO;
;;;3978       done = DEF_NO;
;;;3979   
;;;3980       while (done == DEF_NO) {                                    /* Parse str for desired nbr base digs (see Note #2a2). */
;;;3981           parse_char = (CPU_CHAR)*pstr_parse;
;;;3982           nbr_alpha  =  ASCII_IsAlphaNum(parse_char);
;;;3983           if (nbr_alpha == DEF_YES) {                             /* If valid alpha num nbr dig avail, ...                */
;;;3984                                                                   /* ... convert parse char into nbr dig.                 */
;;;3985               nbr_dig = ASCII_IsDig(parse_char);
;;;3986               if (nbr_dig == DEF_YES) {
;;;3987                   parse_dig = (CPU_INT08U)(parse_char - '0');
;;;3988               } else {
;;;3989                   nbr_hex_lower = ASCII_IsLower(parse_char);
;;;3990                   if (nbr_hex_lower == DEF_YES) {
;;;3991                       parse_dig = (CPU_INT08U)((parse_char - 'a') + 10u);
;;;3992                   } else {
;;;3993                       parse_dig = (CPU_INT08U)((parse_char - 'A') + 10u);
;;;3994                   }
;;;3995               }
;;;3996   
;;;3997               if (parse_dig < nbr_base) {                         /* If parse char valid for nbr base ...                 */
;;;3998                   if (ovf == DEF_NO) {                            /* ... & nbr NOT yet ovf'd,         ...                 */
;;;3999                       if (nbr <= Str_MultOvfThTbl_Int32U[nbr_base]) {
;;;4000                                                                   /* ... merge parse char dig into nbr.                   */
;;;4001                           nbr *= nbr_base;
;;;4002                           nbr += parse_dig;
;;;4003                           if (nbr < parse_dig) {
;;;4004                               ovf = DEF_YES;
;;;4005                           }
;;;4006                       } else {
;;;4007                           ovf = DEF_YES;
;;;4008                       }
;;;4009                   }
;;;4010                   pstr_parse++;
;;;4011   
;;;4012               } else {                                            /* Invalid         char parsed (see Note #2a1C1a).      */
;;;4013                   done = DEF_YES;
;;;4014               }
;;;4015   
;;;4016           } else {                                                /* Invalid OR NULL char parsed (see Note #2a1C1).       */
;;;4017               done = DEF_YES;
;;;4018           }
;;;4019       }
;;;4020   
;;;4021       if (ovf == DEF_YES) {                                       /* If nbr ovf'd, ...                                    */
;;;4022           nbr  = DEF_INT_32U_MAX_VAL;                             /* ... rtn max int val (see Note #2a3A1).               */
;;;4023       }
;;;4024   
;;;4025   
;;;4026       if (pstr_parse !=             pstr_parse_nbr) {             /* If final parse str != init'l parse nbr str,       .. */
;;;4027          *pstr_next   = (CPU_CHAR *)pstr_parse;                   /* .. rtn   parse str's next char (see Note #2a2B2); .. */
;;;4028       } else {
;;;4029          *pstr_next   = (CPU_CHAR *)pstr;                         /* .. else rtn initial parse str  (see Note #2a2A2).    */
;;;4030       }
;;;4031   
;;;4032      *pnbr_neg = neg;                                             /* Rtn neg nbr status.                                  */
;;;4033   
;;;4034   
;;;4035       return (nbr);
;;;4036   }
000032  b004              ADD      sp,sp,#0x10
000034  e8bd9ff0          POP      {r4-r12,pc}
                  |L20.56|
000038  4634              MOV      r4,r6                 ;3883
00003a  e000              B        |L20.62|
                  |L20.60|
00003c  1c64              ADDS     r4,r4,#1              ;3887
                  |L20.62|
00003e  7820              LDRB     r0,[r4,#0]            ;3885
000040  f7fffffe          BL       ASCII_IsSpace
000044  2801              CMP      r0,#1                 ;3886
000046  d0f9              BEQ      |L20.60|
000048  7820              LDRB     r0,[r4,#0]            ;3891
00004a  282b              CMP      r0,#0x2b              ;3891
00004c  d002              BEQ      |L20.84|
00004e  282d              CMP      r0,#0x2d              ;3891
000050  d101              BNE      |L20.86|
000052  e002              B        |L20.90|
                  |L20.84|
000054  1c64              ADDS     r4,r4,#1              ;3893
                  |L20.86|
000056  2000              MOVS     r0,#0                 ;3907
000058  e004              B        |L20.100|
                  |L20.90|
00005a  f1b80f01          CMP      r8,#1                 ;3899
00005e  d100              BNE      |L20.98|
000060  1c64              ADDS     r4,r4,#1              ;3900
                  |L20.98|
000062  2001              MOVS     r0,#1                 ;3902
                  |L20.100|
000064  4680              MOV      r8,r0                 ;3894
000066  9401              STR      r4,[sp,#4]            ;3913
000068  b125              CBZ      r5,|L20.116|
00006a  2d08              CMP      r5,#8                 ;3915
00006c  d011              BEQ      |L20.146|
00006e  2d10              CMP      r5,#0x10              ;3915
000070  d122              BNE      |L20.184|
000072  e012              B        |L20.154|
                  |L20.116|
000074  7820              LDRB     r0,[r4,#0]            ;3917
000076  2830              CMP      r0,#0x30              ;3917
000078  d001              BEQ      |L20.126|
00007a  250a              MOVS     r5,#0xa               ;3937
00007c  e01c              B        |L20.184|
                  |L20.126|
00007e  f8140f01          LDRB     r0,[r4,#1]!           ;3919
000082  2858              CMP      r0,#0x58              ;3919
000084  d003              BEQ      |L20.142|
000086  2878              CMP      r0,#0x78              ;3919
000088  d001              BEQ      |L20.142|
00008a  2508              MOVS     r5,#8                 ;3932
00008c  e014              B        |L20.184|
                  |L20.142|
00008e  2510              MOVS     r5,#0x10              ;3922
000090  e00c              B        |L20.172|
                  |L20.146|
000092  7820              LDRB     r0,[r4,#0]            ;3943
000094  2830              CMP      r0,#0x30              ;3943
000096  d00e              BEQ      |L20.182|
000098  e00e              B        |L20.184|
                  |L20.154|
00009a  7820              LDRB     r0,[r4,#0]            ;3950
00009c  2830              CMP      r0,#0x30              ;3950
00009e  d10b              BNE      |L20.184|
0000a0  f8140f01          LDRB     r0,[r4,#1]!           ;3952
0000a4  2858              CMP      r0,#0x58              ;3952
0000a6  d001              BEQ      |L20.172|
0000a8  2878              CMP      r0,#0x78              ;3952
0000aa  d105              BNE      |L20.184|
                  |L20.172|
0000ac  7860              LDRB     r0,[r4,#1]            ;3955
0000ae  f7fffffe          BL       ASCII_IsDigHex
0000b2  2801              CMP      r0,#1                 ;3957
0000b4  d100              BNE      |L20.184|
                  |L20.182|
0000b6  1c64              ADDS     r4,r4,#1              ;3958
                  |L20.184|
0000b8  2000              MOVS     r0,#0                 ;3976
0000ba  4683              MOV      r11,r0                ;3977
0000bc  f8cd0000          STR.W    r0,[sp,#0]            ;3977
                  |L20.192|
0000c0  f894a000          LDRB     r10,[r4,#0]           ;3981
0000c4  4650              MOV      r0,r10                ;3982
0000c6  f7fffffe          BL       ASCII_IsAlphaNum
0000ca  2801              CMP      r0,#1                 ;3983
0000cc  d127              BNE      |L20.286|
0000ce  4650              MOV      r0,r10                ;3985
0000d0  f7fffffe          BL       ASCII_IsDig
0000d4  2801              CMP      r0,#1                 ;3986
0000d6  d00d              BEQ      |L20.244|
0000d8  4650              MOV      r0,r10                ;3989
0000da  f7fffffe          BL       ASCII_IsLower
0000de  2801              CMP      r0,#1                 ;3990
0000e0  d00b              BEQ      |L20.250|
0000e2  f1aa0037          SUB      r0,r10,#0x37          ;3993
                  |L20.230|
0000e6  b2c0              UXTB     r0,r0                 ;3991
0000e8  42a8              CMP      r0,r5                 ;3997
0000ea  d218              BCS      |L20.286|
0000ec  f1bb0f00          CMP      r11,#0                ;3998
0000f0  d006              BEQ      |L20.256|
0000f2  e012              B        |L20.282|
                  |L20.244|
0000f4  f1aa0030          SUB      r0,r10,#0x30          ;3987
0000f8  e7f5              B        |L20.230|
                  |L20.250|
0000fa  f1aa0057          SUB      r0,r10,#0x57          ;3991
0000fe  e7f2              B        |L20.230|
                  |L20.256|
000100  490f              LDR      r1,|L20.320|
000102  f8512025          LDR      r2,[r1,r5,LSL #2]     ;3999
000106  9900              LDR      r1,[sp,#0]            ;3999
000108  428a              CMP      r2,r1                 ;3999
00010a  d304              BCC      |L20.278|
00010c  fb010105          MLA      r1,r1,r5,r0           ;4002
000110  9100              STR      r1,[sp,#0]            ;4003
000112  4281              CMP      r1,r0                 ;4003
000114  d201              BCS      |L20.282|
                  |L20.278|
000116  f04f0b01          MOV      r11,#1                ;4004
                  |L20.282|
00011a  1c64              ADDS     r4,r4,#1              ;4010
00011c  e7d0              B        |L20.192|
                  |L20.286|
00011e  f1bb0f01          CMP      r11,#1                ;4021
000122  d102              BNE      |L20.298|
000124  f04f30ff          MOV      r0,#0xffffffff        ;4022
000128  9000              STR      r0,[sp,#0]            ;4022
                  |L20.298|
00012a  9801              LDR      r0,[sp,#4]            ;4026
00012c  4284              CMP      r4,r0                 ;4026
00012e  d001              BEQ      |L20.308|
000130  603c              STR      r4,[r7,#0]            ;4027
000132  e000              B        |L20.310|
                  |L20.308|
000134  603e              STR      r6,[r7,#0]            ;4029
                  |L20.310|
000136  f8898000          STRB     r8,[r9,#0]            ;4032
00013a  9800              LDR      r0,[sp,#0]            ;4035
00013c  e779              B        |L20.50|
;;;4037   
                          ENDP

00013e  0000              DCW      0x0000
                  |L20.320|
                          DCD      ||.constdata||

                          AREA ||i.Str_ParseNbr_Int32S||, CODE, READONLY, ALIGN=1

                  Str_ParseNbr_Int32S PROC
;;;3187   
;;;3188   CPU_INT32S  Str_ParseNbr_Int32S (const  CPU_CHAR     *pstr,
000000  b51c              PUSH     {r2-r4,lr}
;;;3189                                           CPU_CHAR    **pstr_next,
;;;3190                                           CPU_INT08U    nbr_base)
;;;3191   {
;;;3192       CPU_INT32S   nbr;
;;;3193       CPU_INT32U   nbr_abs;
;;;3194       CPU_BOOLEAN  nbr_neg;
;;;3195   
;;;3196   
;;;3197       nbr_abs = Str_ParseNbr_Int32(pstr,                          /* Parse/convert str ...                                */
000002  ab01              ADD      r3,sp,#4
000004  9300              STR      r3,[sp,#0]
000006  2301              MOVS     r3,#1
000008  f7fffffe          BL       Str_ParseNbr_Int32
;;;3198                                    pstr_next,
;;;3199                                    nbr_base,
;;;3200                                    DEF_YES,                       /* ... as signed int (see Note #2a2).                   */
;;;3201                                   &nbr_neg);
;;;3202   
;;;3203       if (nbr_neg == DEF_NO) {                                    /* Chk for neg nbr & ovf/undf (see Note #2a3A1).        */
00000c  f89d2004          LDRB     r2,[sp,#4]
;;;3204           nbr = (nbr_abs > (CPU_INT32U) DEF_INT_32S_MAX_VAL)          ?  (CPU_INT32S)DEF_INT_32S_MAX_VAL
000010  f04f4100          MOV      r1,#0x80000000
000014  b122              CBZ      r2,|L21.32|
;;;3205                                                                       :  (CPU_INT32S)nbr_abs;
;;;3206       } else {
;;;3207           nbr = (nbr_abs > (CPU_INT32U)-DEF_INT_32S_MIN_VAL_ONES_CPL) ?  (CPU_INT32S)DEF_INT_32S_MIN_VAL
000016  4288              CMP      r0,r1
000018  d200              BCS      |L21.28|
;;;3208                                                                       : -(CPU_INT32S)nbr_abs;
00001a  4241              RSBS     r1,r0,#0
                  |L21.28|
00001c  4608              MOV      r0,r1
                  |L21.30|
;;;3209       }
;;;3210   
;;;3211       return (nbr);
;;;3212   }
00001e  bd1c              POP      {r2-r4,pc}
                  |L21.32|
000020  4288              CMP      r0,r1                 ;3204
000022  d3fc              BCC      |L21.30|
000024  f06f4000          MVN      r0,#0x80000000        ;3204
000028  bd1c              POP      {r2-r4,pc}
;;;3213   
                          ENDP


                          AREA ||i.Str_ParseNbr_Int32U||, CODE, READONLY, ALIGN=1

                  Str_ParseNbr_Int32U PROC
;;;2971   
;;;2972   CPU_INT32U  Str_ParseNbr_Int32U (const  CPU_CHAR     *pstr,
000000  b508              PUSH     {r3,lr}
;;;2973                                           CPU_CHAR    **pstr_next,
;;;2974                                           CPU_INT08U    nbr_base)
;;;2975   {
;;;2976       CPU_INT32U  nbr;
;;;2977   
;;;2978   
;;;2979       nbr = Str_ParseNbr_Int32(               pstr,               /* Parse/convert str ...                                */
000002  2300              MOVS     r3,#0
000004  9300              STR      r3,[sp,#0]
000006  f7fffffe          BL       Str_ParseNbr_Int32
;;;2980                                               pstr_next,
;;;2981                                               nbr_base,
;;;2982                                               DEF_NO,             /* ... as unsigned int (see Note #2a2).                 */
;;;2983                                (CPU_BOOLEAN *)0);
;;;2984   
;;;2985       return (nbr);
;;;2986   }
00000a  bd08              POP      {r3,pc}
;;;2987   
                          ENDP


                          AREA ||i.Str_Str||, CODE, READONLY, ALIGN=1

                  Str_Str PROC
;;;1760   
;;;1761   CPU_CHAR  *Str_Str (const  CPU_CHAR  *pstr,
000000  f04f32ff          MOV      r2,#0xffffffff
;;;1762                       const  CPU_CHAR  *pstr_srch)
;;;1763   {
;;;1764       CPU_CHAR  *pstr_rtn;
;;;1765   
;;;1766   
;;;1767       pstr_rtn = Str_Str_N(pstr,
000004  f7ffbffe          B.W      Str_Str_N
;;;1768                            pstr_srch,
;;;1769                            DEF_INT_CPU_U_MAX_VAL);
;;;1770   
;;;1771       return (pstr_rtn);
;;;1772   }
;;;1773   
                          ENDP


                          AREA ||i.Str_Str_N||, CODE, READONLY, ALIGN=1

                  Str_Str_N PROC
;;;1844   
;;;1845   CPU_CHAR  *Str_Str_N (const  CPU_CHAR    *pstr,
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;1846                         const  CPU_CHAR    *pstr_srch,
;;;1847                                CPU_SIZE_T   len_max)
;;;1848   {
000004  460e              MOV      r6,r1
000006  0004              MOVS     r4,r0
000008  d025              BEQ      |L24.86|
;;;1849              CPU_SIZE_T    str_len;
;;;1850              CPU_SIZE_T    str_len_srch;
;;;1851              CPU_SIZE_T    len_max_srch;
;;;1852              CPU_SIZE_T    srch_len;
;;;1853              CPU_SIZE_T    srch_ix;
;;;1854              CPU_BOOLEAN   srch_done;
;;;1855              CPU_INT16S    srch_cmp;
;;;1856       const  CPU_CHAR     *pstr_str;
;;;1857       const  CPU_CHAR     *pstr_srch_ix;
;;;1858   
;;;1859                                                                   /* Rtn NULL if str ptr(s) NULL (see Note #3a).          */
;;;1860       if (pstr == (const CPU_CHAR *)0) {
;;;1861           return ((CPU_CHAR *)0);
;;;1862       }
;;;1863       if (pstr_srch == (const CPU_CHAR *)0) {
00000a  b326              CBZ      r6,|L24.86|
;;;1864           return ((CPU_CHAR *)0);
;;;1865       }
;;;1866   
;;;1867       if (len_max < 1) {                                          /* Rtn NULL if srch len = 0    (see Note #3g).          */
00000c  b31a              CBZ      r2,|L24.86|
;;;1868           return ((CPU_CHAR *)0);
;;;1869       }
;;;1870   
;;;1871                                                                   /* Lim max srch str len (to chk > str len).             */
;;;1872       len_max_srch = (len_max <       DEF_INT_CPU_U_MAX_VAL)
00000e  1c50              ADDS     r0,r2,#1
000010  d001              BEQ      |L24.22|
;;;1873                    ? (len_max + 1u) : DEF_INT_CPU_U_MAX_VAL;
000012  4605              MOV      r5,r0
000014  e001              B        |L24.26|
                  |L24.22|
000016  f04f35ff          MOV      r5,#0xffffffff
                  |L24.26|
;;;1874   
;;;1875       str_len      = Str_Len_N(pstr,      len_max);
00001a  4611              MOV      r1,r2
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       Str_Len_N
000022  4607              MOV      r7,r0
;;;1876       str_len_srch = Str_Len_N(pstr_srch, len_max_srch);
000024  4629              MOV      r1,r5
000026  4630              MOV      r0,r6
000028  f7fffffe          BL       Str_Len_N
00002c  0005              MOVS     r5,r0
;;;1877       if (str_len_srch < 1) {                                     /* Rtn ptr to str if srch str len = 0 (see Note #2b2).  */
00002e  d015              BEQ      |L24.92|
;;;1878           return ((CPU_CHAR *)pstr);
;;;1879       }
;;;1880       if (str_len_srch > str_len) {                               /* Rtn NULL if srch str len > str len (see Note #3d).   */
000030  42bd              CMP      r5,r7
000032  d810              BHI      |L24.86|
;;;1881           return ((CPU_CHAR *)0);
;;;1882       }
;;;1883                                                                   /* Rtn NULL if NULL ptr found         (see Note #3b1).  */
;;;1884       pstr_str = pstr      + str_len;
000034  19e0              ADDS     r0,r4,r7
;;;1885       if (pstr_str == (const CPU_CHAR *)0) {
000036  d00f              BEQ      |L24.88|
;;;1886           return ((CPU_CHAR *)0);
;;;1887       }
;;;1888       pstr_str = pstr_srch + str_len_srch;
000038  1970              ADDS     r0,r6,r5
;;;1889       if (pstr_str == (const CPU_CHAR *)0) {
00003a  d00d              BEQ      |L24.88|
;;;1890           return ((CPU_CHAR *)0);
;;;1891       }
;;;1892   
;;;1893   
;;;1894       srch_len  = str_len - str_len_srch;                         /* Calc srch len (see Note #3e2).                       */
00003c  eba70905          SUB      r9,r7,r5
;;;1895       srch_ix   = 0u;
000040  2700              MOVS     r7,#0
                  |L24.66|
;;;1896       srch_done = DEF_NO;
;;;1897   
;;;1898       do {
;;;1899           pstr_srch_ix = (const CPU_CHAR *)(pstr + srch_ix);
000042  19e0              ADDS     r0,r4,r7
000044  4680              MOV      r8,r0
;;;1900           srch_cmp     =  Str_Cmp_N(pstr_srch_ix, pstr_srch, str_len_srch);
000046  462a              MOV      r2,r5
000048  4631              MOV      r1,r6
00004a  f7fffffe          BL       Str_Cmp_N
;;;1901           srch_done    = (srch_cmp == 0) ? DEF_YES : DEF_NO;
00004e  b138              CBZ      r0,|L24.96|
;;;1902           srch_ix++;
000050  1c7f              ADDS     r7,r7,#1
;;;1903       } while ((srch_done == DEF_NO) && (srch_ix <= srch_len));
000052  454f              CMP      r7,r9
000054  d9f5              BLS      |L24.66|
                  |L24.86|
;;;1904   
;;;1905   
;;;1906       if (srch_cmp != 0) {                                        /* Rtn NULL if srch str NOT found (see Note #3e2).      */
;;;1907           return ((CPU_CHAR *)0);
000056  2000              MOVS     r0,#0
                  |L24.88|
;;;1908       }
;;;1909   
;;;1910       return ((CPU_CHAR *)pstr_srch_ix);                          /* Else rtn ptr to found srch str (see Note #3f1).      */
;;;1911   }
000058  e8bd83f0          POP      {r4-r9,pc}
                  |L24.92|
00005c  4620              MOV      r0,r4                 ;1878
00005e  e7fb              B        |L24.88|
                  |L24.96|
000060  4640              MOV      r0,r8                 ;1910
000062  e7f9              B        |L24.88|
;;;1912   
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  Str_MultOvfThTbl_Int32U
                          DCD      0xffffffff
                          DCD      0xffffffff
                          DCD      0x7fffffff
                          DCD      0x55555555
                          DCD      0x3fffffff
                          DCD      0x33333333
                          DCD      0x2aaaaaaa
                          DCD      0x24924924
                          DCD      0x1fffffff
                          DCD      0x1c71c71c
                          DCD      0x19999999
                          DCD      0x1745d174
                          DCD      0x15555555
                          DCD      0x13b13b13
                          DCD      0x12492492
                          DCD      0x11111111
                          DCD      0x0fffffff
                          DCD      0x0f0f0f0f
                          DCD      0x0e38e38e
                          DCD      0x0d79435e
                          DCD      0x0ccccccc
                          DCD      0x0c30c30c
                          DCD      0x0ba2e8ba
                          DCD      0x0b21642c
                          DCD      0x0aaaaaaa
                          DCD      0x0a3d70a3
                          DCD      0x09d89d89
                          DCD      0x097b425e
                          DCD      0x09249249
                          DCD      0x08d3dcb0
                          DCD      0x08888888
                          DCD      0x08421084
                          DCD      0x07ffffff
                          DCD      0x07c1f07c
                          DCD      0x07878787
                          DCD      0x07507507
                          DCD      0x071c71c7
