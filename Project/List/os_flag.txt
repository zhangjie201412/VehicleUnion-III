; generated by ARM C/C++ Compiler, 5.02 [Build 28]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\OBJ\os_flag.o --asm_dir=.\List\ --list_dir=.\List\ --depend=..\OBJ\os_flag.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\BSP -I..\CORE -I..\STM32F10x_FWLib\inc -I..\USER -I..\UCOSIII\uC-CPU -I..\UCOSIII\uC-CPU\ARM-Cortex-M3\RealView -I..\UCOSIII\uC-LIB -I..\UCOSIII\uC-LIB\Ports\ARM-Cortex-M3\RealView -I..\UCOSIII\uCOS-III -I..\UCOSIII\uCOS-III\Ports -I..\UCOSIII\uCOS-III\Ports\ARM-Cortex-M3\Generic\RealView -I..\UCOSIII\uCOS-III\Source -I..\UCOSIII\UCOS_BSP -I..\UCOSIII\uCOS_CONFIG -I..\UCOSIII-Task -I..\SYSTEM -I..\BSP\inc -I..\PAL -I..\PAL\vehicles -ID:\Keil_v4\ARM\RV31\INC -ID:\Keil_v4\ARM\CMSIS\Include -ID:\Keil_v4\ARM\Inc\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=..\OBJ\os_flag.crf ..\UCOSIII\uCOS-III\Source\os_flag.c]
                          THUMB

                          AREA ||i.OSFlagCreate||, CODE, READONLY, ALIGN=2

                  OSFlagCreate PROC
;;;69     
;;;70     void  OSFlagCreate (OS_FLAG_GRP  *p_grp,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;71                         CPU_CHAR     *p_name,
;;;72                         OS_FLAGS      flags,
;;;73                         OS_ERR       *p_err)
;;;74     {
000004  4604              MOV      r4,r0
;;;75         CPU_SR_ALLOC();
;;;76     
;;;77     
;;;78     
;;;79     #ifdef OS_SAFETY_CRITICAL
;;;80         if (p_err == (OS_ERR *)0) {
;;;81             OS_SAFETY_CRITICAL_EXCEPTION();
;;;82             return;
;;;83         }
;;;84     #endif
;;;85     
;;;86     #ifdef OS_SAFETY_CRITICAL_IEC61508
;;;87         if (OSSafetyCriticalStartFlag == DEF_TRUE) {
;;;88            *p_err = OS_ERR_ILLEGAL_CREATE_RUN_TIME;
;;;89             return;
;;;90         }
;;;91     #endif
;;;92     
;;;93     #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;94         if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from ISR ...                             */
000006  4818              LDR      r0,|L1.104|
000008  4690              MOV      r8,r2                 ;74
00000a  460f              MOV      r7,r1                 ;74
00000c  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
00000e  461d              MOV      r5,r3                 ;74
000010  b110              CBZ      r0,|L1.24|
;;;95            *p_err = OS_ERR_CREATE_ISR;                          /* ... can't CREATE from an ISR                           */
000012  f64260e1          MOV      r0,#0x2ee1
;;;96             return;
000016  e025              B        |L1.100|
                  |L1.24|
;;;97         }
;;;98     #endif
;;;99     
;;;100    #if OS_CFG_ARG_CHK_EN > 0u
;;;101        if (p_grp == (OS_FLAG_GRP *)0) {                        /* Validate 'p_grp'                                       */
000018  b314              CBZ      r4,|L1.96|
;;;102           *p_err = OS_ERR_OBJ_PTR_NULL;
;;;103            return;
;;;104        }
;;;105    #endif
;;;106    
;;;107        OS_CRITICAL_ENTER();
00001a  f7fffffe          BL       CPU_SR_Save
00001e  4e13              LDR      r6,|L1.108|
000020  7831              LDRB     r1,[r6,#0]  ; OSSchedLockNestingCtr
000022  1c49              ADDS     r1,r1,#1
000024  7031              STRB     r1,[r6,#0]
000026  f7fffffe          BL       CPU_SR_Restore
;;;108        p_grp->Type    = OS_OBJ_TYPE_FLAG;                      /* Set to event flag group type                           */
00002a  4811              LDR      r0,|L1.112|
00002c  e9c40700          STRD     r0,r7,[r4,#0]
;;;109        p_grp->NamePtr = p_name;
;;;110        p_grp->Flags   = flags;                                 /* Set to desired initial value                           */
;;;111        p_grp->TS      = (CPU_TS)0;
000030  2700              MOVS     r7,#0
;;;112        OS_PendListInit(&p_grp->PendList);
000032  e9c48708          STRD     r8,r7,[r4,#0x20]
000036  f1040008          ADD      r0,r4,#8
00003a  f7fffffe          BL       OS_PendListInit
;;;113    
;;;114    #if OS_CFG_DBG_EN > 0u
;;;115        OS_FlagDbgListAdd(p_grp);
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       OS_FlagDbgListAdd
;;;116    #endif
;;;117        OSFlagQty++;
000044  490b              LDR      r1,|L1.116|
000046  8808              LDRH     r0,[r1,#0]  ; OSFlagQty
000048  1c40              ADDS     r0,r0,#1
00004a  8008              STRH     r0,[r1,#0]
;;;118    
;;;119        OS_CRITICAL_EXIT_NO_SCHED();
00004c  f7fffffe          BL       CPU_SR_Save
000050  7831              LDRB     r1,[r6,#0]  ; OSSchedLockNestingCtr
000052  1e49              SUBS     r1,r1,#1
000054  7031              STRB     r1,[r6,#0]
000056  f7fffffe          BL       CPU_SR_Restore
;;;120       *p_err = OS_ERR_NONE;
00005a  802f              STRH     r7,[r5,#0]
                  |L1.92|
;;;121    }
00005c  e8bd81f0          POP      {r4-r8,pc}
                  |L1.96|
000060  f64550c3          MOV      r0,#0x5dc3            ;102
                  |L1.100|
000064  8018              STRH     r0,[r3,#0]            ;102
000066  e7f9              B        |L1.92|
;;;122    
                          ENDP

                  |L1.104|
                          DCD      OSIntNestingCtr
                  |L1.108|
                          DCD      OSSchedLockNestingCtr
                  |L1.112|
                          DCD      0x47414c46
                  |L1.116|
                          DCD      OSFlagQty

                          AREA ||i.OSFlagDel||, CODE, READONLY, ALIGN=2

                  OSFlagDel PROC
;;;155    #if OS_CFG_FLAG_DEL_EN > 0u
;;;156    OS_OBJ_QTY  OSFlagDel (OS_FLAG_GRP  *p_grp,
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;157                           OS_OPT        opt,
;;;158                           OS_ERR       *p_err)
;;;159    {
000004  4607              MOV      r7,r0
;;;160        OS_OBJ_QTY        cnt;
;;;161        OS_OBJ_QTY        nbr_tasks;
;;;162        OS_PEND_DATA     *p_pend_data;
;;;163        OS_PEND_LIST     *p_pend_list;
;;;164        OS_TCB           *p_tcb;
;;;165        CPU_TS            ts;
;;;166        CPU_SR_ALLOC();
;;;167    
;;;168    
;;;169    
;;;170    #ifdef OS_SAFETY_CRITICAL
;;;171        if (p_err == (OS_ERR *)0) {
;;;172            OS_SAFETY_CRITICAL_EXCEPTION();
;;;173            return ((OS_OBJ_QTY)0);
;;;174        }
;;;175    #endif
;;;176    
;;;177    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;178        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from ISR ...                             */
000006  4853              LDR      r0,|L2.340|
000008  4689              MOV      r9,r1                 ;159
00000a  4615              MOV      r5,r2                 ;159
00000c  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
00000e  b110              CBZ      r0,|L2.22|
;;;179           *p_err = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR                           */
000010  f24320c9          MOV      r0,#0x32c9
;;;180            return ((OS_OBJ_QTY)0);
000014  e00f              B        |L2.54|
                  |L2.22|
;;;181        }
;;;182    #endif
;;;183    
;;;184    #if OS_CFG_ARG_CHK_EN > 0u
;;;185        if (p_grp == (OS_FLAG_GRP *)0) {                        /* Validate 'p_grp'                                       */
000016  b12f              CBZ      r7,|L2.36|
;;;186           *p_err  = OS_ERR_OBJ_PTR_NULL;
;;;187            return ((OS_OBJ_QTY)0);
;;;188        }
;;;189        switch (opt) {                                          /* Validate 'opt'                                         */
000018  b139              CBZ      r1,|L2.42|
00001a  2901              CMP      r1,#1
00001c  d005              BEQ      |L2.42|
;;;190            case OS_OPT_DEL_NO_PEND:
;;;191            case OS_OPT_DEL_ALWAYS:
;;;192                 break;
;;;193    
;;;194            default:
;;;195                *p_err = OS_ERR_OPT_INVALID;
00001e  f6456025          MOV      r0,#0x5e25
;;;196                 return ((OS_OBJ_QTY)0);
000022  e008              B        |L2.54|
                  |L2.36|
000024  f64550c3          MOV      r0,#0x5dc3            ;186
000028  e005              B        |L2.54|
                  |L2.42|
;;;197        }
;;;198    #endif
;;;199    
;;;200    #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
;;;201        if (p_grp->Type != OS_OBJ_TYPE_FLAG) {                  /* Validate event group object                            */
00002a  494b              LDR      r1,|L2.344|
00002c  6838              LDR      r0,[r7,#0]
00002e  4288              CMP      r0,r1
000030  d005              BEQ      |L2.62|
;;;202           *p_err = OS_ERR_OBJ_TYPE;
000032  f64550c4          MOV      r0,#0x5dc4
                  |L2.54|
000036  8010              STRH     r0,[r2,#0]
;;;203            return ((OS_OBJ_QTY)0);
000038  2000              MOVS     r0,#0
                  |L2.58|
;;;204        }
;;;205    #endif
;;;206        OS_CRITICAL_ENTER();
;;;207        p_pend_list = &p_grp->PendList;
;;;208        cnt         = p_pend_list->NbrEntries;
;;;209        nbr_tasks   = cnt;
;;;210        switch (opt) {
;;;211            case OS_OPT_DEL_NO_PEND:                            /* Delete group if no task waiting                        */
;;;212                 if (nbr_tasks == (OS_OBJ_QTY)0) {
;;;213    #if OS_CFG_DBG_EN > 0u
;;;214                     OS_FlagDbgListRemove(p_grp);
;;;215    #endif
;;;216                     OSFlagQty--;
;;;217                     OS_FlagClr(p_grp);
;;;218    
;;;219                     OS_CRITICAL_EXIT();
;;;220                    *p_err = OS_ERR_NONE;
;;;221                 } else {
;;;222                     OS_CRITICAL_EXIT();
;;;223                    *p_err = OS_ERR_TASK_WAITING;
;;;224                 }
;;;225                 break;
;;;226    
;;;227            case OS_OPT_DEL_ALWAYS:                             /* Always delete the event flag group                     */
;;;228                 ts = OS_TS_GET();                              /* Get local time stamp so all tasks get the same time    */
;;;229                 while (cnt > 0u) {                             /* Remove all tasks from the pend list                    */
;;;230                     p_pend_data = p_pend_list->HeadPtr;
;;;231                     p_tcb       = p_pend_data->TCBPtr;
;;;232                     OS_PendObjDel((OS_PEND_OBJ *)((void *)p_grp),
;;;233                                   p_tcb,
;;;234                                   ts);
;;;235                     cnt--;
;;;236                 }
;;;237    #if OS_CFG_DBG_EN > 0u
;;;238                 OS_FlagDbgListRemove(p_grp);
;;;239    #endif
;;;240                 OSFlagQty--;
;;;241                 OS_FlagClr(p_grp);
;;;242                 OS_CRITICAL_EXIT_NO_SCHED();
;;;243                 OSSched();                                     /* Find highest priority task ready to run                */
;;;244                *p_err = OS_ERR_NONE;
;;;245                 break;
;;;246    
;;;247            default:
;;;248                 OS_CRITICAL_EXIT();
;;;249                *p_err = OS_ERR_OPT_INVALID;
;;;250                 break;
;;;251        }
;;;252        return (nbr_tasks);
;;;253    }
00003a  e8bd9ff0          POP      {r4-r12,pc}
                  |L2.62|
00003e  f7fffffe          BL       CPU_SR_Save
000042  4c46              LDR      r4,|L2.348|
000044  7821              LDRB     r1,[r4,#0]            ;206  ; OSSchedLockNestingCtr
000046  1c49              ADDS     r1,r1,#1              ;206
000048  7021              STRB     r1,[r4,#0]            ;206
00004a  f7fffffe          BL       CPU_SR_Restore
00004e  8a3e              LDRH     r6,[r7,#0x10]         ;208
000050  ea5f0009          MOVS     r0,r9                 ;210
000054  f8dfb108          LDR      r11,|L2.352|
000058  f8df9108          LDR      r9,|L2.356|
00005c  f1070808          ADD      r8,r7,#8              ;207
000060  46b2              MOV      r10,r6                ;209
000062  d00a              BEQ      |L2.122|
000064  2801              CMP      r0,#1                 ;210
000066  d042              BEQ      |L2.238|
000068  f7fffffe          BL       CPU_SR_Save
00006c  7821              LDRB     r1,[r4,#0]            ;248  ; OSSchedLockNestingCtr
00006e  1e49              SUBS     r1,r1,#1              ;248
000070  f01101ff          ANDS     r1,r1,#0xff           ;248
000074  7021              STRB     r1,[r4,#0]            ;248
000076  d05f              BEQ      |L2.312|
000078  e066              B        |L2.328|
                  |L2.122|
00007a  f1ba0f00          CMP      r10,#0                ;212
00007e  d008              BEQ      |L2.146|
000080  f7fffffe          BL       CPU_SR_Save
000084  7821              LDRB     r1,[r4,#0]            ;222  ; OSSchedLockNestingCtr
000086  1e49              SUBS     r1,r1,#1              ;222
000088  f01101ff          ANDS     r1,r1,#0xff           ;222
00008c  7021              STRB     r1,[r4,#0]            ;222
00008e  d01f              BEQ      |L2.208|
000090  e026              B        |L2.224|
                  |L2.146|
000092  4638              MOV      r0,r7                 ;214
000094  f7fffffe          BL       OS_FlagDbgListRemove
000098  f8bb1000          LDRH     r1,[r11,#0]           ;216  ; OSFlagQty
00009c  4638              MOV      r0,r7                 ;217
00009e  1e49              SUBS     r1,r1,#1              ;216
0000a0  f8ab1000          STRH     r1,[r11,#0]           ;216
0000a4  f7fffffe          BL       OS_FlagClr
0000a8  f7fffffe          BL       CPU_SR_Save
0000ac  7821              LDRB     r1,[r4,#0]            ;219  ; OSSchedLockNestingCtr
0000ae  1e49              SUBS     r1,r1,#1              ;219
0000b0  f01101ff          ANDS     r1,r1,#0xff           ;219
0000b4  7021              STRB     r1,[r4,#0]            ;219
0000b6  d107              BNE      |L2.200|
0000b8  f8b91000          LDRH     r1,[r9,#0]            ;219  ; OSIntQNbrEntries
0000bc  b121              CBZ      r1,|L2.200|
0000be  f7fffffe          BL       CPU_SR_Restore
0000c2  f7fffffe          BL       OS_Sched0
0000c6  e001              B        |L2.204|
                  |L2.200|
0000c8  f7fffffe          BL       CPU_SR_Restore
                  |L2.204|
0000cc  2000              MOVS     r0,#0                 ;220
0000ce  e00b              B        |L2.232|
                  |L2.208|
0000d0  f8b91000          LDRH     r1,[r9,#0]            ;222  ; OSIntQNbrEntries
0000d4  b121              CBZ      r1,|L2.224|
0000d6  f7fffffe          BL       CPU_SR_Restore
0000da  f7fffffe          BL       OS_Sched0
0000de  e001              B        |L2.228|
                  |L2.224|
0000e0  f7fffffe          BL       CPU_SR_Restore
                  |L2.228|
0000e4  f247105f          MOV      r0,#0x715f            ;223
                  |L2.232|
0000e8  8028              STRH     r0,[r5,#0]            ;220
0000ea  4650              MOV      r0,r10                ;252
0000ec  e7a5              B        |L2.58|
                  |L2.238|
0000ee  f7fffffe          BL       CPU_TS_TmrRd
0000f2  4681              MOV      r9,r0                 ;228
0000f4  e009              B        |L2.266|
0000f6  bf00              NOP                            ;231
                  |L2.248|
0000f8  f8d80000          LDR      r0,[r8,#0]            ;231
0000fc  464a              MOV      r2,r9                 ;232
0000fe  6881              LDR      r1,[r0,#8]            ;232
000100  4638              MOV      r0,r7                 ;232
000102  f7fffffe          BL       OS_PendObjDel
000106  1e76              SUBS     r6,r6,#1              ;235
000108  b2b6              UXTH     r6,r6                 ;235
                  |L2.266|
00010a  2e00              CMP      r6,#0                 ;229
00010c  d1f4              BNE      |L2.248|
00010e  4638              MOV      r0,r7                 ;238
000110  f7fffffe          BL       OS_FlagDbgListRemove
000114  f8bb1000          LDRH     r1,[r11,#0]           ;240  ; OSFlagQty
000118  4638              MOV      r0,r7                 ;241
00011a  1e49              SUBS     r1,r1,#1              ;240
00011c  f8ab1000          STRH     r1,[r11,#0]           ;240
000120  f7fffffe          BL       OS_FlagClr
000124  f7fffffe          BL       CPU_SR_Save
000128  7821              LDRB     r1,[r4,#0]            ;242  ; OSSchedLockNestingCtr
00012a  1e49              SUBS     r1,r1,#1              ;242
00012c  7021              STRB     r1,[r4,#0]            ;242
00012e  f7fffffe          BL       CPU_SR_Restore
000132  f7fffffe          BL       OSSched
000136  e7c9              B        |L2.204|
                  |L2.312|
000138  f8b91000          LDRH     r1,[r9,#0]            ;248  ; OSIntQNbrEntries
00013c  b121              CBZ      r1,|L2.328|
00013e  f7fffffe          BL       CPU_SR_Restore
000142  f7fffffe          BL       OS_Sched0
000146  e001              B        |L2.332|
                  |L2.328|
000148  f7fffffe          BL       CPU_SR_Restore
                  |L2.332|
00014c  f6456025          MOV      r0,#0x5e25            ;249
000150  e7ca              B        |L2.232|
;;;254    #endif
                          ENDP

000152  0000              DCW      0x0000
                  |L2.340|
                          DCD      OSIntNestingCtr
                  |L2.344|
                          DCD      0x47414c46
                  |L2.348|
                          DCD      OSSchedLockNestingCtr
                  |L2.352|
                          DCD      OSFlagQty
                  |L2.356|
                          DCD      OSIntQNbrEntries

                          AREA ||i.OSFlagPend||, CODE, READONLY, ALIGN=2

                  OSFlagPend PROC
;;;314    
;;;315    OS_FLAGS  OSFlagPend (OS_FLAG_GRP  *p_grp,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;316                          OS_FLAGS      flags,
;;;317                          OS_TICK       timeout,
;;;318                          OS_OPT        opt,
;;;319                          CPU_TS       *p_ts,
;;;320                          OS_ERR       *p_err)
;;;321    {
000004  4605              MOV      r5,r0
000006  b08b              SUB      sp,sp,#0x2c
;;;322        CPU_BOOLEAN   consume;
;;;323        OS_FLAGS      flags_rdy;
;;;324        OS_OPT        mode;
;;;325        OS_PEND_DATA  pend_data;
;;;326        CPU_SR_ALLOC();
;;;327    
;;;328    
;;;329    
;;;330    #ifdef OS_SAFETY_CRITICAL
;;;331        if (p_err == (OS_ERR *)0) {
;;;332            OS_SAFETY_CRITICAL_EXCEPTION();
;;;333            return ((OS_FLAGS)0);
;;;334        }
;;;335    #endif
;;;336    
;;;337    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;338        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from ISR ...                             */
000008  4886              LDR      r0,|L3.548|
00000a  e9dd6418          LDRD     r6,r4,[sp,#0x60]      ;321
00000e  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
000010  461f              MOV      r7,r3                 ;321
000012  4689              MOV      r9,r1                 ;321
000014  b110              CBZ      r0,|L3.28|
;;;339           *p_err = OS_ERR_PEND_ISR;                            /* ... can't PEND from an ISR                             */
000016  f24610ae          MOV      r0,#0x61ae
;;;340            return ((OS_FLAGS)0);
00001a  e0e9              B        |L3.496|
                  |L3.28|
;;;341        }
;;;342    #endif
;;;343    
;;;344    #if OS_CFG_ARG_CHK_EN > 0u
;;;345        if (p_grp == (OS_FLAG_GRP *)0) {                        /* Validate 'p_grp'                                       */
00001c  b1ad              CBZ      r5,|L3.74|
;;;346           *p_err = OS_ERR_OBJ_PTR_NULL;
;;;347            return ((OS_FLAGS)0);
;;;348        }
;;;349        switch (opt) {                                          /* Validate 'opt'                                         */
00001e  f2480101          MOV      r1,#0x8001
000022  1a78              SUBS     r0,r7,r1
000024  428f              CMP      r7,r1
000026  d029              BEQ      |L3.124|
000028  dc19              BGT      |L3.94|
00002a  f2401101          MOV      r1,#0x101
00002e  f2a71001          SUB      r0,r7,#0x101
000032  428f              CMP      r7,r1
000034  d022              BEQ      |L3.124|
000036  dc0b              BGT      |L3.80|
000038  2f01              CMP      r7,#1
00003a  d01f              BEQ      |L3.124|
00003c  2f02              CMP      r7,#2
00003e  d01d              BEQ      |L3.124|
000040  2f04              CMP      r7,#4
000042  d01b              BEQ      |L3.124|
000044  2f08              CMP      r7,#8
000046  d116              BNE      |L3.118|
000048  e018              B        |L3.124|
                  |L3.74|
00004a  f64550c3          MOV      r0,#0x5dc3            ;346
00004e  e0cf              B        |L3.496|
                  |L3.80|
000050  2801              CMP      r0,#1
000052  d013              BEQ      |L3.124|
000054  2803              CMP      r0,#3
000056  d011              BEQ      |L3.124|
000058  2807              CMP      r0,#7
00005a  d10c              BNE      |L3.118|
00005c  e00e              B        |L3.124|
                  |L3.94|
00005e  f5b07f80          CMP      r0,#0x100
000062  d00b              BEQ      |L3.124|
000064  ddf4              BLE      |L3.80|
000066  f5a07080          SUB      r0,r0,#0x100
00006a  3801              SUBS     r0,#1
00006c  d006              BEQ      |L3.124|
00006e  2802              CMP      r0,#2
000070  d004              BEQ      |L3.124|
000072  2806              CMP      r0,#6
000074  d002              BEQ      |L3.124|
                  |L3.118|
;;;350            case OS_OPT_PEND_FLAG_CLR_ALL:
;;;351            case OS_OPT_PEND_FLAG_CLR_ANY:
;;;352            case OS_OPT_PEND_FLAG_SET_ALL:
;;;353            case OS_OPT_PEND_FLAG_SET_ANY:
;;;354            case OS_OPT_PEND_FLAG_CLR_ALL | OS_OPT_PEND_FLAG_CONSUME:
;;;355            case OS_OPT_PEND_FLAG_CLR_ANY | OS_OPT_PEND_FLAG_CONSUME:
;;;356            case OS_OPT_PEND_FLAG_SET_ALL | OS_OPT_PEND_FLAG_CONSUME:
;;;357            case OS_OPT_PEND_FLAG_SET_ANY | OS_OPT_PEND_FLAG_CONSUME:
;;;358            case OS_OPT_PEND_FLAG_CLR_ALL | OS_OPT_PEND_NON_BLOCKING:
;;;359            case OS_OPT_PEND_FLAG_CLR_ANY | OS_OPT_PEND_NON_BLOCKING:
;;;360            case OS_OPT_PEND_FLAG_SET_ALL | OS_OPT_PEND_NON_BLOCKING:
;;;361            case OS_OPT_PEND_FLAG_SET_ANY | OS_OPT_PEND_NON_BLOCKING:
;;;362            case OS_OPT_PEND_FLAG_CLR_ALL | OS_OPT_PEND_FLAG_CONSUME | OS_OPT_PEND_NON_BLOCKING:
;;;363            case OS_OPT_PEND_FLAG_CLR_ANY | OS_OPT_PEND_FLAG_CONSUME | OS_OPT_PEND_NON_BLOCKING:
;;;364            case OS_OPT_PEND_FLAG_SET_ALL | OS_OPT_PEND_FLAG_CONSUME | OS_OPT_PEND_NON_BLOCKING:
;;;365            case OS_OPT_PEND_FLAG_SET_ANY | OS_OPT_PEND_FLAG_CONSUME | OS_OPT_PEND_NON_BLOCKING:
;;;366                 break;
;;;367    
;;;368            default:
;;;369                *p_err = OS_ERR_OPT_INVALID;
000076  f6456025          MOV      r0,#0x5e25
;;;370                 return ((OS_OBJ_QTY)0);
00007a  e0b9              B        |L3.496|
                  |L3.124|
;;;371        }
;;;372    #endif
;;;373    
;;;374    #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
;;;375        if (p_grp->Type != OS_OBJ_TYPE_FLAG) {                  /* Validate that we are pointing at an event flag         */
00007c  496a              LDR      r1,|L3.552|
00007e  6828              LDR      r0,[r5,#0]
000080  4288              CMP      r0,r1
000082  d002              BEQ      |L3.138|
;;;376           *p_err = OS_ERR_OBJ_TYPE;
000084  f64550c4          MOV      r0,#0x5dc4
;;;377            return ((OS_FLAGS)0);
000088  e0b2              B        |L3.496|
                  |L3.138|
;;;378        }
;;;379    #endif
;;;380    
;;;381        if ((opt & OS_OPT_PEND_FLAG_CONSUME) != (OS_OPT)0) {    /* See if we need to consume the flags                    */
00008a  05f8              LSLS     r0,r7,#23
00008c  d501              BPL      |L3.146|
;;;382            consume = DEF_TRUE;
00008e  2001              MOVS     r0,#1
000090  e000              B        |L3.148|
                  |L3.146|
;;;383        } else {
;;;384            consume = DEF_FALSE;
000092  2000              MOVS     r0,#0
                  |L3.148|
000094  4680              MOV      r8,r0
000096  f04f0b00          MOV      r11,#0
00009a  b10e              CBZ      r6,|L3.160|
;;;385        }
;;;386    
;;;387        if (p_ts != (CPU_TS *)0) {
;;;388           *p_ts = (CPU_TS)0;                                   /* Initialize the returned timestamp                      */
00009c  f8c6b000          STR      r11,[r6,#0]
                  |L3.160|
;;;389        }
;;;390    
;;;391        mode = opt & OS_OPT_PEND_FLAG_MASK;
0000a0  f007020f          AND      r2,r7,#0xf
;;;392        CPU_CRITICAL_ENTER();
0000a4  9209              STR      r2,[sp,#0x24]
0000a6  f7fffffe          BL       CPU_SR_Save
;;;393        switch (mode) {
0000aa  9a09              LDR      r2,[sp,#0x24]
;;;394            case OS_OPT_PEND_FLAG_SET_ALL:                      /* See if all required flags are set                      */
;;;395                 flags_rdy = (OS_FLAGS)(p_grp->Flags & flags);  /* Extract only the bits we want                          */
;;;396                 if (flags_rdy == flags) {                      /* Must match ALL the bits that we want                   */
;;;397                     if (consume == DEF_TRUE) {                 /* See if we need to consume the flags                    */
;;;398                         p_grp->Flags &= ~flags_rdy;            /* Clear ONLY the flags that we wanted                    */
;;;399                     }
;;;400                     OSTCBCurPtr->FlagsRdy = flags_rdy;         /* Save flags that were ready                             */
;;;401                     if (p_ts != (CPU_TS *)0) {
;;;402                        *p_ts  = p_grp->TS;
;;;403                     }
;;;404                     CPU_CRITICAL_EXIT();                       /* Yes, condition met, return to caller                   */
;;;405                    *p_err = OS_ERR_NONE;
;;;406                     return (flags_rdy);
;;;407                 } else {                                       /* Block task until events occur or timeout               */
;;;408                     if ((opt & OS_OPT_PEND_NON_BLOCKING) != (OS_OPT)0) {
;;;409                         CPU_CRITICAL_EXIT();
;;;410                        *p_err = OS_ERR_PEND_WOULD_BLOCK;       /* Specified non-blocking so task would block             */
;;;411                         return ((OS_FLAGS)0);
;;;412                     } else {                                   /* Specified blocking so check is scheduler is locked     */
;;;413                         if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) { /* See if called with scheduler locked ...      */
0000ac  495f              LDR      r1,|L3.556|
0000ae  f04f0e01          MOV      lr,#1                 ;382
0000b2  2a01              CMP      r2,#1                 ;393
0000b4  d032              BEQ      |L3.284|
0000b6  2a02              CMP      r2,#2                 ;393
0000b8  d036              BEQ      |L3.296|
0000ba  2a04              CMP      r2,#4                 ;393
0000bc  d002              BEQ      |L3.196|
0000be  2a08              CMP      r2,#8                 ;393
0000c0  d16c              BNE      |L3.412|
0000c2  e020              B        |L3.262|
                  |L3.196|
0000c4  6a2a              LDR      r2,[r5,#0x20]         ;395
0000c6  ea020a09          AND      r10,r2,r9             ;395
0000ca  45ca              CMP      r10,r9                ;396
0000cc  d01f              BEQ      |L3.270|
0000ce  e00e              B        |L3.238|
                  |L3.208|
0000d0  4a57              LDR      r2,|L3.560|
0000d2  6812              LDR      r2,[r2,#0]            ;400  ; OSTCBCurPtr
0000d4  f8c2a084          STR      r10,[r2,#0x84]        ;401
0000d8  b10e              CBZ      r6,|L3.222|
0000da  6a69              LDR      r1,[r5,#0x24]         ;402
0000dc  6031              STR      r1,[r6,#0]            ;402
                  |L3.222|
;;;414                             CPU_CRITICAL_EXIT();
;;;415                            *p_err = OS_ERR_SCHED_LOCKED;                 /* ... can't PEND when locked                   */
;;;416                             return ((OS_FLAGS)0);
;;;417                         }
;;;418                     }
;;;419                                                                
;;;420                     OS_CRITICAL_ENTER_CPU_CRITICAL_EXIT();     /* Lock the scheduler/re-enable interrupts                */
;;;421                     OS_FlagBlock(&pend_data,
;;;422                                  p_grp,
;;;423                                  flags,
;;;424                                  opt,
;;;425                                  timeout);
;;;426                     OS_CRITICAL_EXIT_NO_SCHED();
;;;427                 }
;;;428                 break;
;;;429    
;;;430            case OS_OPT_PEND_FLAG_SET_ANY:
;;;431                 flags_rdy = (OS_FLAGS)(p_grp->Flags & flags);  /* Extract only the bits we want                          */
;;;432                 if (flags_rdy != (OS_FLAGS)0) {                /* See if any flag set                                    */
;;;433                     if (consume == DEF_TRUE) {                 /* See if we need to consume the flags                    */
;;;434                         p_grp->Flags &= ~flags_rdy;            /* Clear ONLY the flags that we got                       */
;;;435                     }
;;;436                     OSTCBCurPtr->FlagsRdy = flags_rdy;         /* Save flags that were ready                             */
;;;437                     if (p_ts != (CPU_TS *)0) {
;;;438                        *p_ts  = p_grp->TS;
;;;439                     }
;;;440                     CPU_CRITICAL_EXIT();                       /* Yes, condition met, return to caller                   */
;;;441                    *p_err = OS_ERR_NONE;
;;;442                     return (flags_rdy);
;;;443                 } else {                                       /* Block task until events occur or timeout               */
;;;444                     if ((opt & OS_OPT_PEND_NON_BLOCKING) != (OS_OPT)0) {
;;;445                         CPU_CRITICAL_EXIT();
;;;446                        *p_err = OS_ERR_PEND_WOULD_BLOCK;       /* Specified non-blocking so task would block             */
;;;447                         return ((OS_FLAGS)0);
;;;448                     } else {                                   /* Specified blocking so check is scheduler is locked     */
;;;449                         if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) { /* See if called with scheduler locked ...      */
;;;450                             CPU_CRITICAL_EXIT();
;;;451                            *p_err = OS_ERR_SCHED_LOCKED;                 /* ... can't PEND when locked                   */
;;;452                             return ((OS_FLAGS)0);
;;;453                         }
;;;454                     }
;;;455                                                                
;;;456                     OS_CRITICAL_ENTER_CPU_CRITICAL_EXIT();     /* Lock the scheduler/re-enable interrupts                */
;;;457                     OS_FlagBlock(&pend_data,
;;;458                                  p_grp,
;;;459                                  flags,
;;;460                                  opt,
;;;461                                  timeout);
;;;462                     OS_CRITICAL_EXIT_NO_SCHED();
;;;463                 }
;;;464                 break;
;;;465    
;;;466    #if OS_CFG_FLAG_MODE_CLR_EN > 0u
;;;467            case OS_OPT_PEND_FLAG_CLR_ALL:                      /* See if all required flags are cleared                  */
;;;468                 flags_rdy = (OS_FLAGS)(~p_grp->Flags & flags); /* Extract only the bits we want                          */
;;;469                 if (flags_rdy == flags) {                      /* Must match ALL the bits that we want                   */
;;;470                     if (consume == DEF_TRUE) {                 /* See if we need to consume the flags                    */
;;;471                         p_grp->Flags |= flags_rdy;             /* Set ONLY the flags that we wanted                      */
;;;472                     }
;;;473                     OSTCBCurPtr->FlagsRdy = flags_rdy;         /* Save flags that were ready                             */
;;;474                     if (p_ts != (CPU_TS *)0) {
;;;475                        *p_ts  = p_grp->TS;
;;;476                     }
;;;477                     CPU_CRITICAL_EXIT();                       /* Yes, condition met, return to caller                   */
;;;478                    *p_err = OS_ERR_NONE;
;;;479                     return (flags_rdy);
;;;480                 } else {                                       /* Block task until events occur or timeout               */
;;;481                     if ((opt & OS_OPT_PEND_NON_BLOCKING) != (OS_OPT)0) {
;;;482                         CPU_CRITICAL_EXIT();
;;;483                        *p_err = OS_ERR_PEND_WOULD_BLOCK;       /* Specified non-blocking so task would block             */
;;;484                         return ((OS_FLAGS)0);
;;;485                     } else {                                   /* Specified blocking so check is scheduler is locked     */
;;;486                         if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) { /* See if called with scheduler locked ...      */
;;;487                             CPU_CRITICAL_EXIT();
;;;488                            *p_err = OS_ERR_SCHED_LOCKED;                 /* ... can't PEND when locked                   */
;;;489                             return ((OS_FLAGS)0);
;;;490                         }
;;;491                     }
;;;492                                                                
;;;493                     OS_CRITICAL_ENTER_CPU_CRITICAL_EXIT();     /* Lock the scheduler/re-enable interrupts                */
;;;494                     OS_FlagBlock(&pend_data,
;;;495                                  p_grp,
;;;496                                  flags,
;;;497                                  opt,
;;;498                                  timeout);
;;;499                     OS_CRITICAL_EXIT_NO_SCHED();
;;;500                 }
;;;501                 break;
;;;502    
;;;503            case OS_OPT_PEND_FLAG_CLR_ANY:
;;;504                 flags_rdy = (OS_FLAGS)(~p_grp->Flags & flags); /* Extract only the bits we want                          */
;;;505                 if (flags_rdy != (OS_FLAGS)0) {                /* See if any flag cleared                                */
;;;506                     if (consume == DEF_TRUE) {                 /* See if we need to consume the flags                    */
;;;507                         p_grp->Flags |= flags_rdy;             /* Set ONLY the flags that we got                         */
;;;508                     }
;;;509                     OSTCBCurPtr->FlagsRdy = flags_rdy;         /* Save flags that were ready                             */
;;;510                     if (p_ts != (CPU_TS *)0) {
;;;511                        *p_ts  = p_grp->TS;
;;;512                     }
;;;513                     CPU_CRITICAL_EXIT();                       /* Yes, condition met, return to caller                   */
0000de  f7fffffe          BL       CPU_SR_Restore
;;;514                    *p_err = OS_ERR_NONE;
0000e2  f8a4b000          STRH     r11,[r4,#0]
;;;515                     return (flags_rdy);
0000e6  4650              MOV      r0,r10
                  |L3.232|
;;;516                 } else {                                       /* Block task until events occur or timeout               */
;;;517                     if ((opt & OS_OPT_PEND_NON_BLOCKING) != (OS_OPT)0) {
;;;518                         CPU_CRITICAL_EXIT();
;;;519                        *p_err = OS_ERR_PEND_WOULD_BLOCK;       /* Specified non-blocking so task would block             */
;;;520                         return ((OS_FLAGS)0);
;;;521                     } else {                                   /* Specified blocking so check is scheduler is locked     */
;;;522                         if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) { /* See if called with scheduler locked ...      */
;;;523                             CPU_CRITICAL_EXIT();
;;;524                            *p_err = OS_ERR_SCHED_LOCKED;                 /* ... can't PEND when locked                   */
;;;525                             return ((OS_FLAGS)0);
;;;526                         }
;;;527                     }
;;;528                                                                
;;;529                     OS_CRITICAL_ENTER_CPU_CRITICAL_EXIT();     /* Lock the scheduler/re-enable interrupts                */
;;;530                     OS_FlagBlock(&pend_data,
;;;531                                  p_grp,
;;;532                                  flags,
;;;533                                  opt,
;;;534                                  timeout);
;;;535                     OS_CRITICAL_EXIT_NO_SCHED();
;;;536                 }
;;;537                 break;
;;;538    #endif
;;;539    
;;;540            default:
;;;541                 CPU_CRITICAL_EXIT();
;;;542                *p_err = OS_ERR_OPT_INVALID;
;;;543                 return ((OS_FLAGS)0);
;;;544        }
;;;545    
;;;546        OSSched();                                              /* Find next HPT ready to run                             */
;;;547    
;;;548        CPU_CRITICAL_ENTER();
;;;549        switch (OSTCBCurPtr->PendStatus) {
;;;550            case OS_STATUS_PEND_OK:                             /* We got the vent flags                                  */
;;;551                 if (p_ts != (CPU_TS *)0) {
;;;552                    *p_ts  = OSTCBCurPtr->TS;
;;;553                 }
;;;554                *p_err = OS_ERR_NONE;
;;;555                 break;
;;;556    
;;;557            case OS_STATUS_PEND_ABORT:                          /* Indicate that we aborted                               */
;;;558                 if (p_ts != (CPU_TS *)0) {
;;;559                    *p_ts  = OSTCBCurPtr->TS;
;;;560                 }
;;;561                 CPU_CRITICAL_EXIT();
;;;562                *p_err = OS_ERR_PEND_ABORT;
;;;563                 return ((OS_FLAGS)0);
;;;564    
;;;565            case OS_STATUS_PEND_TIMEOUT:                        /* Indicate that we didn't get semaphore within timeout   */
;;;566                 if (p_ts != (CPU_TS *)0) {
;;;567                    *p_ts  = (CPU_TS  )0;
;;;568                 }
;;;569                 CPU_CRITICAL_EXIT();
;;;570                *p_err = OS_ERR_TIMEOUT;
;;;571                 return ((OS_FLAGS)0);
;;;572    
;;;573            case OS_STATUS_PEND_DEL:                            /* Indicate that object pended on has been deleted        */
;;;574                 if (p_ts != (CPU_TS *)0) {
;;;575                    *p_ts  = OSTCBCurPtr->TS;
;;;576                 }
;;;577                 CPU_CRITICAL_EXIT();
;;;578                *p_err = OS_ERR_OBJ_DEL;
;;;579                 return ((OS_FLAGS)0);
;;;580    
;;;581            default:
;;;582                 CPU_CRITICAL_EXIT();
;;;583                *p_err = OS_ERR_STATUS_INVALID;
;;;584                 return ((OS_FLAGS)0);
;;;585        }
;;;586    
;;;587        flags_rdy = OSTCBCurPtr->FlagsRdy;
;;;588        if (consume == DEF_TRUE) {                              /* See if we need to consume the flags                    */
;;;589            switch (mode) {
;;;590                case OS_OPT_PEND_FLAG_SET_ALL:
;;;591                case OS_OPT_PEND_FLAG_SET_ANY:                  /* Clear ONLY the flags we got                            */
;;;592                     p_grp->Flags &= ~flags_rdy;
;;;593                     break;
;;;594    
;;;595    #if OS_CFG_FLAG_MODE_CLR_EN > 0u
;;;596                case OS_OPT_PEND_FLAG_CLR_ALL:
;;;597                case OS_OPT_PEND_FLAG_CLR_ANY:                  /* Set   ONLY the flags we got                            */
;;;598                     p_grp->Flags |=  flags_rdy;
;;;599                     break;
;;;600    #endif
;;;601                default:
;;;602                     CPU_CRITICAL_EXIT();
;;;603                    *p_err = OS_ERR_OPT_INVALID;
;;;604                     return ((OS_FLAGS)0);
;;;605            }
;;;606        }
;;;607        CPU_CRITICAL_EXIT();
;;;608       *p_err = OS_ERR_NONE;                                    /* Event(s) must have occurred                            */
;;;609        return (flags_rdy);
;;;610    }
0000e8  b00f              ADD      sp,sp,#0x3c
0000ea  e8bd8ff0          POP      {r4-r11,pc}
                  |L3.238|
0000ee  043a              LSLS     r2,r7,#16             ;408
0000f0  d525              BPL      |L3.318|
0000f2  f7fffffe          BL       CPU_SR_Restore
0000f6  f24610b0          MOV      r0,#0x61b0            ;410
0000fa  e079              B        |L3.496|
                  |L3.252|
0000fc  f7fffffe          BL       CPU_SR_Restore
000100  f6465063          MOV      r0,#0x6d63            ;415
000104  e074              B        |L3.496|
                  |L3.262|
000106  6a2a              LDR      r2,[r5,#0x20]         ;431
000108  ea120a09          ANDS     r10,r2,r9             ;431
00010c  d0ef              BEQ      |L3.238|
                  |L3.270|
00010e  f1b80f01          CMP      r8,#1                 ;433
000112  d1dd              BNE      |L3.208|
000114  ea22020a          BIC      r2,r2,r10             ;434
000118  622a              STR      r2,[r5,#0x20]         ;434
00011a  e7d9              B        |L3.208|
                  |L3.284|
00011c  6a2b              LDR      r3,[r5,#0x20]         ;468
00011e  ea290a03          BIC      r10,r9,r3             ;468
000122  45ca              CMP      r10,r9                ;469
000124  d004              BEQ      |L3.304|
000126  e7e2              B        |L3.238|
                  |L3.296|
000128  6a2b              LDR      r3,[r5,#0x20]         ;504
00012a  ea390a03          BICS     r10,r9,r3             ;504
00012e  d0de              BEQ      |L3.238|
                  |L3.304|
000130  f1b80f01          CMP      r8,#1                 ;506
000134  d1cc              BNE      |L3.208|
000136  ea43030a          ORR      r3,r3,r10             ;507
00013a  622b              STR      r3,[r5,#0x20]         ;507
00013c  e7c8              B        |L3.208|
                  |L3.318|
00013e  780a              LDRB     r2,[r1,#0]            ;522  ; OSSchedLockNestingCtr
000140  2a00              CMP      r2,#0                 ;522
000142  d1db              BNE      |L3.252|
000144  468a              MOV      r10,r1                ;529
000146  f881e000          STRB     lr,[r1,#0]            ;529
00014a  f7fffffe          BL       CPU_SR_Restore
00014e  980d              LDR      r0,[sp,#0x34]         ;530
000150  9000              STR      r0,[sp,#0]            ;530
000152  463b              MOV      r3,r7                 ;530
000154  464a              MOV      r2,r9                 ;530
000156  4629              MOV      r1,r5                 ;530
000158  a801              ADD      r0,sp,#4              ;530
00015a  f7fffffe          BL       OS_FlagBlock
00015e  f7fffffe          BL       CPU_SR_Save
000162  f89a1000          LDRB     r1,[r10,#0]           ;535  ; OSSchedLockNestingCtr
000166  1e49              SUBS     r1,r1,#1              ;535
000168  f88a1000          STRB     r1,[r10,#0]           ;535
00016c  f7fffffe          BL       CPU_SR_Restore
000170  f7fffffe          BL       OSSched
000174  f7fffffe          BL       CPU_SR_Save
000178  492d              LDR      r1,|L3.560|
00017a  4602              MOV      r2,r0                 ;548
00017c  6808              LDR      r0,[r1,#0]            ;549  ; OSTCBCurPtr
00017e  f8903035          LDRB     r3,[r0,#0x35]         ;549
000182  b173              CBZ      r3,|L3.418|
000184  2b01              CMP      r3,#1                 ;549
000186  d019              BEQ      |L3.444|
000188  2b02              CMP      r3,#2                 ;549
00018a  d029              BEQ      |L3.480|
00018c  2b03              CMP      r3,#3                 ;549
00018e  d01e              BEQ      |L3.462|
000190  4610              MOV      r0,r2                 ;582
000192  f7fffffe          BL       CPU_SR_Restore
000196  f646602e          MOV      r0,#0x6e2e            ;583
00019a  e029              B        |L3.496|
                  |L3.412|
00019c  f7fffffe          BL       CPU_SR_Restore
0001a0  e769              B        |L3.118|
                  |L3.418|
0001a2  b10e              CBZ      r6,|L3.424|
0001a4  6c00              LDR      r0,[r0,#0x40]         ;552
0001a6  6030              STR      r0,[r6,#0]            ;552
                  |L3.424|
0001a8  f8a4b000          STRH     r11,[r4,#0]           ;554
0001ac  6808              LDR      r0,[r1,#0]            ;587  ; OSTCBCurPtr
0001ae  465f              MOV      r7,r11                ;554
0001b0  f1b80f01          CMP      r8,#1                 ;588
0001b4  f8d06084          LDR      r6,[r0,#0x84]         ;588
0001b8  d01d              BEQ      |L3.502|
0001ba  e02d              B        |L3.536|
                  |L3.444|
0001bc  b10e              CBZ      r6,|L3.450|
0001be  6c00              LDR      r0,[r0,#0x40]         ;559
0001c0  6030              STR      r0,[r6,#0]            ;559
                  |L3.450|
0001c2  4610              MOV      r0,r2                 ;561
0001c4  f7fffffe          BL       CPU_SR_Restore
0001c8  f24610a9          MOV      r0,#0x61a9            ;562
0001cc  e010              B        |L3.496|
                  |L3.462|
0001ce  b10e              CBZ      r6,|L3.468|
0001d0  f8c6b000          STR      r11,[r6,#0]           ;567
                  |L3.468|
0001d4  4610              MOV      r0,r2                 ;569
0001d6  f7fffffe          BL       CPU_SR_Restore
0001da  f24720d9          MOV      r0,#0x72d9            ;570
0001de  e007              B        |L3.496|
                  |L3.480|
0001e0  b10e              CBZ      r6,|L3.486|
0001e2  6c00              LDR      r0,[r0,#0x40]         ;575
0001e4  6030              STR      r0,[r6,#0]            ;575
                  |L3.486|
0001e6  4610              MOV      r0,r2                 ;577
0001e8  f7fffffe          BL       CPU_SR_Restore
0001ec  f64550c2          MOV      r0,#0x5dc2            ;578
                  |L3.496|
0001f0  8020              STRH     r0,[r4,#0]            ;603
0001f2  2000              MOVS     r0,#0                 ;604
0001f4  e778              B        |L3.232|
                  |L3.502|
0001f6  9809              LDR      r0,[sp,#0x24]         ;589
0001f8  2801              CMP      r0,#1                 ;589
0001fa  d00a              BEQ      |L3.530|
0001fc  2802              CMP      r0,#2                 ;589
0001fe  d008              BEQ      |L3.530|
000200  2804              CMP      r0,#4                 ;589
000202  d003              BEQ      |L3.524|
000204  2808              CMP      r0,#8                 ;589
000206  d001              BEQ      |L3.524|
000208  4610              MOV      r0,r2                 ;602
00020a  e7c7              B        |L3.412|
                  |L3.524|
00020c  6a28              LDR      r0,[r5,#0x20]         ;592
00020e  43b0              BICS     r0,r0,r6              ;592
000210  e001              B        |L3.534|
                  |L3.530|
000212  6a28              LDR      r0,[r5,#0x20]         ;598
000214  4330              ORRS     r0,r0,r6              ;598
                  |L3.534|
000216  6228              STR      r0,[r5,#0x20]         ;598
                  |L3.536|
000218  4610              MOV      r0,r2                 ;607
00021a  f7fffffe          BL       CPU_SR_Restore
00021e  8027              STRH     r7,[r4,#0]            ;608
000220  4630              MOV      r0,r6                 ;609
000222  e761              B        |L3.232|
;;;611    
                          ENDP

                  |L3.548|
                          DCD      OSIntNestingCtr
                  |L3.552|
                          DCD      0x47414c46
                  |L3.556|
                          DCD      OSSchedLockNestingCtr
                  |L3.560|
                          DCD      OSTCBCurPtr

                          AREA ||i.OSFlagPendAbort||, CODE, READONLY, ALIGN=2

                  OSFlagPendAbort PROC
;;;646    #if OS_CFG_FLAG_PEND_ABORT_EN > 0u
;;;647    OS_OBJ_QTY  OSFlagPendAbort (OS_FLAG_GRP  *p_grp,
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;648                                 OS_OPT        opt,
;;;649                                 OS_ERR       *p_err)
;;;650    {
000004  4604              MOV      r4,r0
;;;651        OS_PEND_LIST  *p_pend_list;
;;;652        OS_TCB        *p_tcb;
;;;653        CPU_TS         ts;
;;;654        OS_OBJ_QTY     nbr_tasks;
;;;655        CPU_SR_ALLOC();
;;;656    
;;;657    
;;;658    
;;;659    #ifdef OS_SAFETY_CRITICAL
;;;660        if (p_err == (OS_ERR *)0) {
;;;661            OS_SAFETY_CRITICAL_EXCEPTION();
;;;662            return ((OS_OBJ_QTY)0u);
;;;663        }
;;;664    #endif
;;;665    
;;;666    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;667        if (OSIntNestingCtr > (OS_NESTING_CTR)0u) {             /* Not allowed to Pend Abort from an ISR                  */
000006  4830              LDR      r0,|L4.200|
000008  4688              MOV      r8,r1                 ;650
00000a  4615              MOV      r5,r2                 ;650
00000c  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
00000e  b110              CBZ      r0,|L4.22|
;;;668           *p_err = OS_ERR_PEND_ABORT_ISR;
000010  f24610aa          MOV      r0,#0x61aa
;;;669            return ((OS_OBJ_QTY)0u);
000014  e011              B        |L4.58|
                  |L4.22|
;;;670        }
;;;671    #endif
;;;672    
;;;673    #if OS_CFG_ARG_CHK_EN > 0u
;;;674        if (p_grp == (OS_FLAG_GRP *)0) {                        /* Validate 'p_grp'                                       */
000016  b174              CBZ      r4,|L4.54|
;;;675           *p_err  =  OS_ERR_OBJ_PTR_NULL;
;;;676            return ((OS_OBJ_QTY)0u);
;;;677        }
;;;678        switch (opt) {                                          /* Validate 'opt'                                         */
000018  0008              MOVS     r0,r1
00001a  f44f7a80          MOV      r10,#0x100
00001e  d00e              BEQ      |L4.62|
000020  4550              CMP      r0,r10
000022  d00c              BEQ      |L4.62|
000024  f5b04f00          CMP      r0,#0x8000
000028  d009              BEQ      |L4.62|
00002a  f5b14f01          CMP      r1,#0x8100
00002e  d006              BEQ      |L4.62|
;;;679            case OS_OPT_PEND_ABORT_1:
;;;680            case OS_OPT_PEND_ABORT_ALL:
;;;681            case OS_OPT_PEND_ABORT_1   | OS_OPT_POST_NO_SCHED:
;;;682            case OS_OPT_PEND_ABORT_ALL | OS_OPT_POST_NO_SCHED:
;;;683                 break;
;;;684    
;;;685            default:
;;;686                *p_err = OS_ERR_OPT_INVALID;
000030  f6456025          MOV      r0,#0x5e25
;;;687                 return ((OS_OBJ_QTY)0u);
000034  e001              B        |L4.58|
                  |L4.54|
000036  f64550c3          MOV      r0,#0x5dc3            ;675
                  |L4.58|
00003a  8010              STRH     r0,[r2,#0]            ;668
00003c  e022              B        |L4.132|
                  |L4.62|
;;;688        }
;;;689    #endif
;;;690    
;;;691    #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
;;;692        if (p_grp->Type != OS_OBJ_TYPE_FLAG) {                  /* Make sure event flag group was created                 */
00003e  4923              LDR      r1,|L4.204|
000040  6820              LDR      r0,[r4,#0]
000042  4288              CMP      r0,r1
000044  d002              BEQ      |L4.76|
;;;693           *p_err = OS_ERR_OBJ_TYPE;
000046  f64550c4          MOV      r0,#0x5dc4
;;;694            return ((OS_OBJ_QTY)0u);
00004a  e7f6              B        |L4.58|
                  |L4.76|
;;;695        }
;;;696    #endif
;;;697    
;;;698        CPU_CRITICAL_ENTER();
00004c  f7fffffe          BL       CPU_SR_Save
000050  4601              MOV      r1,r0
;;;699        p_pend_list = &p_grp->PendList;
;;;700        if (p_pend_list->NbrEntries == (OS_OBJ_QTY)0u) {        /* Any task waiting on flag group?                        */
000052  8a20              LDRH     r0,[r4,#0x10]
000054  f1040708          ADD      r7,r4,#8              ;699
000058  b170              CBZ      r0,|L4.120|
;;;701            CPU_CRITICAL_EXIT();                                /* No                                                     */
;;;702           *p_err = OS_ERR_PEND_ABORT_NONE;
;;;703            return ((OS_OBJ_QTY)0u);
;;;704        }
;;;705    
;;;706        OS_CRITICAL_ENTER_CPU_CRITICAL_EXIT();
00005a  f8df9074          LDR      r9,|L4.208|
00005e  4608              MOV      r0,r1
000060  f8992000          LDRB     r2,[r9,#0]  ; OSSchedLockNestingCtr
000064  1c52              ADDS     r2,r2,#1
000066  f8892000          STRB     r2,[r9,#0]
00006a  f7fffffe          BL       CPU_SR_Restore
;;;707        nbr_tasks = 0u;
00006e  2600              MOVS     r6,#0
;;;708        ts        = OS_TS_GET();                                /* Get local time stamp so all tasks get the same time    */
000070  f7fffffe          BL       CPU_TS_TmrRd
000074  4683              MOV      r11,r0
;;;709        while (p_pend_list->NbrEntries > (OS_OBJ_QTY)0u) {
000076  e012              B        |L4.158|
                  |L4.120|
000078  4608              MOV      r0,r1                 ;701
00007a  f7fffffe          BL       CPU_SR_Restore
00007e  f24610ab          MOV      r0,#0x61ab            ;702
000082  8028              STRH     r0,[r5,#0]            ;702
                  |L4.132|
000084  2000              MOVS     r0,#0                 ;703
                  |L4.134|
;;;710            p_tcb = p_pend_list->HeadPtr->TCBPtr;
;;;711            OS_PendAbort((OS_PEND_OBJ *)((void *)p_grp),
;;;712                         p_tcb,
;;;713                         ts);
;;;714            nbr_tasks++;
;;;715            if (opt != OS_OPT_PEND_ABORT_ALL) {                 /* Pend abort all tasks waiting?                          */
;;;716                break;                                          /* No                                                     */
;;;717            }
;;;718        }
;;;719        OS_CRITICAL_EXIT_NO_SCHED();
;;;720    
;;;721        if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0u) {
;;;722            OSSched();                                          /* Run the scheduler                                      */
;;;723        }
;;;724    
;;;725       *p_err = OS_ERR_NONE;
;;;726        return (nbr_tasks);
;;;727    }
000086  e8bd9ff0          POP      {r4-r12,pc}
                  |L4.138|
00008a  6838              LDR      r0,[r7,#0]            ;710
00008c  465a              MOV      r2,r11                ;711
00008e  6881              LDR      r1,[r0,#8]            ;711
000090  4620              MOV      r0,r4                 ;711
000092  f7fffffe          BL       OS_PendAbort
000096  1c76              ADDS     r6,r6,#1              ;714
000098  b2b6              UXTH     r6,r6                 ;714
00009a  45d0              CMP      r8,r10                ;715
00009c  d102              BNE      |L4.164|
                  |L4.158|
00009e  8938              LDRH     r0,[r7,#8]            ;709
0000a0  2800              CMP      r0,#0                 ;709
0000a2  d1f2              BNE      |L4.138|
                  |L4.164|
0000a4  f7fffffe          BL       CPU_SR_Save
0000a8  f8992000          LDRB     r2,[r9,#0]            ;719  ; OSSchedLockNestingCtr
0000ac  1e52              SUBS     r2,r2,#1              ;719
0000ae  f8892000          STRB     r2,[r9,#0]            ;719
0000b2  f7fffffe          BL       CPU_SR_Restore
0000b6  ea5f4008          LSLS     r0,r8,#16             ;721
0000ba  d401              BMI      |L4.192|
0000bc  f7fffffe          BL       OSSched
                  |L4.192|
0000c0  2000              MOVS     r0,#0                 ;725
0000c2  8028              STRH     r0,[r5,#0]            ;725
0000c4  4630              MOV      r0,r6                 ;726
0000c6  e7de              B        |L4.134|
;;;728    #endif
                          ENDP

                  |L4.200|
                          DCD      OSIntNestingCtr
                  |L4.204|
                          DCD      0x47414c46
                  |L4.208|
                          DCD      OSSchedLockNestingCtr

                          AREA ||i.OSFlagPendGetFlagsRdy||, CODE, READONLY, ALIGN=2

                  OSFlagPendGetFlagsRdy PROC
;;;746    
;;;747    OS_FLAGS  OSFlagPendGetFlagsRdy (OS_ERR  *p_err)
000000  b570              PUSH     {r4-r6,lr}
;;;748    {
000002  4604              MOV      r4,r0
;;;749        OS_FLAGS   flags;
;;;750        CPU_SR_ALLOC();
;;;751    
;;;752    
;;;753    
;;;754    #ifdef OS_SAFETY_CRITICAL
;;;755        if (p_err == (OS_ERR *)0) {
;;;756            OS_SAFETY_CRITICAL_EXCEPTION();
;;;757            return ((OS_FLAGS)0);
;;;758        }
;;;759    #endif
;;;760    
;;;761    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;762        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from ISR ...                             */
000004  4809              LDR      r0,|L5.44|
000006  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
000008  b120              CBZ      r0,|L5.20|
;;;763           *p_err = OS_ERR_PEND_ISR;                            /* ... can't get from an ISR                              */
00000a  f24610ae          MOV      r0,#0x61ae
00000e  8020              STRH     r0,[r4,#0]
;;;764            return ((OS_FLAGS)0);
000010  2000              MOVS     r0,#0
;;;765        }
;;;766    #endif
;;;767    
;;;768        CPU_CRITICAL_ENTER();
;;;769        flags = OSTCBCurPtr->FlagsRdy;
;;;770        CPU_CRITICAL_EXIT();
;;;771       *p_err = OS_ERR_NONE;
;;;772        return (flags);
;;;773    }
000012  bd70              POP      {r4-r6,pc}
                  |L5.20|
000014  f7fffffe          BL       CPU_SR_Save
000018  4905              LDR      r1,|L5.48|
00001a  6809              LDR      r1,[r1,#0]            ;769  ; OSTCBCurPtr
00001c  f8d15084          LDR      r5,[r1,#0x84]         ;770
000020  f7fffffe          BL       CPU_SR_Restore
000024  2000              MOVS     r0,#0                 ;771
000026  8020              STRH     r0,[r4,#0]            ;771
000028  4628              MOV      r0,r5                 ;772
00002a  bd70              POP      {r4-r6,pc}
;;;774    
                          ENDP

                  |L5.44|
                          DCD      OSIntNestingCtr
                  |L5.48|
                          DCD      OSTCBCurPtr

                          AREA ||i.OSFlagPost||, CODE, READONLY, ALIGN=2

                  OSFlagPost PROC
;;;816    
;;;817    OS_FLAGS  OSFlagPost (OS_FLAG_GRP  *p_grp,
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;818                          OS_FLAGS      flags,
;;;819                          OS_OPT        opt,
;;;820                          OS_ERR       *p_err)
;;;821    {
000004  4616              MOV      r6,r2
000006  4688              MOV      r8,r1
000008  0005              MOVS     r5,r0
00000a  461c              MOV      r4,r3
00000c  d00d              BEQ      |L6.42|
;;;822        OS_FLAGS  flags_cur;
;;;823        CPU_TS    ts;
;;;824    
;;;825    
;;;826    
;;;827    #ifdef OS_SAFETY_CRITICAL
;;;828        if (p_err == (OS_ERR *)0) {
;;;829            OS_SAFETY_CRITICAL_EXCEPTION();
;;;830            return ((OS_FLAGS)0);
;;;831        }
;;;832    #endif
;;;833    
;;;834    #if OS_CFG_ARG_CHK_EN > 0u
;;;835        if (p_grp == (OS_FLAG_GRP *)0) {                        /* Validate 'p_grp'                                       */
;;;836           *p_err  = OS_ERR_OBJ_PTR_NULL;
;;;837            return ((OS_FLAGS)0);
;;;838        }
;;;839        switch (opt) {                                          /* Validate 'opt'                                         */
00000e  b17e              CBZ      r6,|L6.48|
000010  2e01              CMP      r6,#1
000012  d00d              BEQ      |L6.48|
000014  f5b64f00          CMP      r6,#0x8000
000018  d00a              BEQ      |L6.48|
00001a  f46f4000          MVN      r0,#0x8000
00001e  1830              ADDS     r0,r6,r0
000020  d006              BEQ      |L6.48|
;;;840            case OS_OPT_POST_FLAG_SET:
;;;841            case OS_OPT_POST_FLAG_CLR:
;;;842            case OS_OPT_POST_FLAG_SET | OS_OPT_POST_NO_SCHED:
;;;843            case OS_OPT_POST_FLAG_CLR | OS_OPT_POST_NO_SCHED:
;;;844                 break;
;;;845    
;;;846            default:
;;;847                *p_err = OS_ERR_OPT_INVALID;
000022  f6456025          MOV      r0,#0x5e25
                  |L6.38|
000026  8018              STRH     r0,[r3,#0]            ;836
000028  e019              B        |L6.94|
                  |L6.42|
00002a  f64550c3          MOV      r0,#0x5dc3            ;836
00002e  e7fa              B        |L6.38|
                  |L6.48|
;;;848                 return ((OS_FLAGS)0);
;;;849        }
;;;850    #endif
;;;851    
;;;852    #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
;;;853        if (p_grp->Type != OS_OBJ_TYPE_FLAG) {                  /* Make sure we are pointing to an event flag grp         */
000030  4f10              LDR      r7,|L6.116|
000032  6828              LDR      r0,[r5,#0]
000034  42b8              CMP      r0,r7
000036  d002              BEQ      |L6.62|
;;;854           *p_err = OS_ERR_OBJ_TYPE;
000038  f64550c4          MOV      r0,#0x5dc4
;;;855            return ((OS_FLAGS)0);
00003c  e7f3              B        |L6.38|
                  |L6.62|
;;;856        }
;;;857    #endif
;;;858    
;;;859        ts = OS_TS_GET();                                       /* Get timestamp                                          */
00003e  f7fffffe          BL       CPU_TS_TmrRd
000042  4603              MOV      r3,r0
;;;860    #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
;;;861        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from an ISR                              */
000044  480c              LDR      r0,|L6.120|
000046  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
000048  b168              CBZ      r0,|L6.102|
00004a  e9cd3402          STRD     r3,r4,[sp,#8]
;;;862            OS_IntQPost((OS_OBJ_TYPE)OS_OBJ_TYPE_FLAG,          /* Post to ISR queue                                      */
00004e  e9cd8600          STRD     r8,r6,[sp,#0]
000052  2300              MOVS     r3,#0
000054  461a              MOV      r2,r3
000056  4629              MOV      r1,r5
000058  4638              MOV      r0,r7
00005a  f7fffffe          BL       OS_IntQPost
                  |L6.94|
;;;863                        (void      *)p_grp,
;;;864                        (void      *)0,
;;;865                        (OS_MSG_SIZE)0,
;;;866                        (OS_FLAGS   )flags,
;;;867                        (OS_OPT     )opt,
;;;868                        (CPU_TS     )ts,
;;;869                        (OS_ERR    *)p_err);
;;;870            return ((OS_FLAGS)0);
00005e  2000              MOVS     r0,#0
                  |L6.96|
;;;871        }
;;;872    #endif
;;;873    
;;;874        flags_cur = OS_FlagPost(p_grp,
;;;875                                flags,
;;;876                                opt,
;;;877                                ts,
;;;878                                p_err);
;;;879    
;;;880        return (flags_cur);
;;;881    }
000060  b004              ADD      sp,sp,#0x10
000062  e8bd81f0          POP      {r4-r8,pc}
                  |L6.102|
000066  4632              MOV      r2,r6                 ;874
000068  4641              MOV      r1,r8                 ;874
00006a  4628              MOV      r0,r5                 ;874
00006c  9400              STR      r4,[sp,#0]            ;874
00006e  f7fffffe          BL       OS_FlagPost
000072  e7f5              B        |L6.96|
;;;882    
                          ENDP

                  |L6.116|
                          DCD      0x47414c46
                  |L6.120|
                          DCD      OSIntNestingCtr

                          AREA ||i.OS_FlagBlock||, CODE, READONLY, ALIGN=2

                  OS_FlagBlock PROC
;;;919    
;;;920    void  OS_FlagBlock (OS_PEND_DATA  *p_pend_data,
000000  b430              PUSH     {r4,r5}
;;;921                        OS_FLAG_GRP   *p_grp,
;;;922                        OS_FLAGS       flags,
;;;923                        OS_OPT         opt,
;;;924                        OS_TICK        timeout)
;;;925    {
;;;926        OSTCBCurPtr->FlagsPend = flags;                         /* Save the flags that we need to wait for                */
000002  4c06              LDR      r4,|L7.28|
000004  9d02              LDR      r5,[sp,#8]
000006  6824              LDR      r4,[r4,#0]  ; OSTCBCurPtr
000008  f8442f80          STR      r2,[r4,#0x80]!
;;;927        OSTCBCurPtr->FlagsOpt  = opt;                           /* Save the type of wait we are doing                     */
;;;928        OSTCBCurPtr->FlagsRdy  = (OS_FLAGS)0;
00000c  2200              MOVS     r2,#0
00000e  8123              STRH     r3,[r4,#8]            ;927
;;;929    
;;;930        OS_Pend(p_pend_data,
000010  6062              STR      r2,[r4,#4]
000012  462b              MOV      r3,r5
000014  bc30              POP      {r4,r5}
000016  2201              MOVS     r2,#1
000018  f7ffbffe          B.W      OS_Pend
;;;931                (OS_PEND_OBJ *)((void *)p_grp),
;;;932                 OS_TASK_PEND_ON_FLAG,
;;;933                 timeout);
;;;934    }
;;;935    
                          ENDP

                  |L7.28|
                          DCD      OSTCBCurPtr

                          AREA ||i.OS_FlagClr||, CODE, READONLY, ALIGN=2

                  OS_FlagClr PROC
;;;952    
;;;953    void  OS_FlagClr (OS_FLAG_GRP  *p_grp)
000000  4904              LDR      r1,|L8.20|
;;;954    {
;;;955        OS_PEND_LIST  *p_pend_list;
;;;956    
;;;957    
;;;958    
;;;959        p_grp->Type             = OS_OBJ_TYPE_NONE;
;;;960        p_grp->NamePtr          = (CPU_CHAR *)((void *)"?FLAG");    /* Unknown name                                       */
000002  6001              STR      r1,[r0,#0]
000004  4904              LDR      r1,|L8.24|
;;;961        p_grp->Flags            = (OS_FLAGS )0;
000006  6041              STR      r1,[r0,#4]
000008  2100              MOVS     r1,#0
;;;962        p_pend_list             = &p_grp->PendList;
00000a  6201              STR      r1,[r0,#0x20]
00000c  3008              ADDS     r0,r0,#8
;;;963        OS_PendListInit(p_pend_list);
00000e  f7ffbffe          B.W      OS_PendListInit
;;;964    }
;;;965    
                          ENDP

000012  0000              DCW      0x0000
                  |L8.20|
                          DCD      0x454e4f4e
                  |L8.24|
                          DCD      ||.constdata||

                          AREA ||i.OS_FlagDbgListAdd||, CODE, READONLY, ALIGN=2

                  OS_FlagDbgListAdd PROC
;;;1017   #if OS_CFG_DBG_EN > 0u
;;;1018   void  OS_FlagDbgListAdd (OS_FLAG_GRP  *p_grp)
000000  2200              MOVS     r2,#0
;;;1019   {
;;;1020       p_grp->DbgNamePtr                = (CPU_CHAR    *)((void *)" ");
;;;1021       p_grp->DbgPrevPtr                = (OS_FLAG_GRP *)0;
;;;1022       if (OSFlagDbgListPtr == (OS_FLAG_GRP *)0) {
000002  4b07              LDR      r3,|L9.32|
000004  a105              ADR      r1,|L9.28|
000006  6142              STR      r2,[r0,#0x14]
000008  61c1              STR      r1,[r0,#0x1c]
00000a  6819              LDR      r1,[r3,#0]            ;1019  ; OSFlagDbgListPtr
00000c  b119              CBZ      r1,|L9.22|
;;;1023           p_grp->DbgNextPtr            = (OS_FLAG_GRP *)0;
;;;1024       } else {
;;;1025           p_grp->DbgNextPtr            =  OSFlagDbgListPtr;
;;;1026           OSFlagDbgListPtr->DbgPrevPtr =  p_grp;
00000e  6181              STR      r1,[r0,#0x18]
000010  6148              STR      r0,[r1,#0x14]
                  |L9.18|
;;;1027       }
;;;1028       OSFlagDbgListPtr                 =  p_grp;
;;;1029   }
000012  6018              STR      r0,[r3,#0]  ; OSFlagDbgListPtr
000014  4770              BX       lr
                  |L9.22|
000016  6182              STR      r2,[r0,#0x18]         ;1023
000018  e7fb              B        |L9.18|
;;;1030   
                          ENDP

00001a  0000              DCW      0x0000
                  |L9.28|
00001c  2000              DCB      " ",0
00001e  00                DCB      0
00001f  00                DCB      0
                  |L9.32|
                          DCD      OSFlagDbgListPtr

                          AREA ||i.OS_FlagDbgListRemove||, CODE, READONLY, ALIGN=2

                  OS_FlagDbgListRemove PROC
;;;1032   
;;;1033   void  OS_FlagDbgListRemove (OS_FLAG_GRP  *p_grp)
000000  e9d02105          LDRD     r2,r1,[r0,#0x14]
;;;1034   {
000004  2300              MOVS     r3,#0
000006  b12a              CBZ      r2,|L10.20|
;;;1035       OS_FLAG_GRP  *p_grp_next;
;;;1036       OS_FLAG_GRP  *p_grp_prev;
;;;1037   
;;;1038   
;;;1039       p_grp_prev = p_grp->DbgPrevPtr;
;;;1040       p_grp_next = p_grp->DbgNextPtr;
;;;1041   
;;;1042       if (p_grp_prev == (OS_FLAG_GRP *)0) {
;;;1043           OSFlagDbgListPtr = p_grp_next;
;;;1044           if (p_grp_next != (OS_FLAG_GRP *)0) {
;;;1045               p_grp_next->DbgPrevPtr = (OS_FLAG_GRP *)0;
;;;1046           }
;;;1047           p_grp->DbgNextPtr = (OS_FLAG_GRP *)0;
;;;1048   
;;;1049       } else if (p_grp_next == (OS_FLAG_GRP *)0) {
000008  b151              CBZ      r1,|L10.32|
;;;1050           p_grp_prev->DbgNextPtr = (OS_FLAG_GRP *)0;
;;;1051           p_grp->DbgPrevPtr      = (OS_FLAG_GRP *)0;
;;;1052   
;;;1053       } else {
;;;1054           p_grp_prev->DbgNextPtr =  p_grp_next;
;;;1055           p_grp_next->DbgPrevPtr =  p_grp_prev;
00000a  6191              STR      r1,[r2,#0x18]
;;;1056           p_grp->DbgNextPtr      = (OS_FLAG_GRP *)0;
00000c  614a              STR      r2,[r1,#0x14]
00000e  6183              STR      r3,[r0,#0x18]
                  |L10.16|
;;;1057           p_grp->DbgPrevPtr      = (OS_FLAG_GRP *)0;
000010  6143              STR      r3,[r0,#0x14]
;;;1058       }
;;;1059   }
000012  4770              BX       lr
                  |L10.20|
000014  4a03              LDR      r2,|L10.36|
000016  6011              STR      r1,[r2,#0]            ;1044  ; OSFlagDbgListPtr
000018  b101              CBZ      r1,|L10.28|
00001a  614b              STR      r3,[r1,#0x14]         ;1045
                  |L10.28|
00001c  6183              STR      r3,[r0,#0x18]         ;1047
00001e  4770              BX       lr
                  |L10.32|
000020  6193              STR      r3,[r2,#0x18]         ;1051
000022  e7f5              B        |L10.16|
;;;1060   #endif
                          ENDP

                  |L10.36|
                          DCD      OSFlagDbgListPtr

                          AREA ||i.OS_FlagInit||, CODE, READONLY, ALIGN=2

                  OS_FlagInit PROC
;;;983    
;;;984    void  OS_FlagInit (OS_ERR  *p_err)
000000  4a03              LDR      r2,|L11.16|
;;;985    {
;;;986    #ifdef OS_SAFETY_CRITICAL
;;;987        if (p_err == (OS_ERR *)0) {
;;;988            OS_SAFETY_CRITICAL_EXCEPTION();
;;;989            return;
;;;990        }
;;;991    #endif
;;;992    
;;;993    #if OS_CFG_DBG_EN > 0u
;;;994        OSFlagDbgListPtr = (OS_FLAG_GRP *)0;
000002  2100              MOVS     r1,#0
;;;995    #endif
;;;996    
;;;997        OSFlagQty        = (OS_OBJ_QTY   )0;
000004  6011              STR      r1,[r2,#0]  ; OSFlagDbgListPtr
000006  4a03              LDR      r2,|L11.20|
000008  8011              STRH     r1,[r2,#0]
;;;998       *p_err            = OS_ERR_NONE;
00000a  8001              STRH     r1,[r0,#0]
;;;999    }
00000c  4770              BX       lr
;;;1000   
                          ENDP

00000e  0000              DCW      0x0000
                  |L11.16|
                          DCD      OSFlagDbgListPtr
                  |L11.20|
                          DCD      OSFlagQty

                          AREA ||i.OS_FlagPost||, CODE, READONLY, ALIGN=2

                  OS_FlagPost PROC
;;;1105   
;;;1106   OS_FLAGS  OS_FlagPost (OS_FLAG_GRP  *p_grp,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1107                          OS_FLAGS      flags,
;;;1108                          OS_OPT        opt,
;;;1109                          CPU_TS        ts,
;;;1110                          OS_ERR       *p_err)
;;;1111   {
000004  4690              MOV      r8,r2
000006  469a              MOV      r10,r3
000008  460d              MOV      r5,r1
00000a  4604              MOV      r4,r0
;;;1112       OS_FLAGS        flags_cur;
;;;1113       OS_FLAGS        flags_rdy;
;;;1114       OS_OPT          mode;
;;;1115       OS_PEND_DATA   *p_pend_data;
;;;1116       OS_PEND_DATA   *p_pend_data_next;
;;;1117       OS_PEND_LIST   *p_pend_list;
;;;1118       OS_TCB         *p_tcb;
;;;1119       CPU_SR_ALLOC();
;;;1120   
;;;1121   
;;;1122   
;;;1123       CPU_CRITICAL_ENTER();
00000c  9f08              LDR      r7,[sp,#0x20]
00000e  f7fffffe          BL       CPU_SR_Save
000012  4601              MOV      r1,r0
;;;1124       switch (opt) {
000014  ea5f0008          MOVS     r0,r8
000018  d00f              BEQ      |L12.58|
00001a  2801              CMP      r0,#1
00001c  d010              BEQ      |L12.64|
00001e  f5b04f00          CMP      r0,#0x8000
000022  d00a              BEQ      |L12.58|
000024  f46f4200          MVN      r2,#0x8000
000028  eb180002          ADDS     r0,r8,r2
00002c  d008              BEQ      |L12.64|
;;;1125           case OS_OPT_POST_FLAG_SET:
;;;1126           case OS_OPT_POST_FLAG_SET | OS_OPT_POST_NO_SCHED:
;;;1127                p_grp->Flags |=  flags;                            /* Set   the flags specified in the group             */
;;;1128                break;
;;;1129   
;;;1130           case OS_OPT_POST_FLAG_CLR:
;;;1131           case OS_OPT_POST_FLAG_CLR | OS_OPT_POST_NO_SCHED:
;;;1132                p_grp->Flags &= ~flags;                            /* Clear the flags specified in the group             */
;;;1133                break;
;;;1134   
;;;1135           default:
;;;1136                CPU_CRITICAL_EXIT();                               /* INVALID option                                     */
00002e  4608              MOV      r0,r1
000030  f7fffffe          BL       CPU_SR_Restore
;;;1137               *p_err = OS_ERR_OPT_INVALID;
000034  f6456025          MOV      r0,#0x5e25
;;;1138                return ((OS_FLAGS)0);
000038  e072              B        |L12.288|
                  |L12.58|
00003a  6a20              LDR      r0,[r4,#0x20]         ;1127
00003c  4328              ORRS     r0,r0,r5              ;1127
00003e  e001              B        |L12.68|
                  |L12.64|
000040  6a20              LDR      r0,[r4,#0x20]         ;1132
000042  43a8              BICS     r0,r0,r5              ;1132
                  |L12.68|
;;;1139       }
;;;1140       p_grp->TS   = ts;
;;;1141       p_pend_list = &p_grp->PendList;
;;;1142       if (p_pend_list->NbrEntries == 0u) {                        /* Any task waiting on event flag group?              */
000044  e9c40a08          STRD     r0,r10,[r4,#0x20]
000048  8a20              LDRH     r0,[r4,#0x10]
00004a  f1040608          ADD      r6,r4,#8              ;1141
00004e  f04f0900          MOV      r9,#0
000052  b140              CBZ      r0,|L12.102|
;;;1143           CPU_CRITICAL_EXIT();                                    /* No                                                 */
;;;1144          *p_err = OS_ERR_NONE;
;;;1145           return (p_grp->Flags);
;;;1146       }
;;;1147   
;;;1148       OS_CRITICAL_ENTER_CPU_CRITICAL_EXIT();
000054  4d34              LDR      r5,|L12.296|
000056  7828              LDRB     r0,[r5,#0]  ; OSSchedLockNestingCtr
000058  1c40              ADDS     r0,r0,#1
00005a  7028              STRB     r0,[r5,#0]
00005c  4608              MOV      r0,r1
00005e  f7fffffe          BL       CPU_SR_Restore
;;;1149       p_pend_data = p_pend_list->HeadPtr;
000062  6836              LDR      r6,[r6,#0]
;;;1150       p_tcb       = p_pend_data->TCBPtr;
;;;1151       while (p_tcb != (OS_TCB *)0) {                              /* Go through all tasks waiting on event flag(s)      */
000064  e038              B        |L12.216|
                  |L12.102|
000066  4608              MOV      r0,r1                 ;1143
000068  f7fffffe          BL       CPU_SR_Restore
00006c  f8a79000          STRH     r9,[r7,#0]            ;1144
000070  6a20              LDR      r0,[r4,#0x20]         ;1145
                  |L12.114|
;;;1152           p_pend_data_next = p_pend_data->NextPtr;
;;;1153           mode             = p_tcb->FlagsOpt & OS_OPT_PEND_FLAG_MASK;
;;;1154           switch (mode) {
;;;1155               case OS_OPT_PEND_FLAG_SET_ALL:                      /* See if all req. flags are set for current node     */
;;;1156                    flags_rdy = (OS_FLAGS)(p_grp->Flags & p_tcb->FlagsPend);
;;;1157                    if (flags_rdy == p_tcb->FlagsPend) {
;;;1158                        OS_FlagTaskRdy(p_tcb,                      /* Make task RTR, event(s) Rx'd                       */
;;;1159                                       flags_rdy,
;;;1160                                       ts);
;;;1161                    }
;;;1162                    break;
;;;1163   
;;;1164               case OS_OPT_PEND_FLAG_SET_ANY:                      /* See if any flag set                                */
;;;1165                    flags_rdy = (OS_FLAGS)(p_grp->Flags & p_tcb->FlagsPend);
;;;1166                    if (flags_rdy != (OS_FLAGS)0) {
;;;1167                        OS_FlagTaskRdy(p_tcb,                      /* Make task RTR, event(s) Rx'd                       */
;;;1168                                       flags_rdy,
;;;1169                                       ts);
;;;1170                    }
;;;1171                    break;
;;;1172   
;;;1173   #if OS_CFG_FLAG_MODE_CLR_EN > 0u
;;;1174               case OS_OPT_PEND_FLAG_CLR_ALL:                      /* See if all req. flags are set for current node     */
;;;1175                    flags_rdy = (OS_FLAGS)(~p_grp->Flags & p_tcb->FlagsPend);
;;;1176                    if (flags_rdy == p_tcb->FlagsPend) {
;;;1177                        OS_FlagTaskRdy(p_tcb,                      /* Make task RTR, event(s) Rx'd                       */
;;;1178                                       flags_rdy,
;;;1179                                       ts);
;;;1180                    }
;;;1181                    break;
;;;1182   
;;;1183               case OS_OPT_PEND_FLAG_CLR_ANY:                      /* See if any flag set                                */
;;;1184                    flags_rdy = (OS_FLAGS)(~p_grp->Flags & p_tcb->FlagsPend);
;;;1185                    if (flags_rdy != (OS_FLAGS)0) {
;;;1186                        OS_FlagTaskRdy(p_tcb,                      /* Make task RTR, event(s) Rx'd                       */
;;;1187                                       flags_rdy,
;;;1188                                       ts);
;;;1189                    }
;;;1190                    break;
;;;1191   #endif
;;;1192               default:
;;;1193                    OS_CRITICAL_EXIT();
;;;1194                   *p_err = OS_ERR_FLAG_PEND_OPT;
;;;1195                    return ((OS_FLAGS)0);
;;;1196           }
;;;1197           p_pend_data = p_pend_data_next;                         /* Point to next task waiting for event flag(s)       */
;;;1198           if (p_pend_data != (OS_PEND_DATA *)0) {
;;;1199               p_tcb = p_pend_data->TCBPtr;
;;;1200           } else {
;;;1201               p_tcb = (OS_TCB *)0;
;;;1202           }
;;;1203       }
;;;1204       OS_CRITICAL_EXIT_NO_SCHED();
;;;1205   
;;;1206       if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0) {
;;;1207           OSSched();
;;;1208       }
;;;1209   
;;;1210       CPU_CRITICAL_ENTER();
;;;1211       flags_cur = p_grp->Flags;
;;;1212       CPU_CRITICAL_EXIT();
;;;1213      *p_err     = OS_ERR_NONE;
;;;1214       return (flags_cur);
;;;1215   }
000072  e8bd87f0          POP      {r4-r10,pc}
                  |L12.118|
000076  f8901088          LDRB     r1,[r0,#0x88]         ;1153
00007a  6876              LDR      r6,[r6,#4]            ;1152
00007c  f001010f          AND      r1,r1,#0xf            ;1153
000080  2901              CMP      r1,#1                 ;1154
000082  d018              BEQ      |L12.182|
000084  2902              CMP      r1,#2                 ;1154
000086  d01e              BEQ      |L12.198|
000088  2904              CMP      r1,#4                 ;1154
00008a  d00a              BEQ      |L12.162|
00008c  2908              CMP      r1,#8                 ;1154
00008e  d00d              BEQ      |L12.172|
000090  f7fffffe          BL       CPU_SR_Save
000094  7829              LDRB     r1,[r5,#0]            ;1193  ; OSSchedLockNestingCtr
000096  1e49              SUBS     r1,r1,#1              ;1193
000098  f01101ff          ANDS     r1,r1,#0xff           ;1193
00009c  7029              STRB     r1,[r5,#0]            ;1193
00009e  d033              BEQ      |L12.264|
0000a0  e03a              B        |L12.280|
                  |L12.162|
0000a2  6a21              LDR      r1,[r4,#0x20]         ;1156
0000a4  f8d02080          LDR      r2,[r0,#0x80]         ;1156
0000a8  4011              ANDS     r1,r1,r2              ;1156
0000aa  e009              B        |L12.192|
                  |L12.172|
0000ac  6a21              LDR      r1,[r4,#0x20]         ;1165
0000ae  f8d02080          LDR      r2,[r0,#0x80]         ;1165
0000b2  4011              ANDS     r1,r1,r2              ;1165
0000b4  e00b              B        |L12.206|
                  |L12.182|
0000b6  f8d01080          LDR      r1,[r0,#0x80]         ;1175
0000ba  6a23              LDR      r3,[r4,#0x20]         ;1175
0000bc  460a              MOV      r2,r1                 ;1175
0000be  4399              BICS     r1,r1,r3              ;1175
                  |L12.192|
0000c0  428a              CMP      r2,r1                 ;1176
0000c2  d005              BEQ      |L12.208|
0000c4  e007              B        |L12.214|
                  |L12.198|
0000c6  f8d01080          LDR      r1,[r0,#0x80]         ;1184
0000ca  6a22              LDR      r2,[r4,#0x20]         ;1184
0000cc  4391              BICS     r1,r1,r2              ;1184
                  |L12.206|
0000ce  b111              CBZ      r1,|L12.214|
                  |L12.208|
0000d0  4652              MOV      r2,r10                ;1186
0000d2  f7fffffe          BL       OS_FlagTaskRdy
                  |L12.214|
0000d6  b116              CBZ      r6,|L12.222|
                  |L12.216|
0000d8  68b0              LDR      r0,[r6,#8]            ;1199
0000da  2800              CMP      r0,#0                 ;1199
0000dc  d1cb              BNE      |L12.118|
                  |L12.222|
0000de  f7fffffe          BL       CPU_SR_Save
0000e2  7829              LDRB     r1,[r5,#0]            ;1204  ; OSSchedLockNestingCtr
0000e4  1e49              SUBS     r1,r1,#1              ;1204
0000e6  7029              STRB     r1,[r5,#0]            ;1204
0000e8  f7fffffe          BL       CPU_SR_Restore
0000ec  ea5f4008          LSLS     r0,r8,#16             ;1206
0000f0  d401              BMI      |L12.246|
0000f2  f7fffffe          BL       OSSched
                  |L12.246|
0000f6  f7fffffe          BL       CPU_SR_Save
0000fa  6a24              LDR      r4,[r4,#0x20]         ;1211
0000fc  f7fffffe          BL       CPU_SR_Restore
000100  f8a79000          STRH     r9,[r7,#0]            ;1213
000104  4620              MOV      r0,r4                 ;1214
000106  e7b4              B        |L12.114|
                  |L12.264|
000108  4908              LDR      r1,|L12.300|
00010a  8809              LDRH     r1,[r1,#0]            ;1193  ; OSIntQNbrEntries
00010c  b121              CBZ      r1,|L12.280|
00010e  f7fffffe          BL       CPU_SR_Restore
000112  f7fffffe          BL       OS_Sched0
000116  e001              B        |L12.284|
                  |L12.280|
000118  f7fffffe          BL       CPU_SR_Restore
                  |L12.284|
00011c  f64320ff          MOV      r0,#0x3aff            ;1194
                  |L12.288|
000120  8038              STRH     r0,[r7,#0]            ;1194
000122  2000              MOVS     r0,#0                 ;1195
000124  e7a5              B        |L12.114|
;;;1216   
                          ENDP

000126  0000              DCW      0x0000
                  |L12.296|
                          DCD      OSSchedLockNestingCtr
                  |L12.300|
                          DCD      OSIntQNbrEntries

                          AREA ||i.OS_FlagTaskRdy||, CODE, READONLY, ALIGN=1

                  OS_FlagTaskRdy PROC
;;;1237   
;;;1238   void   OS_FlagTaskRdy (OS_TCB    *p_tcb,
000000  b570              PUSH     {r4-r6,lr}
;;;1239                          OS_FLAGS   flags_rdy,
;;;1240                          CPU_TS     ts)
;;;1241   {
000002  f1000434          ADD      r4,r0,#0x34
;;;1242       p_tcb->FlagsRdy   = flags_rdy;
;;;1243       p_tcb->PendStatus = OS_STATUS_PEND_OK;                  /* Clear pend status                                      */
000006  2500              MOVS     r5,#0
000008  6521              STR      r1,[r4,#0x50]
00000a  7065              STRB     r5,[r4,#1]
;;;1244       p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;            /* Indicate no longer pending                             */
00000c  7025              STRB     r5,[r4,#0]
;;;1245       p_tcb->TS         = ts;
;;;1246       switch (p_tcb->TaskState) {
00000e  6402              STR      r2,[r0,#0x40]
000010  78a0              LDRB     r0,[r4,#2]
000012  3c34              SUBS     r4,r4,#0x34
000014  2808              CMP      r0,#8
000016  d20e              BCS      |L13.54|
000018  e8dff000          TBB      [pc,r0]
00001c  0d0d0404          DCB      0x0d,0x0d,0x04,0x04
000020  0d0d0a0a          DCB      0x0d,0x0d,0x0a,0x0a
;;;1247           case OS_TASK_STATE_RDY:
;;;1248           case OS_TASK_STATE_DLY:
;;;1249           case OS_TASK_STATE_DLY_SUSPENDED:
;;;1250           case OS_TASK_STATE_SUSPENDED:
;;;1251                break;
;;;1252   
;;;1253           case OS_TASK_STATE_PEND:
;;;1254           case OS_TASK_STATE_PEND_TIMEOUT:
;;;1255                OS_TaskRdy(p_tcb);
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       OS_TaskRdy
;;;1256                p_tcb->TaskState = OS_TASK_STATE_RDY;
00002a  f8845036          STRB     r5,[r4,#0x36]
;;;1257                break;
00002e  e002              B        |L13.54|
;;;1258   
;;;1259           case OS_TASK_STATE_PEND_SUSPENDED:
;;;1260           case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
;;;1261                p_tcb->TaskState = OS_TASK_STATE_SUSPENDED;
000030  2004              MOVS     r0,#4
000032  f8840036          STRB     r0,[r4,#0x36]
                  |L13.54|
;;;1262                break;
;;;1263   
;;;1264           default:
;;;1265                break;
;;;1266       }
;;;1267       OS_PendListRemove(p_tcb);
000036  4620              MOV      r0,r4
000038  e8bd4070          POP      {r4-r6,lr}
00003c  f7ffbffe          B.W      OS_PendListRemove
;;;1268   }
;;;1269   #endif
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

000000  3f464c41          DCB      0x3f,0x46,0x4c,0x41
000004  4700              DCB      0x47,0x00
