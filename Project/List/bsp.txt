; generated by ARM C/C++ Compiler, 5.02 [Build 28]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\OBJ\bsp.o --asm_dir=.\List\ --list_dir=.\List\ --depend=..\OBJ\bsp.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\BSP -I..\CORE -I..\STM32F10x_FWLib\inc -I..\USER -I..\UCOSIII\uC-CPU -I..\UCOSIII\uC-CPU\ARM-Cortex-M3\RealView -I..\UCOSIII\uC-LIB -I..\UCOSIII\uC-LIB\Ports\ARM-Cortex-M3\RealView -I..\UCOSIII\uCOS-III -I..\UCOSIII\uCOS-III\Ports -I..\UCOSIII\uCOS-III\Ports\ARM-Cortex-M3\Generic\RealView -I..\UCOSIII\uCOS-III\Source -I..\UCOSIII\UCOS_BSP -I..\UCOSIII\uCOS_CONFIG -I..\UCOSIII-Task -I..\SYSTEM -I..\BSP\inc -I..\PAL -I..\PAL\vehicles -ID:\Keil_v4\ARM\RV31\INC -ID:\Keil_v4\ARM\CMSIS\Include -ID:\Keil_v4\ARM\Inc\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=..\OBJ\bsp.crf ..\BSP\bsp.c]
                          THUMB

                          AREA ||i.BSP_Init||, CODE, READONLY, ALIGN=1

                  BSP_Init PROC
;;;63     
;;;64     void BSP_Init(void)
000000  b510              PUSH     {r4,lr}
;;;65     {
;;;66         /* System Clocks Configuration --72M*/
;;;67         RCC_Configuration();
000002  f7fffffe          BL       RCC_Configuration
;;;68     
;;;69         GPIO_Configuration();
;;;70         USART_Config(115200);
000006  f44f30e1          MOV      r0,#0x1c200
00000a  f7fffffe          BL       USART_Config
;;;71         /* NVIC configuration */
;;;72         NVIC_Configuration();
00000e  f7fffffe          BL       NVIC_Configuration
;;;73         flash_init();
000012  f7fffffe          BL       flash_init
;;;74         //sim800_init();
;;;75         l206_init();
000016  f7fffffe          BL       l206_init
;;;76         adc_config();
00001a  e8bd4010          POP      {r4,lr}
00001e  f7ffbffe          B.W      adc_config
;;;77     }
;;;78     #define ADC1_DR_Address    ((u32)0x4001244C)	 
                          ENDP


                          AREA ||i.GPIO_Configuration||, CODE, READONLY, ALIGN=1

                  GPIO_Configuration PROC
;;;167     *******************************************************************************/
;;;168    void GPIO_Configuration(void)
000000  4770              BX       lr
;;;169    {
;;;170    
;;;171    }
;;;172    
                          ENDP


                          AREA ||i.NVIC_Configuration||, CODE, READONLY, ALIGN=1

                  NVIC_Configuration PROC
;;;180     *******************************************************************************/
;;;181    void NVIC_Configuration(void)
000000  b538              PUSH     {r3-r5,lr}
;;;182    {
;;;183        NVIC_InitTypeDef  NVIC_InitStructure;
;;;184    
;;;185        NVIC_PriorityGroupConfig(NVIC_PriorityGroup_3);
000002  f44f6080          MOV      r0,#0x400
000006  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;186    
;;;187        NVIC_InitStructure.NVIC_IRQChannel = USART3_IRQn;
00000a  2027              MOVS     r0,#0x27
00000c  f88d0000          STRB     r0,[sp,#0]
;;;188        NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
000010  2400              MOVS     r4,#0
000012  f88d4001          STRB     r4,[sp,#1]
;;;189        NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000016  f88d4002          STRB     r4,[sp,#2]
;;;190        NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00001a  2501              MOVS     r5,#1
00001c  f88d5003          STRB     r5,[sp,#3]
;;;191        NVIC_Init(&NVIC_InitStructure);
000020  4668              MOV      r0,sp
000022  f7fffffe          BL       NVIC_Init
;;;192    
;;;193        NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
000026  2025              MOVS     r0,#0x25
000028  f88d0000          STRB     r0,[sp,#0]
;;;194        NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
00002c  f88d4001          STRB     r4,[sp,#1]
;;;195        NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000030  f88d4002          STRB     r4,[sp,#2]
;;;196        NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000034  f88d5003          STRB     r5,[sp,#3]
;;;197        NVIC_Init(&NVIC_InitStructure);
000038  4668              MOV      r0,sp
00003a  f7fffffe          BL       NVIC_Init
;;;198    
;;;199        NVIC_InitStructure.NVIC_IRQChannel = UART4_IRQn;
00003e  2034              MOVS     r0,#0x34
000040  f88d0000          STRB     r0,[sp,#0]
;;;200        NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
000044  f88d4001          STRB     r4,[sp,#1]
;;;201        NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000048  f88d4002          STRB     r4,[sp,#2]
;;;202        NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00004c  f88d5003          STRB     r5,[sp,#3]
;;;203        NVIC_Init(&NVIC_InitStructure);
000050  4668              MOV      r0,sp
000052  f7fffffe          BL       NVIC_Init
;;;204    
;;;205        NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn;
000056  2026              MOVS     r0,#0x26
000058  f88d0000          STRB     r0,[sp,#0]
;;;206        NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
00005c  f88d4001          STRB     r4,[sp,#1]
;;;207        NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000060  f88d4002          STRB     r4,[sp,#2]
;;;208        NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000064  f88d5003          STRB     r5,[sp,#3]
;;;209        NVIC_Init(&NVIC_InitStructure);
000068  4668              MOV      r0,sp
00006a  f7fffffe          BL       NVIC_Init
;;;210    }
00006e  bd38              POP      {r3-r5,pc}
;;;211    
                          ENDP


                          AREA ||i.RCC_Configuration||, CODE, READONLY, ALIGN=1

                  RCC_Configuration PROC
;;;44     ////////////////////////////////////////////////////////
;;;45     void RCC_Configuration(void)
000000  b510              PUSH     {r4,lr}
;;;46     {
;;;47         SystemInit();
000002  f7fffffe          BL       SystemInit
;;;48         RCC_ADCCLKConfig(RCC_PCLK2_Div6); 
000006  f44f4000          MOV      r0,#0x8000
00000a  f7fffffe          BL       RCC_ADCCLKConfig
;;;49         RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);
00000e  2101              MOVS     r1,#1
000010  4608              MOV      r0,r1
000012  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;50         RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
000016  2101              MOVS     r1,#1
000018  4608              MOV      r0,r1
00001a  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;51         RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1 , ENABLE);
00001e  2101              MOVS     r1,#1
000020  0248              LSLS     r0,r1,#9
000022  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;52         RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);
000026  2101              MOVS     r1,#1
000028  e8bd4010          POP      {r4,lr}
00002c  2010              MOVS     r0,#0x10
00002e  f7ffbffe          B.W      RCC_APB2PeriphClockCmd
;;;53     }
;;;54     
                          ENDP


                          AREA ||i.USART_Config||, CODE, READONLY, ALIGN=2

                  USART_Config PROC
;;;211    
;;;212    void USART_Config(u32 baud)
000000  b5f0              PUSH     {r4-r7,lr}
;;;213    {
000002  4606              MOV      r6,r0
000004  b085              SUB      sp,sp,#0x14
;;;214        GPIO_InitTypeDef GPIO_InitStructure;
;;;215        USART_InitTypeDef USART_InitStructure;
;;;216        if (PC_USARTAPB == APB1)
;;;217        {
;;;218            RCC_APB2PeriphClockCmd(RCC_APBxPeriph_PC_USART_IO | RCC_APB2Periph_AFIO,ENABLE);
000006  2101              MOVS     r1,#1
000008  2005              MOVS     r0,#5
00000a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;219            RCC_APB1PeriphClockCmd(RCC_APBxPeriph_PC_USART,ENABLE);
00000e  2101              MOVS     r1,#1
000010  0448              LSLS     r0,r1,#17
000012  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;220        }
;;;221        else
;;;222        {
;;;223            RCC_APB2PeriphClockCmd(RCC_APBxPeriph_PC_USART_IO | RCC_APBxPeriph_PC_USART | RCC_APB2Periph_AFIO,ENABLE);
;;;224        }
;;;225        if (PC_PinRemap == ENABLE)
;;;226        {
;;;227            GPIO_PinRemapConfig(GPIO_Remap_USART2,ENABLE);
;;;228        }
;;;229        GPIO_InitStructure.GPIO_Pin = PC_USART_TXD;
000016  2404              MOVS     r4,#4
000018  f8ad4010          STRH     r4,[sp,#0x10]
;;;230        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
00001c  2018              MOVS     r0,#0x18
00001e  f88d0013          STRB     r0,[sp,#0x13]
;;;231        GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;232        GPIO_Init(PC_USART_IO,&GPIO_InitStructure);
000022  4f19              LDR      r7,|L5.136|
000024  2503              MOVS     r5,#3                 ;231
000026  f88d5012          STRB     r5,[sp,#0x12]         ;231
00002a  a904              ADD      r1,sp,#0x10
00002c  4638              MOV      r0,r7
00002e  f7fffffe          BL       GPIO_Init
;;;233    
;;;234        GPIO_InitStructure.GPIO_Pin = PC_USART_RXD;
000032  2008              MOVS     r0,#8
000034  f8ad0010          STRH     r0,[sp,#0x10]
;;;235        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
000038  f88d4013          STRB     r4,[sp,#0x13]
;;;236        GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00003c  f88d5012          STRB     r5,[sp,#0x12]
;;;237        GPIO_Init(PC_USART_IO,&GPIO_InitStructure);
000040  a904              ADD      r1,sp,#0x10
000042  4638              MOV      r0,r7
000044  f7fffffe          BL       GPIO_Init
;;;238    
;;;239        USART_InitStructure.USART_BaudRate = baud;
;;;240        USART_InitStructure.USART_WordLength = USART_WordLength_8b;
000048  2000              MOVS     r0,#0
00004a  f8ad0004          STRH     r0,[sp,#4]
;;;241        USART_InitStructure.USART_StopBits = USART_StopBits_1;
00004e  f8ad0006          STRH     r0,[sp,#6]
;;;242        USART_InitStructure.USART_Parity = USART_Parity_No;
000052  f8ad0008          STRH     r0,[sp,#8]
;;;243        USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None ;
000056  f8ad000c          STRH     r0,[sp,#0xc]
;;;244        USART_InitStructure.USART_Mode = USART_Mode_Rx|USART_Mode_Tx;
00005a  200c              MOVS     r0,#0xc
;;;245        USART_Init(PC_USART,&USART_InitStructure);
00005c  4c0b              LDR      r4,|L5.140|
00005e  f8ad000a          STRH     r0,[sp,#0xa]          ;244
000062  9600              STR      r6,[sp,#0]            ;240
000064  4669              MOV      r1,sp
000066  4620              MOV      r0,r4
000068  f7fffffe          BL       USART_Init
;;;246        //data = data;
;;;247        //data = PC_USART->DR;
;;;248        //data = PC_USART->SR;
;;;249        NVIC_Configuration();
00006c  f7fffffe          BL       NVIC_Configuration
;;;250        USART_ITConfig(PC_USART, USART_IT_RXNE, ENABLE);
000070  2201              MOVS     r2,#1
000072  f2405125          MOV      r1,#0x525
000076  4620              MOV      r0,r4
000078  f7fffffe          BL       USART_ITConfig
;;;251        //USART_ITConfig(PC_USART, USART_IT_TXE, ENABLE);
;;;252        USART_Cmd(PC_USART,ENABLE);
00007c  2101              MOVS     r1,#1
00007e  4620              MOV      r0,r4
000080  f7fffffe          BL       USART_Cmd
;;;253    }
000084  b005              ADD      sp,sp,#0x14
000086  bdf0              POP      {r4-r7,pc}
;;;254    
                          ENDP

                  |L5.136|
                          DCD      0x40010800
                  |L5.140|
                          DCD      0x40004400

                          AREA ||i.UnableJTAG||, CODE, READONLY, ALIGN=2

                  UnableJTAG PROC
;;;55     //关闭调试接口，作GPIO使用
;;;56     void UnableJTAG(void)
000000  4807              LDR      r0,|L6.32|
;;;57     {
;;;58     
;;;59         RCC->APB2ENR |= RCC_APB2ENR_AFIOEN;                     // enable clock for Alternate Function
000002  6981              LDR      r1,[r0,#0x18]
000004  f0410101          ORR      r1,r1,#1
000008  6181              STR      r1,[r0,#0x18]
;;;60         AFIO->MAPR &= ~(7UL<<24); // clear used bit
00000a  4806              LDR      r0,|L6.36|
00000c  6841              LDR      r1,[r0,#4]
00000e  f02161e0          BIC      r1,r1,#0x7000000
000012  6041              STR      r1,[r0,#4]
;;;61         AFIO->MAPR |= (4UL<<24); // set used bits
000014  6841              LDR      r1,[r0,#4]
000016  f0416180          ORR      r1,r1,#0x4000000
00001a  6041              STR      r1,[r0,#4]
;;;62     }
00001c  4770              BX       lr
;;;63     
                          ENDP

00001e  0000              DCW      0x0000
                  |L6.32|
                          DCD      0x40021000
                  |L6.36|
                          DCD      0x40010000

                          AREA ||i._sys_exit||, CODE, READONLY, ALIGN=1

                  _sys_exit PROC
;;;21     FILE __stdout;
;;;22     _sys_exit(int x)
000000  4770              BX       lr
;;;23     {
;;;24         x = x;
;;;25     }
;;;26     
                          ENDP


                          AREA ||i.adc_config||, CODE, READONLY, ALIGN=2

                  adc_config PROC
;;;80     
;;;81     void adc_config(void)
000000  b570              PUSH     {r4-r6,lr}
;;;82     {
000002  b092              SUB      sp,sp,#0x48
;;;83         ADC_InitTypeDef ADC_InitStructure;
;;;84         GPIO_InitTypeDef GPIO_InitStructure;
;;;85         DMA_InitTypeDef DMA_InitStructure;
;;;86     
;;;87         //设置AD模拟输入端口为输入 1路AD 规则通道
;;;88         GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;
000004  2002              MOVS     r0,#2
000006  f8ad0040          STRH     r0,[sp,#0x40]
;;;89         GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
00000a  2400              MOVS     r4,#0
00000c  f88d4043          STRB     r4,[sp,#0x43]
;;;90         GPIO_Init(GPIOC, &GPIO_InitStructure);
000010  a910              ADD      r1,sp,#0x40
000012  4830              LDR      r0,|L8.212|
000014  f7fffffe          BL       GPIO_Init
;;;91         /* Enable DMA clock */
;;;92         RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
000018  2101              MOVS     r1,#1
00001a  4608              MOV      r0,r1
00001c  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;93     
;;;94         /* Enable ADC1 and GPIOC clock */
;;;95         RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1 , ENABLE);
000020  2101              MOVS     r1,#1
000022  0248              LSLS     r0,r1,#9
000024  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;96     
;;;97         /* DMA channel1 configuration ----------------------------------------------*/
;;;98         //使能DMA
;;;99         DMA_DeInit(DMA1_Channel1);
000028  4e2b              LDR      r6,|L8.216|
00002a  4630              MOV      r0,r6
00002c  f7fffffe          BL       DMA_DeInit
;;;100        DMA_InitStructure.DMA_PeripheralBaseAddr = ADC1_DR_Address;			            //DMA通道1的地址 
000030  482a              LDR      r0,|L8.220|
;;;101        DMA_InitStructure.DMA_MemoryBaseAddr = (u32)&ADC_ConvertedValue;	            //DMA传送地址
000032  9000              STR      r0,[sp,#0]
000034  482a              LDR      r0,|L8.224|
;;;102        DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;					            //传送方向
;;;103        DMA_InitStructure.DMA_BufferSize = 1;								            //传送内存大小，1个16位
000036  a901              ADD      r1,sp,#4
000038  2501              MOVS     r5,#1
00003a  c131              STM      r1!,{r0,r4,r5}
;;;104        DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;	 
;;;105        DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;				            //传送内存地址递增
00003c  2080              MOVS     r0,#0x80
00003e  e9cd4004          STRD     r4,r0,[sp,#0x10]
;;;106        DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;		//ADC1转换的数据是16位
000042  0040              LSLS     r0,r0,#1
;;;107        DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;				//传送的目的地址是16位宽度
000044  9006              STR      r0,[sp,#0x18]
000046  0080              LSLS     r0,r0,#2
;;;108        DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;									//循环
000048  9007              STR      r0,[sp,#0x1c]
00004a  2020              MOVS     r0,#0x20
;;;109        DMA_InitStructure.DMA_Priority = DMA_Priority_High;
00004c  9008              STR      r0,[sp,#0x20]
00004e  0200              LSLS     r0,r0,#8
;;;110        DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
;;;111        DMA_Init(DMA1_Channel1, &DMA_InitStructure);
000050  e9cd0409          STRD     r0,r4,[sp,#0x24]
000054  4669              MOV      r1,sp
000056  4630              MOV      r0,r6
000058  f7fffffe          BL       DMA_Init
;;;112    
;;;113        /* 允许DMA1通道1传输结束中断 */
;;;114        //DMA_ITConfig(DMA1_Channel1,DMA_IT_TC, ENABLE);
;;;115        //使能DMA通道1
;;;116        DMA_Cmd(DMA1_Channel1, ENABLE); 
00005c  2101              MOVS     r1,#1
00005e  4630              MOV      r0,r6
000060  f7fffffe          BL       DMA_Cmd
;;;117        //ADC配置
;;;118        /* ADC转换时间： ─ STM32F103xx增强型产品：时钟为56MHz时为1μs(时钟为72MHz为1.17μs)
;;;119           ADC采样范围0-3.3V    */
;;;120        RCC_ADCCLKConfig(RCC_PCLK2_Div6);                   //设置ADC的时钟为72MHZ/6=12M 
000064  03e8              LSLS     r0,r5,#15
000066  f7fffffe          BL       RCC_ADCCLKConfig
;;;121    
;;;122        ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;	//ADC1工作在独立模式
;;;123        ADC_InitStructure.ADC_ScanConvMode = ENABLE;		//模数转换工作在扫描模式（多通道）还是单次（单通道）模式
00006a  f88d5030          STRB     r5,[sp,#0x30]
00006e  940b              STR      r4,[sp,#0x2c]
;;;124        ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;	//模数转换工作在连续模式，还是单次模式
000070  f88d5031          STRB     r5,[sp,#0x31]
;;;125        ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;//转换由软件而不是外部触发启动
000074  f44f2060          MOV      r0,#0xe0000
000078  e9cd040d          STRD     r0,r4,[sp,#0x34]
;;;126        ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;//ADC数据右对齐
;;;127        ADC_InitStructure.ADC_NbrOfChannel = 1;               //规定了顺序进行规则转换的ADC通道的数目。这个数目的取值范围是1到16
;;;128        ADC_Init(ADC1, &ADC_InitStructure);
00007c  4c17              LDR      r4,|L8.220|
00007e  f88d503c          STRB     r5,[sp,#0x3c]         ;127
000082  3c4c              SUBS     r4,r4,#0x4c
000084  a90b              ADD      r1,sp,#0x2c
000086  4620              MOV      r0,r4
000088  f7fffffe          BL       ADC_Init
;;;129    
;;;130        /* ADC1 regular channels configuration [规则模式通道配置]*/ 
;;;131    
;;;132        //ADC1 规则通道配置
;;;133        ADC_RegularChannelConfig(ADC1, ADC_Channel_11, 1, ADC_SampleTime_55Cycles5);	  //通道11采样时间 55.5周期
00008c  2305              MOVS     r3,#5
00008e  2201              MOVS     r2,#1
000090  210b              MOVS     r1,#0xb
000092  4620              MOV      r0,r4
000094  f7fffffe          BL       ADC_RegularChannelConfig
;;;134    
;;;135        //使能ADC1 DMA 
;;;136        ADC_DMACmd(ADC1, ENABLE);
000098  2101              MOVS     r1,#1
00009a  4620              MOV      r0,r4
00009c  f7fffffe          BL       ADC_DMACmd
;;;137        //使能ADC1
;;;138        ADC_Cmd(ADC1, ENABLE);	
0000a0  2101              MOVS     r1,#1
0000a2  4620              MOV      r0,r4
0000a4  f7fffffe          BL       ADC_Cmd
;;;139    
;;;140        // 初始化ADC1校准寄存器
;;;141        ADC_ResetCalibration(ADC1);
0000a8  4620              MOV      r0,r4
0000aa  f7fffffe          BL       ADC_ResetCalibration
                  |L8.174|
;;;142        //检测ADC1校准寄存器初始化是否完成
;;;143        while(ADC_GetResetCalibrationStatus(ADC1));
0000ae  4620              MOV      r0,r4
0000b0  f7fffffe          BL       ADC_GetResetCalibrationStatus
0000b4  2800              CMP      r0,#0
0000b6  d1fa              BNE      |L8.174|
;;;144    
;;;145        //开始校准ADC1
;;;146        ADC_StartCalibration(ADC1);
0000b8  4620              MOV      r0,r4
0000ba  f7fffffe          BL       ADC_StartCalibration
                  |L8.190|
;;;147        //检测是否完成校准
;;;148        while(ADC_GetCalibrationStatus(ADC1));
0000be  4620              MOV      r0,r4
0000c0  f7fffffe          BL       ADC_GetCalibrationStatus
0000c4  2800              CMP      r0,#0
0000c6  d1fa              BNE      |L8.190|
;;;149    
;;;150        //ADC1转换启动
;;;151        ADC_SoftwareStartConvCmd(ADC1, ENABLE);	
0000c8  2101              MOVS     r1,#1
0000ca  4620              MOV      r0,r4
0000cc  f7fffffe          BL       ADC_SoftwareStartConvCmd
;;;152    }
0000d0  b012              ADD      sp,sp,#0x48
0000d2  bd70              POP      {r4-r6,pc}
;;;153    
                          ENDP

                  |L8.212|
                          DCD      0x40011000
                  |L8.216|
                          DCD      0x40020008
                  |L8.220|
                          DCD      0x4001244c
                  |L8.224|
                          DCD      ||area_number.14||

                          AREA ||i.fputc||, CODE, READONLY, ALIGN=2

                  fputc PROC
;;;26     
;;;27     int fputc(int ch, FILE *f)
000000  4904              LDR      r1,|L9.20|
                  |L9.2|
;;;28     {
;;;29     
;;;30         while((PC_USART->SR & 0x40) == 0);
000002  880a              LDRH     r2,[r1,#0]
000004  0652              LSLS     r2,r2,#25
000006  d5fc              BPL      |L9.2|
;;;31         PC_USART->DR = (u8)ch;
000008  4a02              LDR      r2,|L9.20|
00000a  b2c1              UXTB     r1,r0
00000c  1d12              ADDS     r2,r2,#4
00000e  8011              STRH     r1,[r2,#0]
;;;32         return ch;
;;;33     }
000010  4770              BX       lr
;;;34     #endif
                          ENDP

000012  0000              DCW      0x0000
                  |L9.20|
                          DCD      0x40004400

                          AREA ||i.get_adc_value||, CODE, READONLY, ALIGN=2

                  get_adc_value PROC
;;;153    
;;;154    uint16_t get_adc_value(void)
000000  4801              LDR      r0,|L10.8|
;;;155    {
;;;156        return ADC_ConvertedValue;
000002  8800              LDRH     r0,[r0,#0]  ; ADC_ConvertedValue
;;;157    }
000004  4770              BX       lr
;;;158    
                          ENDP

000006  0000              DCW      0x0000
                  |L10.8|
                          DCD      ||area_number.14||

                          AREA ||.data||, DATA, ALIGN=2

                  __stdout
                          DCD      0x00000000

                          AREA ||area_number.14||, DATA, ALIGN=1

                          EXPORTAS ||area_number.14||, ||.data||
                  ADC_ConvertedValue
000000  0000              DCB      0x00,0x00
