; generated by ARM C/C++ Compiler, 5.02 [Build 28]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\OBJ\lib_mem.o --asm_dir=.\List\ --list_dir=.\List\ --depend=..\OBJ\lib_mem.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\BSP -I..\CORE -I..\STM32F10x_FWLib\inc -I..\USER -I..\UCOSIII\uC-CPU -I..\UCOSIII\uC-CPU\ARM-Cortex-M3\RealView -I..\UCOSIII\uC-LIB -I..\UCOSIII\uC-LIB\Ports\ARM-Cortex-M3\RealView -I..\UCOSIII\uCOS-III -I..\UCOSIII\uCOS-III\Ports -I..\UCOSIII\uCOS-III\Ports\ARM-Cortex-M3\Generic\RealView -I..\UCOSIII\uCOS-III\Source -I..\UCOSIII\UCOS_BSP -I..\UCOSIII\uCOS_CONFIG -I..\UCOSIII-Task -I..\SYSTEM -I..\BSP\inc -I..\PAL -I..\PAL\vehicles -ID:\Keil_v4\ARM\RV31\INC -ID:\Keil_v4\ARM\CMSIS\Include -ID:\Keil_v4\ARM\Inc\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=..\OBJ\lib_mem.crf ..\UCOSIII\uC-LIB\lib_mem.c]
                          THUMB

                          AREA ||i.Mem_Clr||, CODE, READONLY, ALIGN=1

                  Mem_Clr PROC
;;;221    
;;;222    void  Mem_Clr (void        *pmem,
000000  460a              MOV      r2,r1
;;;223                   CPU_SIZE_T   size)
;;;224    {
;;;225        Mem_Set(pmem,
000002  2100              MOVS     r1,#0
000004  f7ffbffe          B.W      Mem_Set
;;;226                0u,                                                 /* See Note #2.                                         */
;;;227                size);
;;;228    }
;;;229    
                          ENDP


                          AREA ||i.Mem_Cmp||, CODE, READONLY, ALIGN=2

                  Mem_Cmp PROC
;;;613    
;;;614    CPU_BOOLEAN  Mem_Cmp (const  void        *p1_mem,
000000  b570              PUSH     {r4-r6,lr}
;;;615                          const  void        *p2_mem,
;;;616                                 CPU_SIZE_T   size)
;;;617    {
000002  4603              MOV      r3,r0
000004  b1ca              CBZ      r2,|L2.58|
;;;618               CPU_SIZE_T    size_rem;
;;;619               CPU_ALIGN    *p1_mem_align;
;;;620               CPU_ALIGN    *p2_mem_align;
;;;621        const  CPU_INT08U   *p1_mem_08;
;;;622        const  CPU_INT08U   *p2_mem_08;
;;;623               CPU_DATA      i;
;;;624               CPU_DATA      mem_align_mod_1;
;;;625               CPU_DATA      mem_align_mod_2;
;;;626               CPU_BOOLEAN   mem_aligned;
;;;627               CPU_BOOLEAN   mem_cmp;
;;;628    
;;;629    
;;;630        if (size < 1) {                                             /* See Note #1.                                         */
;;;631            return (DEF_YES);
;;;632        }
;;;633        if (p1_mem == (void *)0) {
000006  b35b              CBZ      r3,|L2.96|
;;;634            return (DEF_NO);
;;;635        }
;;;636        if (p2_mem == (void *)0) {
000008  b351              CBZ      r1,|L2.96|
;;;637            return (DEF_NO);
;;;638        }
;;;639    
;;;640    
;;;641        mem_cmp         =  DEF_YES;                                 /* Assume mem bufs are identical until cmp fails.       */
;;;642        size_rem        =  size;
;;;643                                                                    /* Start @ end of mem bufs (see Note #2).               */
;;;644        p1_mem_08       = (const CPU_INT08U *)p1_mem + size;
00000a  4413              ADD      r3,r3,r2
;;;645        p2_mem_08       = (const CPU_INT08U *)p2_mem + size;
00000c  4411              ADD      r1,r1,r2
00000e  2001              MOVS     r0,#1                 ;641
;;;646                                                                    /* See Note #4.                                         */
;;;647        mem_align_mod_1 = (CPU_INT08U)((CPU_ADDR)p1_mem_08 % sizeof(CPU_ALIGN));
000010  f0030403          AND      r4,r3,#3
;;;648        mem_align_mod_2 = (CPU_INT08U)((CPU_ADDR)p2_mem_08 % sizeof(CPU_ALIGN));
000014  f0010503          AND      r5,r1,#3
;;;649    
;;;650        mem_aligned     = (mem_align_mod_1 == mem_align_mod_2) ? DEF_YES : DEF_NO;
000018  42ac              CMP      r4,r5
00001a  d11b              BNE      |L2.84|
                  |L2.28|
00001c  b1bc              CBZ      r4,|L2.78|
;;;651    
;;;652        if (mem_aligned == DEF_YES) {                               /* If mem bufs' alignment offset equal, ...             */
;;;653                                                                    /* ... optimize cmp for mem buf alignment.              */
;;;654            if (mem_align_mod_1 != 0u) {                            /* If trailing octets avail,                  ...       */
;;;655                i = mem_align_mod_1;
;;;656                while ((mem_cmp == DEF_YES) &&                      /* ... cmp mem bufs while identical &         ...       */
;;;657                       (size_rem > 0)       &&                      /* ... start mem buf cmp with trailing octets ...       */
;;;658                       (i        > 0)) {                            /* ... until next CPU_ALIGN word boundary.              */
;;;659                    p1_mem_08--;
;;;660                    p2_mem_08--;
;;;661                    if (*p1_mem_08 != *p2_mem_08) {                 /* If ANY data octet(s) NOT identical, cmp fails.       */
00001e  f8135d01          LDRB     r5,[r3,#-1]!
000022  f8116d01          LDRB     r6,[r1,#-1]!
000026  42b5              CMP      r5,r6
000028  d000              BEQ      |L2.44|
;;;662                         mem_cmp = DEF_NO;
00002a  2000              MOVS     r0,#0
                  |L2.44|
;;;663                    }
;;;664                    size_rem -= sizeof(CPU_INT08U);
00002c  1e52              SUBS     r2,r2,#1
;;;665                    i--;
00002e  1e64              SUBS     r4,r4,#1
000030  2801              CMP      r0,#1                 ;656
000032  d103              BNE      |L2.60|
000034  2a00              CMP      r2,#0                 ;657
000036  d1f1              BNE      |L2.28|
000038  e009              B        |L2.78|
                  |L2.58|
00003a  2001              MOVS     r0,#1                 ;631
                  |L2.60|
;;;666                }
;;;667            }
;;;668    
;;;669            if (mem_cmp == DEF_YES) {                               /* If cmp still identical, cmp aligned mem bufs.        */
;;;670                p1_mem_align = (CPU_ALIGN *)p1_mem_08;              /* See Note #3a.                                        */
;;;671                p2_mem_align = (CPU_ALIGN *)p2_mem_08;
;;;672    
;;;673                while ((mem_cmp  == DEF_YES) &&                     /* Cmp mem bufs while identical & ...                   */
;;;674                       (size_rem >= sizeof(CPU_ALIGN))) {           /* ... mem bufs aligned on CPU_ALIGN word boundaries.   */
;;;675                    p1_mem_align--;
;;;676                    p2_mem_align--;
;;;677                    if (*p1_mem_align != *p2_mem_align) {           /* If ANY data octet(s) NOT identical, cmp fails.       */
;;;678                         mem_cmp = DEF_NO;
;;;679                    }
;;;680                    size_rem -= sizeof(CPU_ALIGN);
;;;681                }
;;;682    
;;;683                p1_mem_08 = (CPU_INT08U *)p1_mem_align;
;;;684                p2_mem_08 = (CPU_INT08U *)p2_mem_align;
;;;685            }
;;;686        }
;;;687    
;;;688        while ((mem_cmp == DEF_YES) &&                              /* Cmp mem bufs while identical ...                     */
;;;689               (size_rem > 0)) {                                    /* ... for unaligned mem bufs or trailing octets.       */
;;;690            p1_mem_08--;
;;;691            p2_mem_08--;
;;;692            if (*p1_mem_08 != *p2_mem_08) {                         /* If ANY data octet(s) NOT identical, cmp fails.       */
;;;693                 mem_cmp = DEF_NO;
;;;694            }
;;;695            size_rem -= sizeof(CPU_INT08U);
;;;696        }
;;;697    
;;;698        return (mem_cmp);
;;;699    }
00003c  bd70              POP      {r4-r6,pc}
00003e  bf00              NOP                            ;677
                  |L2.64|
000040  f8534d04          LDR      r4,[r3,#-4]!          ;677
000044  f8515d04          LDR      r5,[r1,#-4]!          ;677
000048  42ac              CMP      r4,r5                 ;677
00004a  d109              BNE      |L2.96|
00004c  1f12              SUBS     r2,r2,#4              ;680
                  |L2.78|
00004e  2a04              CMP      r2,#4                 ;674
000050  d2f6              BCS      |L2.64|
000052  e008              B        |L2.102|
                  |L2.84|
000054  f8134d01          LDRB     r4,[r3,#-1]!          ;692
000058  f8115d01          LDRB     r5,[r1,#-1]!          ;692
00005c  42ac              CMP      r4,r5                 ;692
00005e  d001              BEQ      |L2.100|
                  |L2.96|
000060  2000              MOVS     r0,#0                 ;693
000062  bd70              POP      {r4-r6,pc}
                  |L2.100|
000064  1e52              SUBS     r2,r2,#1              ;695
                  |L2.102|
000066  2a00              CMP      r2,#0                 ;689
000068  d1f4              BNE      |L2.84|
00006a  bd70              POP      {r4-r6,pc}
;;;700    
                          ENDP


                          AREA ||i.Mem_HeapAlloc||, CODE, READONLY, ALIGN=2

                  Mem_HeapAlloc PROC
;;;740    #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)
;;;741    void  *Mem_HeapAlloc (CPU_SIZE_T   size,
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;742                          CPU_SIZE_T   align,
;;;743                          CPU_SIZE_T  *poctets_reqd,
;;;744                          LIB_ERR     *perr)
;;;745    {
000004  461f              MOV      r7,r3
000006  0014              MOVS     r4,r2
000008  468a              MOV      r10,r1
00000a  4683              MOV      r11,r0
00000c  d100              BNE      |L3.16|
;;;746        MEM_POOL    *pmem_pool_heap;
;;;747        void        *pmem_addr;
;;;748        void        *pmem_blk;
;;;749        CPU_SIZE_T   octets_reqd_unused;
;;;750        CPU_SIZE_T   size_rem;
;;;751        CPU_SIZE_T   size_req;
;;;752        CPU_SR_ALLOC();
;;;753    
;;;754    
;;;755    #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* ------------- VALIDATE RTN ERR PTR ------------- */
;;;756        if (perr == (LIB_ERR *)0) {
;;;757            CPU_SW_EXCEPTION((void *)0);
;;;758        }
;;;759    #endif
;;;760    
;;;761                                                                        /* ------------ VALIDATE RTN OCTETS PTR ----------- */
;;;762        if (poctets_reqd == (CPU_SIZE_T *) 0) {                         /* If NOT avail, ...                                */
;;;763            poctets_reqd  = (CPU_SIZE_T *)&octets_reqd_unused;          /* ... re-cfg NULL rtn ptr to unused local var.     */
00000e  ac01              ADD      r4,sp,#4
                  |L3.16|
;;;764           (void)&octets_reqd_unused;                                   /* Prevent possible 'variable unused' warning.      */
;;;765        }
;;;766       *poctets_reqd = 0u;                                              /* Init octets req'd for err (see Note #1).         */
000010  2000              MOVS     r0,#0
;;;767    
;;;768    
;;;769    #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* ------------ VALIDATE HEAP MEM ALLOC ----------- */
;;;770        if (size < 1) {
;;;771           *perr = LIB_MEM_ERR_INVALID_MEM_SIZE;
;;;772            return ((void *)0);
;;;773        }
;;;774    
;;;775        if (align < 1) {
;;;776           *perr = LIB_MEM_ERR_INVALID_MEM_ALIGN;
;;;777            return ((void *)0);
;;;778        }
;;;779    #endif
;;;780    
;;;781                                                                        /* -------------- ALLOC HEAP MEM BLK -------------- */
;;;782        pmem_pool_heap = &Mem_PoolHeap;
000012  4e18              LDR      r6,|L3.116|
;;;783    
;;;784        CPU_CRITICAL_ENTER();
000014  6020              STR      r0,[r4,#0]
000016  f7fffffe          BL       CPU_SR_Save
;;;785    
;;;786        pmem_addr = pmem_pool_heap->SegAddrNextAvail;
00001a  9000              STR      r0,[sp,#0]
;;;787        size_rem  = pmem_pool_heap->SegSizeRem;
;;;788        size_req  = Mem_SegCalcTotSize(pmem_addr,
00001c  4653              MOV      r3,r10
00001e  465a              MOV      r2,r11
000020  2101              MOVS     r1,#1
000022  f8d68044          LDR      r8,[r6,#0x44]
000026  6bf0              LDR      r0,[r6,#0x3c]
000028  f7fffffe          BL       Mem_SegCalcTotSize
00002c  4605              MOV      r5,r0
;;;789                                       1u,                              /* Calc alloc for single mem blk from heap.         */
;;;790                                       size,
;;;791                                       align);
;;;792    #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
;;;793        if (size_req < 1) {                                             /* If req'd size ovf, ...                           */
;;;794            CPU_CRITICAL_EXIT();
;;;795           *poctets_reqd = size;                                        /* ... rtn add'l heap size needed.                  */
;;;796           *perr         = LIB_MEM_ERR_HEAP_OVF;
;;;797            return ((void *)0);
;;;798        }
;;;799    #endif
;;;800    
;;;801        if (size_req > size_rem) {                                      /* If req'd size > rem heap size, ...               */
;;;802            CPU_CRITICAL_EXIT();
;;;803           *poctets_reqd = size_req - size_rem;                         /* ... rtn add'l heap size needed.                  */
;;;804           *perr         = LIB_MEM_ERR_HEAP_EMPTY;
00002e  f24279e2          MOV      r9,#0x27e2
000032  4540              CMP      r0,r8                 ;801
000034  d906              BLS      |L3.68|
000036  9800              LDR      r0,[sp,#0]            ;802
000038  f7fffffe          BL       CPU_SR_Restore
00003c  eba50008          SUB      r0,r5,r8              ;803
;;;805            return ((void *)0);
000040  6020              STR      r0,[r4,#0]
000042  e012              B        |L3.106|
                  |L3.68|
;;;806        }
;;;807    
;;;808        pmem_blk = Mem_SegAlloc(pmem_pool_heap, size, align);
000044  4652              MOV      r2,r10
000046  4659              MOV      r1,r11
000048  4630              MOV      r0,r6
00004a  f7fffffe          BL       Mem_SegAlloc
00004e  0006              MOVS     r6,r0
;;;809        if (pmem_blk == (void *)0) {                                    /* If mem blk NOT avail from heap, ...              */
000050  9800              LDR      r0,[sp,#0]
000052  d007              BEQ      |L3.100|
;;;810            CPU_CRITICAL_EXIT();
;;;811           *poctets_reqd = size_req;                                    /* ... rtn add'l heap size needed.                  */
;;;812           *perr         = LIB_MEM_ERR_HEAP_EMPTY;
;;;813            return ((void *)0);
;;;814        }
;;;815    
;;;816        CPU_CRITICAL_EXIT();
000054  f7fffffe          BL       CPU_SR_Restore
;;;817    
;;;818       *perr =  LIB_MEM_ERR_NONE;
000058  f2427010          MOV      r0,#0x2710
00005c  8038              STRH     r0,[r7,#0]
;;;819    
;;;820        return (pmem_blk);
00005e  4630              MOV      r0,r6
                  |L3.96|
;;;821    }
000060  e8bd9ffc          POP      {r2-r12,pc}
                  |L3.100|
000064  f7fffffe          BL       CPU_SR_Restore
000068  6025              STR      r5,[r4,#0]            ;811
                  |L3.106|
00006a  f8a79000          STRH     r9,[r7,#0]            ;812
00006e  2000              MOVS     r0,#0                 ;813
000070  e7f6              B        |L3.96|
;;;822    #endif
                          ENDP

000072  0000              DCW      0x0000
                  |L3.116|
                          DCD      ||.bss||

                          AREA ||i.Mem_HeapGetSizeRem||, CODE, READONLY, ALIGN=2

                  Mem_HeapGetSizeRem PROC
;;;852    #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)
;;;853    CPU_SIZE_T  Mem_HeapGetSizeRem (CPU_SIZE_T   align,
000000  460a              MOV      r2,r1
;;;854                                    LIB_ERR     *perr)
;;;855    {
;;;856        CPU_SIZE_T  size_rem;
;;;857    
;;;858    
;;;859        size_rem = Mem_SegGetSizeRem(&Mem_PoolHeap, align, perr);
000002  4601              MOV      r1,r0
000004  4801              LDR      r0,|L4.12|
000006  f7ffbffe          B.W      Mem_SegGetSizeRem
;;;860    
;;;861        return (size_rem);
;;;862    }
;;;863    #endif
                          ENDP

00000a  0000              DCW      0x0000
                  |L4.12|
                          DCD      ||.bss||

                          AREA ||i.Mem_Init||, CODE, READONLY, ALIGN=2

                  Mem_Init PROC
;;;162    
;;;163    void  Mem_Init (void)
000000  480c              LDR      r0,|L5.52|
;;;164    {
;;;165    #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)
;;;166        MEM_POOL  *pmem_pool;
;;;167    
;;;168                                                                            /* --------- INIT MEM HEAP SEG / POOL --------- */
;;;169        pmem_pool                   = (MEM_POOL   *)&Mem_PoolHeap;
;;;170        pmem_pool->Type             = (LIB_MEM_TYPE) LIB_MEM_TYPE_HEAP;
000002  490d              LDR      r1,|L5.56|
;;;171        pmem_pool->SegHeadPtr       = (MEM_POOL   *)&Mem_PoolHeap;          /* Heap seg head = heap seg.                    */
000004  6001              STR      r1,[r0,#0]
;;;172        pmem_pool->SegPrevPtr       = (MEM_POOL   *) 0;
000006  2100              MOVS     r1,#0
000008  e9c00101          STRD     r0,r1,[r0,#4]
;;;173        pmem_pool->SegNextPtr       = (MEM_POOL   *) 0;
;;;174        pmem_pool->PoolPrevPtr      = (MEM_POOL   *) 0;
00000c  60c1              STR      r1,[r0,#0xc]
;;;175        pmem_pool->PoolNextPtr      = (MEM_POOL   *) 0;
00000e  6101              STR      r1,[r0,#0x10]
;;;176        pmem_pool->PoolAddrStart    = (void       *) 0;
000010  6141              STR      r1,[r0,#0x14]
;;;177        pmem_pool->PoolAddrEnd      = (void       *) 0;
000012  6181              STR      r1,[r0,#0x18]
;;;178        pmem_pool->PoolPtrs         = (void      **) 0;
000014  61c1              STR      r1,[r0,#0x1c]
;;;179        pmem_pool->BlkSize          = (CPU_SIZE_T  ) 0u;
000016  6201              STR      r1,[r0,#0x20]
;;;180        pmem_pool->BlkNbr           = (CPU_SIZE_T  ) 0u;
000018  6301              STR      r1,[r0,#0x30]
;;;181        pmem_pool->BlkIx            = (MEM_POOL_IX ) 0u;
00001a  62c1              STR      r1,[r0,#0x2c]
;;;182    
;;;183    #ifdef  LIB_MEM_CFG_HEAP_BASE_ADDR
;;;184        pmem_pool->SegAddr          = (void       *) LIB_MEM_CFG_HEAP_BASE_ADDR;
;;;185        pmem_pool->SegAddrNextAvail = (void       *) LIB_MEM_CFG_HEAP_BASE_ADDR;
;;;186    #else
;;;187        pmem_pool->SegAddr          = (void       *)&Mem_Heap[0];
00001c  6241              STR      r1,[r0,#0x24]
00001e  f1000148          ADD      r1,r0,#0x48
;;;188        pmem_pool->SegAddrNextAvail = (void       *)&Mem_Heap[0];
000022  6381              STR      r1,[r0,#0x38]
;;;189    #endif
;;;190    
;;;191        pmem_pool->SegSizeTot       = (CPU_SIZE_T  ) LIB_MEM_CFG_HEAP_SIZE;
000024  63c1              STR      r1,[r0,#0x3c]
000026  f44f6180          MOV      r1,#0x400
;;;192        pmem_pool->SegSizeRem       = (CPU_SIZE_T  ) LIB_MEM_CFG_HEAP_SIZE;
00002a  6401              STR      r1,[r0,#0x40]
;;;193    
;;;194                                                                            /* ------------ INIT MEM POOL TBL ------------- */
;;;195        Mem_PoolTbl = &Mem_PoolHeap;
00002c  6441              STR      r1,[r0,#0x44]
00002e  4903              LDR      r1,|L5.60|
000030  6008              STR      r0,[r1,#0]  ; Mem_PoolTbl
;;;196    #endif
;;;197    }
000032  4770              BX       lr
;;;198    
                          ENDP

                  |L5.52|
                          DCD      ||.bss||
                  |L5.56|
                          DCD      0x50414548
                  |L5.60|
                          DCD      ||.data||

                          AREA ||i.Mem_Move||, CODE, READONLY, ALIGN=2

                  Mem_Move PROC
;;;487    
;;;488    void  Mem_Move (       void        *pdest,
000000  b430              PUSH     {r4,r5}
;;;489                    const  void        *psrc,
;;;490                           CPU_SIZE_T   size)
;;;491    {
;;;492               CPU_SIZE_T    size_rem;
;;;493               CPU_SIZE_T    mem_gap_octets;
;;;494               CPU_ALIGN    *pmem_align_dest;
;;;495        const  CPU_ALIGN    *pmem_align_src;
;;;496               CPU_INT08U   *pmem_08_dest;
;;;497        const  CPU_INT08U   *pmem_08_src;
;;;498               CPU_INT08S    i;
;;;499               CPU_DATA      mem_align_mod_dest;
;;;500               CPU_DATA      mem_align_mod_src;
;;;501               CPU_BOOLEAN   mem_aligned;
;;;502    
;;;503    
;;;504    #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
;;;505        if (size < 1) {
;;;506            return;
;;;507        }
;;;508        if (pdest == (void *)0) {
;;;509            return;
;;;510        }
;;;511        if (psrc  == (void *)0) {
;;;512            return;
;;;513        }
;;;514    #endif
;;;515    
;;;516        pmem_08_src  = (const CPU_INT08U *)psrc;
;;;517        pmem_08_dest = (      CPU_INT08U *)pdest;
;;;518        if (pmem_08_src > pmem_08_dest) {
000002  4281              CMP      r1,r0
000004  d902              BLS      |L6.12|
;;;519            Mem_Copy(pdest, psrc, size);
000006  bc30              POP      {r4,r5}
000008  f7ffbffe          B.W      Mem_Copy
                  |L6.12|
;;;520            return;
;;;521        }
;;;522    
;;;523        size_rem           =  size;
;;;524    
;;;525        pmem_08_dest       = (      CPU_INT08U *)pdest + size - 1;
00000c  4410              ADD      r0,r0,r2
;;;526        pmem_08_src        = (const CPU_INT08U *)psrc  + size - 1;
00000e  4411              ADD      r1,r1,r2
000010  1e40              SUBS     r0,r0,#1              ;525
000012  1e49              SUBS     r1,r1,#1
;;;527    
;;;528        mem_gap_octets     = pmem_08_dest - pmem_08_src;
000014  1a43              SUBS     r3,r0,r1
;;;529    
;;;530    
;;;531        if (mem_gap_octets >= sizeof(CPU_ALIGN)) {                  /* Avoid bufs overlap.                                  */
000016  2b04              CMP      r3,#4
000018  d325              BCC      |L6.102|
;;;532    
;;;533                                                                    /* See Note #4.                                         */
;;;534            mem_align_mod_dest = (CPU_INT08U)((CPU_ADDR)pmem_08_dest % sizeof(CPU_ALIGN));
00001a  f0000303          AND      r3,r0,#3
;;;535            mem_align_mod_src  = (CPU_INT08U)((CPU_ADDR)pmem_08_src  % sizeof(CPU_ALIGN));
00001e  f0010403          AND      r4,r1,#3
;;;536    
;;;537            mem_aligned        = (mem_align_mod_dest == mem_align_mod_src) ? DEF_YES : DEF_NO;
000022  42a3              CMP      r3,r4
000024  d11f              BNE      |L6.102|
;;;538    
;;;539            if (mem_aligned == DEF_YES) {                           /* If mem bufs' alignment offset equal, ...             */
;;;540                                                                    /* ... optimize copy for mem buf alignment.             */
;;;541                if (mem_align_mod_dest != (sizeof(CPU_ALIGN) - 1)) {/* If leading octets avail,                   ...       */
000026  2b03              CMP      r3,#3
000028  d107              BNE      |L6.58|
00002a  e009              B        |L6.64|
                  |L6.44|
;;;542                    i = mem_align_mod_dest;
;;;543                    while ((size_rem   >  0) &&                     /* ... start mem buf copy with leading octets ...       */
;;;544                           (i          >= 0)) {                     /* ... until next CPU_ALIGN word boundary.              */
;;;545                       *pmem_08_dest-- = *pmem_08_src--;
;;;546                        size_rem      -=  sizeof(CPU_INT08U);
00002c  1e52              SUBS     r2,r2,#1
00002e  f8114901          LDRB     r4,[r1],#-1           ;545
;;;547                        i--;
000032  1e5b              SUBS     r3,r3,#1
000034  f8004901          STRB     r4,[r0],#-1           ;545
000038  b25b              SXTB     r3,r3
                  |L6.58|
00003a  b10a              CBZ      r2,|L6.64|
00003c  2b00              CMP      r3,#0                 ;544
00003e  daf5              BGE      |L6.44|
                  |L6.64|
;;;548                    }
;;;549                }
;;;550    
;;;551                                                                    /* See Note #3a.                                        */
;;;552                pmem_align_dest = (      CPU_ALIGN *)((CPU_INT08U *)pmem_08_dest - sizeof(CPU_ALIGN) + 1);
000040  1ec0              SUBS     r0,r0,#3
;;;553                pmem_align_src  = (const CPU_ALIGN *)((CPU_INT08U *)pmem_08_src  - sizeof(CPU_ALIGN) + 1);
000042  1ec9              SUBS     r1,r1,#3
;;;554                while (size_rem      >=  sizeof(CPU_ALIGN)) {       /* While mem bufs aligned on CPU_ALIGN word boundaries, */
000044  e005              B        |L6.82|
;;;555                   *pmem_align_dest-- = *pmem_align_src--;          /* ... copy psrc to pdest with CPU_ALIGN-sized words.   */
000046  bf00              NOP      
                  |L6.72|
000048  f8513904          LDR      r3,[r1],#-4
00004c  f8403904          STR      r3,[r0],#-4
;;;556                    size_rem         -=  sizeof(CPU_ALIGN);
000050  1f12              SUBS     r2,r2,#4
                  |L6.82|
000052  2a04              CMP      r2,#4                 ;554
000054  d2f8              BCS      |L6.72|
;;;557                }
;;;558    
;;;559                pmem_08_dest = (      CPU_INT08U *)pmem_align_dest + sizeof(CPU_ALIGN) - 1;
000056  1cc0              ADDS     r0,r0,#3
;;;560                pmem_08_src  = (const CPU_INT08U *)pmem_align_src  + sizeof(CPU_ALIGN) - 1;
000058  1cc9              ADDS     r1,r1,#3
00005a  e004              B        |L6.102|
                  |L6.92|
;;;561    
;;;562            }
;;;563        }
;;;564    
;;;565        while (size_rem > 0) {                                      /* For unaligned mem bufs or trailing octets, ...       */
;;;566           *pmem_08_dest-- = *pmem_08_src--;                        /* ... copy psrc to pdest by octets.                    */
00005c  f8113901          LDRB     r3,[r1],#-1
000060  f8003901          STRB     r3,[r0],#-1
;;;567            size_rem      -=  sizeof(CPU_INT08U);
000064  1e52              SUBS     r2,r2,#1
                  |L6.102|
000066  2a00              CMP      r2,#0                 ;565
000068  d1f8              BNE      |L6.92|
;;;568        }
;;;569    }
00006a  bc30              POP      {r4,r5}
00006c  4770              BX       lr
;;;570    
                          ENDP


                          AREA ||i.Mem_PoolBlkFree||, CODE, READONLY, ALIGN=1

                  Mem_PoolBlkFree PROC
;;;1858   #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)
;;;1859   void  Mem_PoolBlkFree (MEM_POOL  *pmem_pool,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1860                          void      *pmem_blk,
;;;1861                          LIB_ERR   *perr)
;;;1862   {
000004  4615              MOV      r5,r2
000006  460e              MOV      r6,r1
000008  4604              MOV      r4,r0
;;;1863       void         *p_addr;
;;;1864       CPU_BOOLEAN   addr_valid;
;;;1865       MEM_POOL_IX   i;
;;;1866       CPU_SR_ALLOC();
;;;1867   
;;;1868   
;;;1869   #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* ------------- VALIDATE RTN ERR PTR ------------- */
;;;1870       if (perr == (LIB_ERR *)0) {
;;;1871           CPU_SW_EXCEPTION(;);
;;;1872       }
;;;1873   #endif
;;;1874   
;;;1875                                                                       /* ------------ VALIDATE MEM POOL FREE ------------ */
;;;1876   #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* Validate mem ptrs.                               */
;;;1877       if (pmem_pool == (MEM_POOL *)0) {
;;;1878          *perr = LIB_MEM_ERR_NULL_PTR;
;;;1879           return;
;;;1880       }
;;;1881   
;;;1882       if (pmem_blk == (void *)0) {
;;;1883          *perr = LIB_MEM_ERR_NULL_PTR;
;;;1884           return;
;;;1885       }
;;;1886   #endif
;;;1887   
;;;1888       CPU_CRITICAL_ENTER();
00000a  f7fffffe          BL       CPU_SR_Save
;;;1889   
;;;1890   #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
;;;1891       if (pmem_pool->Type != LIB_MEM_TYPE_POOL) {                     /* Validate mem pool type.                          */
;;;1892           CPU_CRITICAL_EXIT();
;;;1893          *perr = LIB_MEM_ERR_INVALID_POOL;
;;;1894           return;
;;;1895       }
;;;1896   
;;;1897       addr_valid = Mem_PoolBlkIsValidAddr(pmem_pool, pmem_blk);       /* Validate mem blk as valid pool blk addr.         */
;;;1898       if (addr_valid != DEF_OK) {
;;;1899           CPU_CRITICAL_EXIT();
;;;1900          *perr = LIB_MEM_ERR_INVALID_BLK_ADDR;
;;;1901           return;
;;;1902       }
;;;1903   
;;;1904       for (i = 0u; i < pmem_pool->BlkIx; i++) {                       /* Validate mem blk  NOT already in pool.           */
;;;1905           if (pmem_blk == pmem_pool->PoolPtrs[i]) {
;;;1906               CPU_CRITICAL_EXIT();
;;;1907              *perr = LIB_MEM_ERR_INVALID_BLK_ADDR_IN_POOL;
;;;1908               return;
;;;1909           }
;;;1910       }
;;;1911   #endif
;;;1912   
;;;1913       if (pmem_pool->BlkIx >= pmem_pool->BlkNbr) {                    /* Validate mem pool NOT already full.              */
00000e  6ae2              LDR      r2,[r4,#0x2c]
000010  6a61              LDR      r1,[r4,#0x24]
000012  4607              MOV      r7,r0                 ;1888
000014  4291              CMP      r1,r2
000016  d304              BCC      |L7.34|
;;;1914           CPU_CRITICAL_EXIT();
000018  f7fffffe          BL       CPU_SR_Restore
;;;1915          *perr = LIB_MEM_ERR_POOL_FULL;
00001c  f24270dd          MOV      r0,#0x27dd
;;;1916           return;
000020  e01a              B        |L7.88|
                  |L7.34|
;;;1917       }
;;;1918   
;;;1919                                                                       /* ------------- FREE MEM BLK TO POOL ------------- */
;;;1920       addr_valid = DEF_NO;
;;;1921       for (i = pmem_pool->BlkIx; i < pmem_pool->BlkNbr; i++) {        /* Find ix of mem blk to free.                      */
000022  460b              MOV      r3,r1
000024  6a20              LDR      r0,[r4,#0x20]
000026  e009              B        |L7.60|
                  |L7.40|
;;;1922           p_addr = pmem_pool->PoolPtrs[i];
000028  f850c023          LDR      r12,[r0,r3,LSL #2]
;;;1923           if (p_addr == pmem_blk) {
00002c  45b4              CMP      r12,r6
00002e  d104              BNE      |L7.58|
;;;1924               addr_valid = DEF_YES;
;;;1925               break;
;;;1926           }
;;;1927       }
;;;1928                                                                       /* Swap addr of mem blk to free in tbl.             */
;;;1929       if (addr_valid == DEF_YES) {
;;;1930           pmem_pool->PoolPtrs[i] = pmem_pool->PoolPtrs[pmem_pool->BlkIx];
000030  f8501021          LDR      r1,[r0,r1,LSL #2]
000034  f8401023          STR      r1,[r0,r3,LSL #2]
000038  e002              B        |L7.64|
                  |L7.58|
00003a  1c5b              ADDS     r3,r3,#1              ;1921
                  |L7.60|
00003c  429a              CMP      r2,r3                 ;1921
00003e  d8f3              BHI      |L7.40|
                  |L7.64|
000040  e9d40108          LDRD     r0,r1,[r4,#0x20]      ;1921
;;;1931       } else {
;;;1932   #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
;;;1933           CPU_CRITICAL_EXIT();
;;;1934          *perr = LIB_MEM_ERR_INVALID_POOL;
;;;1935           return;
;;;1936   #endif
;;;1937       }
;;;1938   
;;;1939                                                                       /* Free mem blk.                                    */
;;;1940       pmem_pool->PoolPtrs[pmem_pool->BlkIx] = pmem_blk;
000044  f8406021          STR      r6,[r0,r1,LSL #2]
;;;1941       pmem_pool->BlkIx++;
000048  6a60              LDR      r0,[r4,#0x24]
00004a  1c40              ADDS     r0,r0,#1
;;;1942   
;;;1943       CPU_CRITICAL_EXIT();
00004c  6260              STR      r0,[r4,#0x24]
00004e  4638              MOV      r0,r7
000050  f7fffffe          BL       CPU_SR_Restore
;;;1944   
;;;1945      *perr = LIB_MEM_ERR_NONE;
000054  f2427010          MOV      r0,#0x2710
                  |L7.88|
000058  8028              STRH     r0,[r5,#0]
;;;1946   }
00005a  e8bd81f0          POP      {r4-r8,pc}
;;;1947   #endif
                          ENDP


                          AREA ||i.Mem_PoolBlkGet||, CODE, READONLY, ALIGN=1

                  Mem_PoolBlkGet PROC
;;;1658   #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)
;;;1659   void  *Mem_PoolBlkGet (MEM_POOL    *pmem_pool,
000000  b570              PUSH     {r4-r6,lr}
;;;1660                          CPU_SIZE_T   size,
;;;1661                          LIB_ERR     *perr)
;;;1662   {
000002  4615              MOV      r5,r2
000004  4604              MOV      r4,r0
;;;1663       void  *pmem_blk;
;;;1664       CPU_SR_ALLOC();
;;;1665   
;;;1666   
;;;1667   #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* ------------- VALIDATE RTN ERR PTR ------------- */
;;;1668       if (perr == (LIB_ERR *)0) {
;;;1669           CPU_SW_EXCEPTION((void *)0);
;;;1670       }
;;;1671   #endif
;;;1672   
;;;1673                                                                       /* ------------ VALIDATE MEM POOL GET ------------- */
;;;1674   #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
;;;1675       if (pmem_pool == (MEM_POOL *)0) {                               /* Validate mem ptr.                                */
;;;1676          *perr = LIB_MEM_ERR_NULL_PTR;
;;;1677           return ((void *)0);
;;;1678       }
;;;1679   
;;;1680       if (size < 1) {                                                 /* Validate req'd size as non-NULL.                 */
;;;1681          *perr = LIB_MEM_ERR_INVALID_BLK_SIZE;
;;;1682           return ((void *)0);
;;;1683       }
;;;1684   #endif
;;;1685   
;;;1686       CPU_CRITICAL_ENTER();
000006  f7fffffe          BL       CPU_SR_Save
00000a  4601              MOV      r1,r0
;;;1687   
;;;1688   #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
;;;1689       if (pmem_pool->Type != LIB_MEM_TYPE_POOL) {                     /* Validate mem pool type.                          */
;;;1690           CPU_CRITICAL_EXIT();
;;;1691          *perr = LIB_MEM_ERR_INVALID_POOL;
;;;1692           return ((void *)0);
;;;1693       }
;;;1694   
;;;1695       if (size > pmem_pool->BlkSize) {                                /* Validate req'd size <= mem pool blk size.        */
;;;1696           CPU_CRITICAL_EXIT();
;;;1697          *perr = LIB_MEM_ERR_INVALID_BLK_SIZE;
;;;1698           return ((void *)0);
;;;1699       }
;;;1700   #endif
;;;1701   
;;;1702      (void)&size;                                                     /* Prevent possible 'variable unused' warning.      */
;;;1703   
;;;1704       if (pmem_pool->BlkIx < 1) {                                     /* Validate mem pool as NOT empty.                  */
00000c  6a60              LDR      r0,[r4,#0x24]
00000e  b150              CBZ      r0,|L8.38|
;;;1705           CPU_CRITICAL_EXIT();
;;;1706          *perr = LIB_MEM_ERR_POOL_EMPTY;
;;;1707           return ((void *)0);
;;;1708       }
;;;1709   
;;;1710       if (pmem_pool->BlkIx > pmem_pool->BlkNbr) {                     /* Validate mem pool ix NOT corrupt.                */
000010  6ae2              LDR      r2,[r4,#0x2c]
000012  4290              CMP      r0,r2
000014  d90d              BLS      |L8.50|
;;;1711           CPU_CRITICAL_EXIT();
000016  4608              MOV      r0,r1
000018  f7fffffe          BL       CPU_SR_Restore
;;;1712          *perr = LIB_MEM_ERR_INVALID_BLK_IX;
00001c  f2427095          MOV      r0,#0x2795
                  |L8.32|
000020  8028              STRH     r0,[r5,#0]
;;;1713           return ((void *)0);
000022  2000              MOVS     r0,#0
;;;1714       }
;;;1715   
;;;1716                                                                       /* ------------ GET MEM BLK FROM POOL ------------- */
;;;1717       pmem_pool->BlkIx--;
;;;1718       pmem_blk = pmem_pool->PoolPtrs[pmem_pool->BlkIx];
;;;1719   
;;;1720       CPU_CRITICAL_EXIT();
;;;1721   
;;;1722      *perr =  LIB_MEM_ERR_NONE;
;;;1723   
;;;1724       return (pmem_blk);
;;;1725   }
000024  bd70              POP      {r4-r6,pc}
                  |L8.38|
000026  4608              MOV      r0,r1                 ;1705
000028  f7fffffe          BL       CPU_SR_Restore
00002c  f24270de          MOV      r0,#0x27de            ;1706
000030  e7f6              B        |L8.32|
                  |L8.50|
000032  1e40              SUBS     r0,r0,#1              ;1717
000034  6260              STR      r0,[r4,#0x24]         ;1718
000036  6a22              LDR      r2,[r4,#0x20]         ;1718
000038  f8524020          LDR      r4,[r2,r0,LSL #2]     ;1718
00003c  4608              MOV      r0,r1                 ;1720
00003e  f7fffffe          BL       CPU_SR_Restore
000042  f2427010          MOV      r0,#0x2710            ;1722
000046  8028              STRH     r0,[r5,#0]            ;1722
000048  4620              MOV      r0,r4                 ;1724
00004a  bd70              POP      {r4-r6,pc}
;;;1726   #endif
                          ENDP


                          AREA ||i.Mem_PoolBlkGetNbrAvail||, CODE, READONLY, ALIGN=1

                  Mem_PoolBlkGetNbrAvail PROC
;;;1578   #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)
;;;1579   MEM_POOL_BLK_QTY  Mem_PoolBlkGetNbrAvail (MEM_POOL  *pmem_pool,
000000  b570              PUSH     {r4-r6,lr}
;;;1580                                             LIB_ERR   *perr)
;;;1581   {
000002  460c              MOV      r4,r1
000004  4605              MOV      r5,r0
;;;1582       MEM_POOL_BLK_QTY  nbr_blk_rem;
;;;1583       CPU_SR_ALLOC();
;;;1584   
;;;1585   
;;;1586   #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
;;;1587                                                                   /* --------------- VALIDATE RTN ERR PTR --------------- */
;;;1588       if (perr == (LIB_ERR *)0) {
;;;1589           CPU_SW_EXCEPTION(0u);
;;;1590       }
;;;1591                                                                   /* ---------------- VALIDATE MEM POOL ----------------- */
;;;1592       if (pmem_pool == (MEM_POOL *)0) {                           /* Validate mem ptr.                                    */
;;;1593          *perr =  LIB_MEM_ERR_NULL_PTR;
;;;1594           return (0u);
;;;1595       }
;;;1596   #endif
;;;1597   
;;;1598       CPU_CRITICAL_ENTER();
000006  f7fffffe          BL       CPU_SR_Save
;;;1599   
;;;1600   #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
;;;1601       switch (pmem_pool->Type) {                                  /* Validate mem pool type.                              */
;;;1602           case LIB_MEM_TYPE_POOL:
;;;1603                break;
;;;1604   
;;;1605   
;;;1606           case LIB_MEM_TYPE_NONE:
;;;1607           case LIB_MEM_TYPE_HEAP:
;;;1608           default:
;;;1609                CPU_CRITICAL_EXIT();
;;;1610               *perr =  LIB_MEM_ERR_INVALID_POOL;
;;;1611                return (0u);                                       /* Prevent 'break NOT reachable' compiler warning.      */
;;;1612       }
;;;1613   #endif
;;;1614   
;;;1615                                                                   /* --------- GET REM'ING MEM POOL NBR BLK(S) ---------- */
;;;1616       nbr_blk_rem = pmem_pool->BlkIx;
00000a  6a6d              LDR      r5,[r5,#0x24]
;;;1617   
;;;1618       CPU_CRITICAL_EXIT();
00000c  f7fffffe          BL       CPU_SR_Restore
;;;1619   
;;;1620   
;;;1621      *perr =  LIB_MEM_ERR_NONE;
000010  f2427010          MOV      r0,#0x2710
000014  8020              STRH     r0,[r4,#0]
;;;1622   
;;;1623       return (nbr_blk_rem);
000016  4628              MOV      r0,r5
;;;1624   }
000018  bd70              POP      {r4-r6,pc}
;;;1625   #endif
                          ENDP


                          AREA ||i.Mem_PoolBlkGetUsedAtIx||, CODE, READONLY, ALIGN=1

                  Mem_PoolBlkGetUsedAtIx PROC
;;;1762   #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)
;;;1763   void  *Mem_PoolBlkGetUsedAtIx (MEM_POOL          *pmem_pool,
000000  b570              PUSH     {r4-r6,lr}
;;;1764                                  MEM_POOL_IX        used_ix,
;;;1765                                  LIB_ERR           *perr)
;;;1766   {
000002  4614              MOV      r4,r2
000004  460e              MOV      r6,r1
000006  4605              MOV      r5,r0
;;;1767       MEM_POOL_IX   blk_ix;
;;;1768       void         *pmem_blk;
;;;1769       CPU_SR_ALLOC();
;;;1770   
;;;1771   
;;;1772   #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* ------------- VALIDATE RTN ERR PTR ------------- */
;;;1773       if (perr == (LIB_ERR *)0) {
;;;1774           CPU_SW_EXCEPTION((void *)0);
;;;1775       }
;;;1776   #endif
;;;1777   
;;;1778                                                                       /* ------------ VALIDATE MEM POOL GET ------------- */
;;;1779   #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
;;;1780       if (pmem_pool == (MEM_POOL *)0) {                               /* Validate mem ptr.                                */
;;;1781          *perr = LIB_MEM_ERR_NULL_PTR;
;;;1782           return ((void *)0);
;;;1783       }
;;;1784   #endif
;;;1785   
;;;1786       CPU_CRITICAL_ENTER();
000008  f7fffffe          BL       CPU_SR_Save
;;;1787   
;;;1788   #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
;;;1789       if (pmem_pool->Type != LIB_MEM_TYPE_POOL) {                     /* Validate mem pool type.                          */
;;;1790           CPU_CRITICAL_EXIT();
;;;1791          *perr = LIB_MEM_ERR_INVALID_POOL;
;;;1792           return ((void *)0);
;;;1793       }
;;;1794   
;;;1795       if (pmem_pool->BlkIx >= pmem_pool->BlkNbr) {                    /* Validate mem pool as NOT full.                   */
;;;1796           CPU_CRITICAL_EXIT();
;;;1797          *perr = LIB_MEM_ERR_INVALID_BLK_IX;
;;;1798           return ((void *)0);
;;;1799       }
;;;1800   #endif
;;;1801   
;;;1802       blk_ix = pmem_pool->BlkNbr - used_ix - 1u;
00000c  6aea              LDR      r2,[r5,#0x2c]
00000e  1b91              SUBS     r1,r2,r6
000010  1e49              SUBS     r1,r1,#1
;;;1803   
;;;1804       if (blk_ix >= pmem_pool->BlkNbr) {                              /* Validate ix range.                               */
;;;1805           CPU_CRITICAL_EXIT();
;;;1806          *perr = LIB_MEM_ERR_INVALID_BLK_IX;
000012  f2427695          MOV      r6,#0x2795
000016  428a              CMP      r2,r1                 ;1804
000018  d902              BLS      |L10.32|
;;;1807           return ((void *)0);
;;;1808       }
;;;1809   
;;;1810       if (blk_ix < pmem_pool->BlkIx) {
00001a  6a6a              LDR      r2,[r5,#0x24]
00001c  428a              CMP      r2,r1
00001e  d904              BLS      |L10.42|
                  |L10.32|
;;;1811           CPU_CRITICAL_EXIT();
000020  f7fffffe          BL       CPU_SR_Restore
;;;1812          *perr = LIB_MEM_ERR_INVALID_BLK_IX;
000024  8026              STRH     r6,[r4,#0]
;;;1813           return ((void *)0);
000026  2000              MOVS     r0,#0
;;;1814       }
;;;1815                                                                       /* ------------ GET MEM BLK FROM POOL ------------- */
;;;1816       pmem_blk = pmem_pool->PoolPtrs[blk_ix];
;;;1817   
;;;1818       CPU_CRITICAL_EXIT();
;;;1819   
;;;1820      *perr =  LIB_MEM_ERR_NONE;
;;;1821   
;;;1822       return (pmem_blk);
;;;1823   }
000028  bd70              POP      {r4-r6,pc}
                  |L10.42|
00002a  6a2a              LDR      r2,[r5,#0x20]         ;1816
00002c  f8525021          LDR      r5,[r2,r1,LSL #2]     ;1816
000030  f7fffffe          BL       CPU_SR_Restore
000034  f2427010          MOV      r0,#0x2710            ;1820
000038  8020              STRH     r0,[r4,#0]            ;1820
00003a  4628              MOV      r0,r5                 ;1822
00003c  bd70              POP      {r4-r6,pc}
;;;1824   #endif
                          ENDP


                          AREA ||i.Mem_PoolBlkIxGet||, CODE, READONLY, ALIGN=1

                  Mem_PoolBlkIxGet PROC
;;;1985   #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)
;;;1986   MEM_POOL_IX  Mem_PoolBlkIxGet (MEM_POOL  *pmem_pool,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1987                                  void      *pmem_blk,
;;;1988                                  LIB_ERR   *perr)
;;;1989   {
000004  4614              MOV      r4,r2
000006  460f              MOV      r7,r1
000008  4605              MOV      r5,r0
;;;1990       void         *p_addr;
;;;1991       CPU_BOOLEAN   addr_valid;
;;;1992       MEM_POOL_IX   i;
;;;1993       MEM_POOL_IX   pool_ix;
;;;1994       MEM_POOL_IX   invalid_ix;
;;;1995       CPU_SR_ALLOC();
;;;1996   
;;;1997   
;;;1998       invalid_ix = DEF_GET_U_MAX_VAL(MEM_POOL_IX);
00000a  f04f36ff          MOV      r6,#0xffffffff
;;;1999   #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* ------------- VALIDATE RTN ERR PTR ------------- */
;;;2000       if (perr == (LIB_ERR *)0) {
;;;2001           CPU_SW_EXCEPTION(invalid_ix);
;;;2002       }
;;;2003   #endif
;;;2004   
;;;2005                                                                       /* ------------ VALIDATE MEM POOL FREE ------------ */
;;;2006   #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* Validate mem ptrs.                               */
;;;2007       if (pmem_pool == (MEM_POOL *)0) {
;;;2008          *perr = LIB_MEM_ERR_NULL_PTR;
;;;2009           return (invalid_ix);
;;;2010       }
;;;2011   
;;;2012       if (pmem_blk == (void *)0) {
;;;2013          *perr = LIB_MEM_ERR_NULL_PTR;
;;;2014           return (invalid_ix);
;;;2015       }
;;;2016   #endif
;;;2017   
;;;2018       CPU_CRITICAL_ENTER();
00000e  f7fffffe          BL       CPU_SR_Save
000012  4602              MOV      r2,r0
;;;2019   
;;;2020   #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
;;;2021       if (pmem_pool->Type != LIB_MEM_TYPE_POOL) {                     /* Validate mem pool type.                          */
;;;2022           CPU_CRITICAL_EXIT();
;;;2023          *perr = LIB_MEM_ERR_INVALID_POOL;
;;;2024           return(invalid_ix);
;;;2025       }
;;;2026   
;;;2027       addr_valid = Mem_PoolBlkIsValidAddr(pmem_pool, pmem_blk);       /* Validate mem blk as valid pool blk addr.         */
;;;2028       if (addr_valid != DEF_OK) {
;;;2029           CPU_CRITICAL_EXIT();
;;;2030          *perr = LIB_MEM_ERR_INVALID_BLK_ADDR;
;;;2031           return (invalid_ix);
;;;2032       }
;;;2033   
;;;2034       for (i = 0u; i < pmem_pool->BlkIx; i++) {                       /* Validate mem blk  NOT already in pool.           */
;;;2035           if (pmem_blk == pmem_pool->PoolPtrs[i]) {
;;;2036               CPU_CRITICAL_EXIT();
;;;2037              *perr = LIB_MEM_ERR_INVALID_BLK_ADDR_IN_POOL;
;;;2038               return (invalid_ix);
;;;2039           }
;;;2040       }
;;;2041   #endif
;;;2042   
;;;2043       if (pmem_pool->BlkIx >= pmem_pool->BlkNbr) {                    /* Validate mem pool NOT full.                      */
000014  6ae9              LDR      r1,[r5,#0x2c]
000016  6a68              LDR      r0,[r5,#0x24]
000018  4288              CMP      r0,r1
00001a  d316              BCC      |L11.74|
;;;2044           CPU_CRITICAL_EXIT();
00001c  4610              MOV      r0,r2
00001e  f7fffffe          BL       CPU_SR_Restore
;;;2045          *perr = LIB_MEM_ERR_POOL_FULL;
000022  f24270dd          MOV      r0,#0x27dd
;;;2046           return (invalid_ix);
000026  e017              B        |L11.88|
                  |L11.40|
;;;2047       }
;;;2048   
;;;2049       addr_valid = DEF_NO;
;;;2050       for (i = pmem_pool->BlkIx; i < pmem_pool->BlkNbr; i++) {        /* Find ix of mem blk.                              */
;;;2051           p_addr = pmem_pool->PoolPtrs[i];
000028  6a2b              LDR      r3,[r5,#0x20]
00002a  f8533020          LDR      r3,[r3,r0,LSL #2]
;;;2052           if (p_addr == pmem_blk) {
00002e  42bb              CMP      r3,r7
000030  d10a              BNE      |L11.72|
;;;2053               addr_valid = DEF_YES;
;;;2054               break;
;;;2055           }
;;;2056       }
;;;2057                                                                       /* Return ix of mem blk in tbl.                     */
;;;2058       if (addr_valid == DEF_YES) {
;;;2059           pool_ix = pmem_pool->BlkNbr - 1 - i;
000032  1a0d              SUBS     r5,r1,r0
000034  1e6d              SUBS     r5,r5,#1
;;;2060           CPU_CRITICAL_EXIT();
000036  4610              MOV      r0,r2
000038  f7fffffe          BL       CPU_SR_Restore
;;;2061          *perr = LIB_MEM_ERR_NONE;
00003c  f2427010          MOV      r0,#0x2710
000040  8020              STRH     r0,[r4,#0]
;;;2062           return (pool_ix);
000042  4628              MOV      r0,r5
                  |L11.68|
;;;2063       } else {
;;;2064           CPU_CRITICAL_EXIT();
;;;2065          *perr = LIB_MEM_ERR_INVALID_POOL;
;;;2066           return (invalid_ix);
;;;2067       }
;;;2068   
;;;2069   }
000044  e8bd81f0          POP      {r4-r8,pc}
                  |L11.72|
000048  1c40              ADDS     r0,r0,#1              ;2050
                  |L11.74|
00004a  4281              CMP      r1,r0                 ;2050
00004c  d8ec              BHI      |L11.40|
00004e  4610              MOV      r0,r2                 ;2064
000050  f7fffffe          BL       CPU_SR_Restore
000054  f2427088          MOV      r0,#0x2788            ;2065
                  |L11.88|
000058  8020              STRH     r0,[r4,#0]            ;2065
00005a  4630              MOV      r0,r6                 ;2066
00005c  e7f2              B        |L11.68|
;;;2070   #endif
                          ENDP


                          AREA ||i.Mem_PoolClr||, CODE, READONLY, ALIGN=2

                  Mem_PoolClr PROC
;;;1003   #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)
;;;1004   void  Mem_PoolClr (MEM_POOL  *pmem_pool,
000000  b1b8              CBZ      r0,|L12.50|
;;;1005                      LIB_ERR   *perr)
;;;1006   {
;;;1007   
;;;1008   #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                 /* -------------- VALIDATE RTN ERR  PTR --------------- */
;;;1009       if (perr == (LIB_ERR *)0) {
;;;1010           CPU_SW_EXCEPTION(;);
;;;1011       }
;;;1012   #endif
;;;1013   
;;;1014                                                                   /* -------------- VALIDATE MEM POOL PTR --------------- */
;;;1015       if (pmem_pool == (MEM_POOL *)0) {
;;;1016          *perr = LIB_MEM_ERR_NULL_PTR;
;;;1017           return;
;;;1018       }
;;;1019   
;;;1020   
;;;1021       pmem_pool->Type             = (LIB_MEM_TYPE)LIB_MEM_TYPE_NONE;
000002  4a0d              LDR      r2,|L12.56|
;;;1022       pmem_pool->SegHeadPtr       = (MEM_POOL   *)0;
000004  6002              STR      r2,[r0,#0]
000006  2200              MOVS     r2,#0
;;;1023       pmem_pool->SegPrevPtr       = (MEM_POOL   *)0;
000008  6042              STR      r2,[r0,#4]
;;;1024       pmem_pool->SegNextPtr       = (MEM_POOL   *)0;
00000a  6082              STR      r2,[r0,#8]
;;;1025       pmem_pool->PoolPrevPtr      = (MEM_POOL   *)0;
00000c  60c2              STR      r2,[r0,#0xc]
;;;1026       pmem_pool->PoolNextPtr      = (MEM_POOL   *)0;
00000e  6102              STR      r2,[r0,#0x10]
;;;1027       pmem_pool->PoolAddrStart    = (void       *)0;
000010  6142              STR      r2,[r0,#0x14]
;;;1028       pmem_pool->PoolAddrEnd      = (void       *)0;
000012  6182              STR      r2,[r0,#0x18]
;;;1029       pmem_pool->PoolPtrs         = (void      **)0;
000014  61c2              STR      r2,[r0,#0x1c]
;;;1030       pmem_pool->PoolSize         = (CPU_SIZE_T  )0u;
000016  6202              STR      r2,[r0,#0x20]
;;;1031       pmem_pool->BlkAlign         = (CPU_SIZE_T  )0u;
000018  6282              STR      r2,[r0,#0x28]
;;;1032       pmem_pool->BlkSize          = (CPU_SIZE_T  )0u;
00001a  6342              STR      r2,[r0,#0x34]
;;;1033       pmem_pool->BlkNbr           = (CPU_SIZE_T  )0u;
00001c  6302              STR      r2,[r0,#0x30]
;;;1034       pmem_pool->BlkIx            = (MEM_POOL_IX )0u;
00001e  62c2              STR      r2,[r0,#0x2c]
;;;1035       pmem_pool->SegAddr          = (void       *)0;
000020  6242              STR      r2,[r0,#0x24]
;;;1036       pmem_pool->SegAddrNextAvail = (void       *)0;
000022  6382              STR      r2,[r0,#0x38]
;;;1037       pmem_pool->SegSizeTot       = (CPU_SIZE_T  )0u;
000024  63c2              STR      r2,[r0,#0x3c]
;;;1038       pmem_pool->SegSizeRem       = (CPU_SIZE_T  )0u;
000026  6402              STR      r2,[r0,#0x40]
;;;1039   
;;;1040   
;;;1041      *perr = LIB_MEM_ERR_NONE;
000028  6442              STR      r2,[r0,#0x44]
00002a  f2427010          MOV      r0,#0x2710
                  |L12.46|
00002e  8008              STRH     r0,[r1,#0]
;;;1042   }
000030  4770              BX       lr
                  |L12.50|
000032  f2427011          MOV      r0,#0x2711            ;1016
000036  e7fa              B        |L12.46|
;;;1043   #endif
                          ENDP

                  |L12.56|
                          DCD      0x454e4f4e

                          AREA ||i.Mem_PoolCreate||, CODE, READONLY, ALIGN=2

                  Mem_PoolCreate PROC
;;;1197   #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)
;;;1198   void  Mem_PoolCreate (MEM_POOL          *pmem_pool,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;1199                         void              *pmem_base_addr,
;;;1200                         CPU_SIZE_T         mem_size,
;;;1201                         MEM_POOL_BLK_QTY   blk_nbr,
;;;1202                         CPU_SIZE_T         blk_size,
;;;1203                         CPU_SIZE_T         blk_align,
;;;1204                         CPU_SIZE_T        *poctets_reqd,
;;;1205                         LIB_ERR           *perr)
;;;1206   {
000004  b08b              SUB      sp,sp,#0x2c
000006  4693              MOV      r11,r2
000008  e9dd791a          LDRD     r7,r9,[sp,#0x68]
00000c  468a              MOV      r10,r1
00000e  4604              MOV      r4,r0
000010  b907              CBNZ     r7,|L13.20|
;;;1207       MEM_POOL           *pmem_pool_heap;
;;;1208       MEM_POOL           *pmem_pool_next;
;;;1209       MEM_POOL           *pmem_seg;
;;;1210       MEM_POOL           *pmem_seg_prev;
;;;1211       MEM_POOL           *pmem_seg_next;
;;;1212       void              **ppool_ptr;
;;;1213       void               *pmem_blk;
;;;1214       CPU_INT08U         *pmem_addr_ptrs;
;;;1215       CPU_INT08U         *pmem_addr_pool;
;;;1216       CPU_INT08U         *pmem_base_addr_start;
;;;1217       CPU_INT08U         *pmem_base_addr_end;
;;;1218       CPU_INT08U         *pmem_seg_addr_start;
;;;1219       CPU_INT08U         *pmem_seg_addr_end;
;;;1220       MEM_POOL_BLK_QTY    blk_rem;
;;;1221       CPU_SIZE_T          octets_reqd_unused;
;;;1222       CPU_SIZE_T          size_tot;
;;;1223       CPU_SIZE_T          size_tot_ptrs;
;;;1224       CPU_SIZE_T          size_tot_pool;
;;;1225       CPU_SIZE_T          size_rem;
;;;1226       CPU_SIZE_T          size_pool_ptrs;
;;;1227       CPU_SIZE_T          i;
;;;1228       CPU_SR_ALLOC();
;;;1229   
;;;1230   
;;;1231   #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* ------------- VALIDATE RTN ERR PTR ------------- */
;;;1232       if (perr == (LIB_ERR *)0) {
;;;1233           CPU_SW_EXCEPTION(;);
;;;1234       }
;;;1235   #endif
;;;1236   
;;;1237                                                                       /* ------------ VALIDATE RTN OCTETS PTR ----------- */
;;;1238       if (poctets_reqd == (CPU_SIZE_T *) 0) {                         /* If NOT avail, ...                                */
;;;1239           poctets_reqd  = (CPU_SIZE_T *)&octets_reqd_unused;          /* ... re-cfg NULL rtn ptr to unused local var.     */
000012  af0a              ADD      r7,sp,#0x28
                  |L13.20|
;;;1240          (void)&octets_reqd_unused;                                   /* Prevent possible 'variable unused' warning.      */
;;;1241       }
;;;1242      *poctets_reqd = 0u;                                              /* Init octets req'd for err (see Note #4).         */
000014  2000              MOVS     r0,#0
;;;1243   
;;;1244   
;;;1245   
;;;1246       Mem_PoolClr(pmem_pool, perr);                                   /* Init mem pool     for err (see Note #4).         */
000016  6038              STR      r0,[r7,#0]
000018  4649              MOV      r1,r9
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       Mem_PoolClr
;;;1247       if (*perr != LIB_MEM_ERR_NONE) {
000020  f8b91000          LDRH     r1,[r9,#0]
000024  f5a1501c          SUB      r0,r1,#0x2700
000028  3810              SUBS     r0,r0,#0x10
00002a  d156              BNE      |L13.218|
;;;1248            return;
;;;1249       }
;;;1250   
;;;1251   
;;;1252                                                                       /* ----------- VALIDATE MEM POOL CREATE ----------- */
;;;1253   #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
;;;1254       if (pmem_base_addr != (void *)0) {
;;;1255           if (mem_size < 1) {
;;;1256              *perr = LIB_MEM_ERR_INVALID_SEG_SIZE;
;;;1257               return;
;;;1258           }
;;;1259       }
;;;1260   
;;;1261       if (blk_nbr < 1) {
;;;1262          *perr = LIB_MEM_ERR_INVALID_BLK_NBR;
;;;1263           return;
;;;1264       }
;;;1265   
;;;1266       if (blk_size < 1) {
;;;1267          *perr = LIB_MEM_ERR_INVALID_BLK_SIZE;
;;;1268           return;
;;;1269       }
;;;1270   
;;;1271       if (blk_align < 1) {
;;;1272          *perr = LIB_MEM_ERR_INVALID_BLK_ALIGN;
;;;1273           return;
;;;1274       }
;;;1275   #endif
;;;1276   
;;;1277   
;;;1278                                                                       /* ------------ VALIDATE MEM POOL TBL ------------- */
;;;1279       if (Mem_PoolTbl == (MEM_POOL *)0) {
00002c  487e              LDR      r0,|L13.552|
00002e  6800              LDR      r0,[r0,#0]  ; Mem_PoolTbl
000030  b188              CBZ      r0,|L13.86|
;;;1280          *perr = LIB_MEM_ERR_HEAP_NOT_FOUND;
;;;1281           return;
;;;1282       }
;;;1283   
;;;1284   
;;;1285                                                                       /* ---------------- CREATE MEM POOL --------------- */
;;;1286       pmem_pool_heap = (MEM_POOL *)&Mem_PoolHeap;
;;;1287       size_tot       = (CPU_SIZE_T) 0u;
000032  2000              MOVS     r0,#0
000034  f8df81f4          LDR      r8,|L13.556|
;;;1288   
;;;1289       CPU_CRITICAL_ENTER();
000038  9002              STR      r0,[sp,#8]
00003a  f7fffffe          BL       CPU_SR_Save
;;;1290   
;;;1291       if (pmem_base_addr == (void *)0) {                              /* If no base addr, cfg mem pool from heap.         */
00003e  9007              STR      r0,[sp,#0x1c]
000040  ea5f000a          MOVS     r0,r10
000044  d00a              BEQ      |L13.92|
;;;1292           pmem_seg        =  pmem_pool_heap;
;;;1293           pmem_seg_prev   =  pmem_pool_heap;
;;;1294           pmem_seg_next   =  pmem_pool_heap;
;;;1295   
;;;1296                                                                       /* --------------- VALIDATE MEM SEG --------------- */
;;;1297                                                                       /* Calc tot mem   size for mem pool ptrs.           */
;;;1298           pmem_addr_ptrs  = (CPU_INT08U *)pmem_pool_heap->SegAddrNextAvail;
;;;1299           size_tot_ptrs   =  Mem_SegCalcTotSize((void     *)pmem_addr_ptrs,
;;;1300                                                 (CPU_SIZE_T)blk_nbr,
;;;1301                                                 (CPU_SIZE_T)sizeof(void *),
;;;1302                                                 (CPU_SIZE_T)sizeof(void *));
;;;1303   #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
;;;1304           if (size_tot_ptrs < 1) {                                    /* If heap ovf, ...                                 */
;;;1305               CPU_CRITICAL_EXIT();
;;;1306              *perr = LIB_MEM_ERR_HEAP_OVF;                            /* ... rtn err but add'l heap size NOT avail.       */
;;;1307               return;
;;;1308           }
;;;1309   #endif
;;;1310                                                                       /* Calc tot mem   size for mem blks.                */
;;;1311           pmem_addr_pool  =  pmem_addr_ptrs + size_tot_ptrs;          /* Adj next avail addr for mem pool blks.           */
;;;1312           size_tot_pool   =  Mem_SegCalcTotSize((void     *)pmem_addr_pool,
;;;1313                                                 (CPU_SIZE_T)blk_nbr,
;;;1314                                                 (CPU_SIZE_T)blk_size,
;;;1315                                                 (CPU_SIZE_T)blk_align);
;;;1316   #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
;;;1317           if (size_tot_pool < 1) {                                    /* If heap ovf, ...                                 */
;;;1318               CPU_CRITICAL_EXIT();
;;;1319              *perr = LIB_MEM_ERR_HEAP_OVF;                            /* ... rtn err but add'l heap size NOT avail.       */
;;;1320               return;
;;;1321           }
;;;1322   #endif
;;;1323   
;;;1324           size_tot = size_tot_ptrs + size_tot_pool;
;;;1325   
;;;1326   #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
;;;1327           if ((size_tot < size_tot_ptrs) ||                           /* If heap ovf, ...                                 */
;;;1328               (size_tot < size_tot_pool)) {
;;;1329               CPU_CRITICAL_EXIT();
;;;1330              *perr = LIB_MEM_ERR_HEAP_OVF;                            /* ... rtn err but add'l heap size NOT avail.       */
;;;1331               return;
;;;1332           }
;;;1333   #endif
;;;1334   
;;;1335           size_rem = pmem_pool_heap->SegSizeRem;
;;;1336           if (size_tot > size_rem) {                                  /* If tot size > rem  size, ...                     */
;;;1337               CPU_CRITICAL_EXIT();
;;;1338              *poctets_reqd = size_tot - size_rem;                     /* ... rtn add'l heap size needed.                  */
;;;1339              *perr         = LIB_MEM_ERR_HEAP_EMPTY;
;;;1340               return;
;;;1341           }
;;;1342   
;;;1343       } else {                                                        /* Else cfg mem pool from dedicated mem.            */
;;;1344                                                                       /* -------- SRCH ALL MEM SEGS FOR MEM POOL -------- */
;;;1345           pmem_base_addr_start = (CPU_INT08U *)pmem_base_addr;
;;;1346           pmem_base_addr_end   = (CPU_INT08U *)pmem_base_addr + mem_size - 1;
000046  eb00020b          ADD      r2,r0,r11
00004a  1e52              SUBS     r2,r2,#1
;;;1347   
;;;1348   #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
;;;1349           if (pmem_base_addr_end < pmem_base_addr_start) {            /* Chk ovf of end addr.                             */
;;;1350               CPU_CRITICAL_EXIT();
;;;1351              *perr = LIB_MEM_ERR_INVALID_BLK_ADDR;
;;;1352               return;
;;;1353           }
;;;1354   #endif
;;;1355   
;;;1356           pmem_seg      = (MEM_POOL *)0;
;;;1357           pmem_seg_prev = (MEM_POOL *)0;
00004c  2100              MOVS     r1,#0
;;;1358           pmem_seg_next =  Mem_PoolTbl;
00004e  9108              STR      r1,[sp,#0x20]
000050  4975              LDR      r1,|L13.552|
;;;1359   
;;;1360           while (pmem_seg_next != (MEM_POOL *)0) {                    /* Srch tbl for mem seg with same base addr/size.   */
000052  680e              LDR      r6,[r1,#0]  ; Mem_PoolTbl
000054  e046              B        |L13.228|
                  |L13.86|
000056  f24271e7          MOV      r1,#0x27e7            ;1280
00005a  e03c              B        |L13.214|
                  |L13.92|
00005c  f8cd8020          STR      r8,[sp,#0x20]         ;1298
000060  f8d8b03c          LDR      r11,[r8,#0x3c]        ;1299
000064  2304              MOVS     r3,#4                 ;1299
000066  4646              MOV      r6,r8                 ;1294
000068  461a              MOV      r2,r3                 ;1299
00006a  4658              MOV      r0,r11                ;1299
00006c  990e              LDR      r1,[sp,#0x38]         ;1299
00006e  f7fffffe          BL       Mem_SegCalcTotSize
000072  9003              STR      r0,[sp,#0xc]          ;1311
000074  4458              ADD      r0,r0,r11             ;1311
000076  9004              STR      r0,[sp,#0x10]         ;1312
000078  e9dd2318          LDRD     r2,r3,[sp,#0x60]      ;1312
00007c  990e              LDR      r1,[sp,#0x38]         ;1312
00007e  f7fffffe          BL       Mem_SegCalcTotSize
000082  4683              MOV      r11,r0                ;1312
000084  9803              LDR      r0,[sp,#0xc]          ;1324
000086  4645              MOV      r5,r8                 ;1335
000088  4458              ADD      r0,r0,r11             ;1324
00008a  9002              STR      r0,[sp,#8]            ;1335
00008c  f8d81044          LDR      r1,[r8,#0x44]         ;1335
000090  9100              STR      r1,[sp,#0]            ;1336
000092  4288              CMP      r0,r1                 ;1336
000094  d959              BLS      |L13.330|
000096  9807              LDR      r0,[sp,#0x1c]         ;1337
000098  f7fffffe          BL       CPU_SR_Restore
00009c  9900              LDR      r1,[sp,#0]            ;1338
00009e  9802              LDR      r0,[sp,#8]            ;1338
0000a0  1a40              SUBS     r0,r0,r1              ;1338
0000a2  e03b              B        |L13.284|
                  |L13.164|
;;;1361   
;;;1362               if ((pmem_base_addr == pmem_seg_next->SegAddr) &&       /* If same base addr/size found, ...                */
0000a4  6bb1              LDR      r1,[r6,#0x38]
0000a6  4551              CMP      r1,r10
0000a8  d105              BNE      |L13.182|
;;;1363                   (mem_size       == pmem_seg_next->SegSizeTot)) {
0000aa  6c35              LDR      r5,[r6,#0x40]
0000ac  455d              CMP      r5,r11
0000ae  d102              BNE      |L13.182|
;;;1364   
;;;1365                    pmem_seg        = pmem_seg_next;                   /* ... mem seg already avail in tbl.                */
0000b0  0035              MOVS     r5,r6
;;;1366                    break;
0000b2  d019              BEQ      |L13.232|
0000b4  e01f              B        |L13.246|
                  |L13.182|
;;;1367   
;;;1368               } else {
;;;1369                   pmem_seg_addr_start = (CPU_INT08U *)pmem_seg_next->SegAddr;
;;;1370                   pmem_seg_addr_end   = (CPU_INT08U *)pmem_seg_next->SegAddr + pmem_seg_next->SegSizeTot - 1;
0000b6  6c33              LDR      r3,[r6,#0x40]
0000b8  440b              ADD      r3,r3,r1
0000ba  1e5b              SUBS     r3,r3,#1
;;;1371   
;;;1372   
;;;1373                   if (pmem_base_addr_end < pmem_seg_addr_start) {     /* If mem seg addr/size prior to next mem seg, ...  */
0000bc  428a              CMP      r2,r1
0000be  d313              BCC      |L13.232|
;;;1374                       break;                                          /* ... new mem seg NOT avail in tbl.                */
;;;1375   
;;;1376                                                                       /* If mem seg overlaps prev mem seg(s) in tbl, ...  */
;;;1377                   } else if (((pmem_base_addr_start <= pmem_seg_addr_start)  &&
0000c0  4288              CMP      r0,r1
0000c2  d903              BLS      |L13.204|
;;;1378                               (pmem_base_addr_end   >= pmem_seg_addr_start)) ||
;;;1379                              ((pmem_base_addr_start >= pmem_seg_addr_start)  &&
;;;1380                               (pmem_base_addr_end   <= pmem_seg_addr_end  )) ||
0000c4  429a              CMP      r2,r3
0000c6  d901              BLS      |L13.204|
;;;1381                              ((pmem_base_addr_start <= pmem_seg_addr_end  )  &&
0000c8  4298              CMP      r0,r3
0000ca  d809              BHI      |L13.224|
                  |L13.204|
;;;1382                               (pmem_base_addr_end   >= pmem_seg_addr_end  ))) {
;;;1383                       CPU_CRITICAL_EXIT();
0000cc  9807              LDR      r0,[sp,#0x1c]
0000ce  f7fffffe          BL       CPU_SR_Restore
;;;1384                      *perr = LIB_MEM_ERR_INVALID_SEG_OVERLAP;         /* ... rtn err.                                     */
0000d2  f242717f          MOV      r1,#0x277f
                  |L13.214|
0000d6  f8a91000          STRH     r1,[r9,#0]
                  |L13.218|
;;;1385                       return;
;;;1386                   }
;;;1387               }
;;;1388                                                                       /* If mem seg NOT found, adv to next mem seg.       */
;;;1389               pmem_seg_prev = pmem_seg_next;
;;;1390               pmem_seg_next = pmem_seg_next->SegNextPtr;
;;;1391           }
;;;1392   
;;;1393           if (pmem_seg == (MEM_POOL *)0) {                            /* If mem seg NOT found, add    new  mem seg.       */
;;;1394               pmem_seg                    = pmem_pool;
;;;1395               pmem_pool->SegAddr          = pmem_base_addr;
;;;1396               pmem_pool->SegAddrNextAvail = pmem_base_addr;
;;;1397               pmem_pool->SegSizeTot       = mem_size;
;;;1398               pmem_pool->SegSizeRem       = mem_size;
;;;1399           }
;;;1400   
;;;1401                                                                       /* --------------- VALIDATE MEM SEG --------------- */
;;;1402                                                                       /* Calc tot mem size for mem pool ptrs.             */
;;;1403           pmem_addr_ptrs = (CPU_INT08U *)pmem_pool_heap->SegAddrNextAvail;
;;;1404           size_tot_ptrs  =  Mem_SegCalcTotSize((void     *)pmem_addr_ptrs,
;;;1405                                                (CPU_SIZE_T)blk_nbr,
;;;1406                                                (CPU_SIZE_T)sizeof(void *),
;;;1407                                                (CPU_SIZE_T)sizeof(void *));
;;;1408   #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
;;;1409           if (size_tot_ptrs < 1) {                                    /* If heap ovf, ...                                 */
;;;1410               CPU_CRITICAL_EXIT();
;;;1411              *perr = LIB_MEM_ERR_HEAP_OVF;                            /* ... rtn err but add'l heap size NOT avail.       */
;;;1412               return;
;;;1413           }
;;;1414   #endif
;;;1415   
;;;1416           size_rem = pmem_pool_heap->SegSizeRem;
;;;1417           if (size_tot_ptrs > size_rem) {                             /* If ptr size > rem  size, ...                     */
;;;1418               CPU_CRITICAL_EXIT();
;;;1419              *poctets_reqd = size_tot_ptrs - size_rem;                /* ... rtn add'l heap size needed.                  */
;;;1420              *perr         = LIB_MEM_ERR_HEAP_EMPTY;
;;;1421               return;
;;;1422           }
;;;1423   
;;;1424                                                                       /* Calc tot mem size for mem blks.                  */
;;;1425           pmem_addr_pool = (CPU_INT08U *)pmem_seg->SegAddrNextAvail;
;;;1426           size_tot_pool  =  Mem_SegCalcTotSize((void     *)pmem_addr_pool,
;;;1427                                                (CPU_SIZE_T)blk_nbr,
;;;1428                                                (CPU_SIZE_T)blk_size,
;;;1429                                                (CPU_SIZE_T)blk_align);
;;;1430   #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
;;;1431           if (size_tot_pool < 1) {                                    /* If seg  ovf, ...                                 */
;;;1432               CPU_CRITICAL_EXIT();
;;;1433              *perr = LIB_MEM_ERR_SEG_OVF;                             /* ... rtn err but add'l seg  size NOT avail.       */
;;;1434               return;
;;;1435           }
;;;1436   #endif
;;;1437   
;;;1438           size_rem = pmem_seg->SegSizeRem;
;;;1439           if (size_tot_pool > size_rem) {                             /* If tot size > rem  size, ...                     */
;;;1440               CPU_CRITICAL_EXIT();
;;;1441              *poctets_reqd = size_tot_pool - size_rem;                /* ... rtn add'l seg  size needed.                  */
;;;1442              *perr         = LIB_MEM_ERR_SEG_EMPTY;
;;;1443               return;
;;;1444           }
;;;1445       }
;;;1446   
;;;1447   
;;;1448                                                                       /* ---------------- ALLOC MEM BLKs ---------------- */
;;;1449       size_pool_ptrs = (CPU_SIZE_T)(blk_nbr * sizeof(void *));
;;;1450                                                                       /* Alloc stk of ptrs for mem blks from heap.        */
;;;1451       ppool_ptr      = (void **)Mem_SegAlloc((MEM_POOL *)pmem_pool_heap,
;;;1452                                              (CPU_SIZE_T)size_pool_ptrs,
;;;1453                                              (CPU_SIZE_T)sizeof(void *));
;;;1454       if (ppool_ptr == (void **)0) {                                  /* If mem pool ptrs alloc failed, ...               */
;;;1455           size_rem = pmem_pool_heap->SegSizeRem;
;;;1456           CPU_CRITICAL_EXIT();
;;;1457                                                                       /* ... rtn add'l heap size needed.                  */
;;;1458           if (pmem_base_addr == (void *)0) {
;;;1459               if (size_tot > size_rem) {
;;;1460                  *poctets_reqd = size_tot - size_rem;
;;;1461               } else {
;;;1462                  *poctets_reqd = size_tot;
;;;1463               }
;;;1464           } else {
;;;1465               if (size_pool_ptrs > size_rem) {
;;;1466                  *poctets_reqd = size_pool_ptrs - size_rem;
;;;1467               } else {
;;;1468                  *poctets_reqd = size_pool_ptrs;
;;;1469               }
;;;1470           }
;;;1471          *perr = LIB_MEM_ERR_HEAP_EMPTY;
;;;1472           return;
;;;1473       }
;;;1474   
;;;1475       for (i = 0u; i < (CPU_SIZE_T)blk_nbr; i++) {                    /* Alloc mem blks from mem seg.                     */
;;;1476           pmem_blk = (void *)Mem_SegAlloc(pmem_seg, blk_size, blk_align);
;;;1477           if (pmem_blk == (void *)0) {                                /* If    mem blks alloc failed, ...                 */
;;;1478               pmem_addr_pool = (CPU_INT08U *)pmem_seg->SegAddrNextAvail;
;;;1479               size_rem       = (CPU_SIZE_T  )pmem_seg->SegSizeRem;
;;;1480               CPU_CRITICAL_EXIT();
;;;1481               blk_rem        =  blk_nbr - (MEM_POOL_BLK_QTY)i;
;;;1482               size_tot       =  Mem_SegCalcTotSize((void           *)pmem_addr_pool,
;;;1483                                                    (MEM_POOL_BLK_QTY)blk_rem,
;;;1484                                                    (CPU_SIZE_T      )blk_size,
;;;1485                                                    (CPU_SIZE_T      )blk_align);
;;;1486                                                                       /* ... rtn add'l seg  size needed.                  */
;;;1487               if (size_tot > size_rem) {
;;;1488                  *poctets_reqd = size_tot - size_rem;
;;;1489               } else {
;;;1490                  *poctets_reqd = size_tot;
;;;1491               }
;;;1492              *perr = LIB_MEM_ERR_SEG_EMPTY;
;;;1493               return;
;;;1494           }
;;;1495           ppool_ptr[i] = pmem_blk;
;;;1496       }
;;;1497   
;;;1498   
;;;1499                                                                       /* ------------- UPDATE MEM POOL TBL -------------- */
;;;1500       if (pmem_seg == pmem_pool) {                                    /* Add mem pool as new  mem pool tbl seg.           */
;;;1501                                                                       /* Update cur  mem seg  links.                      */
;;;1502           pmem_pool->SegPrevPtr = pmem_seg_prev;
;;;1503           pmem_pool->SegNextPtr = pmem_seg_next;
;;;1504   
;;;1505           if (pmem_seg_prev != (MEM_POOL *)0) {                       /* Update prev mem seg  link.                       */
;;;1506               pmem_seg_prev->SegNextPtr = pmem_pool;
;;;1507           } else {
;;;1508               Mem_PoolTbl               = pmem_pool;                  /* Update      mem tbl.                             */
;;;1509           }
;;;1510   
;;;1511           if (pmem_seg_next != (MEM_POOL *)0) {                       /* Update next mem seg  link.                       */
;;;1512               pmem_seg_next->SegPrevPtr = pmem_pool;
;;;1513           }
;;;1514   
;;;1515       } else {                                                        /* Add mem pool into mem seg.                       */
;;;1516                                                                       /* Update cur  mem pool links.                      */
;;;1517           pmem_pool_next         = pmem_seg->PoolNextPtr;
;;;1518           pmem_pool->PoolPrevPtr = pmem_seg;
;;;1519           pmem_pool->PoolNextPtr = pmem_pool_next;
;;;1520   
;;;1521           pmem_seg->PoolNextPtr  = pmem_pool;                         /* Update prev mem pool link.                       */
;;;1522   
;;;1523           if (pmem_pool_next != (MEM_POOL *)0) {                      /* Update next mem pool link.                       */
;;;1524               pmem_pool_next->PoolPrevPtr = pmem_pool;
;;;1525           }
;;;1526       }
;;;1527   
;;;1528   
;;;1529   
;;;1530                                                                       /* ----------------- CFG MEM POOL ----------------- */
;;;1531       pmem_pool->Type          = (LIB_MEM_TYPE    ) LIB_MEM_TYPE_POOL;
;;;1532       pmem_pool->SegHeadPtr    = (MEM_POOL       *) pmem_seg;
;;;1533       pmem_pool->PoolAddrStart = (void           *) pmem_addr_pool;
;;;1534       pmem_pool->PoolAddrEnd   = (void           *)(pmem_addr_pool + size_tot_pool - 1);
;;;1535       pmem_pool->PoolPtrs      = (void          **) ppool_ptr;
;;;1536       pmem_pool->PoolSize      = (CPU_SIZE_T      ) size_tot_pool;
;;;1537       pmem_pool->BlkAlign      = (CPU_SIZE_T      ) blk_align;
;;;1538       pmem_pool->BlkSize       = (CPU_SIZE_T      ) blk_size;
;;;1539       pmem_pool->BlkNbr        = (MEM_POOL_BLK_QTY) blk_nbr;
;;;1540       pmem_pool->BlkIx         = (MEM_POOL_IX     ) blk_nbr;
;;;1541   
;;;1542   
;;;1543       CPU_CRITICAL_EXIT();
;;;1544   
;;;1545      *perr = LIB_MEM_ERR_NONE;
;;;1546   }
0000da  b00f              ADD      sp,sp,#0x3c
0000dc  e8bd8ff0          POP      {r4-r11,pc}
                  |L13.224|
0000e0  9608              STR      r6,[sp,#0x20]         ;1390
0000e2  68f6              LDR      r6,[r6,#0xc]          ;1390
                  |L13.228|
0000e4  2e00              CMP      r6,#0                 ;1360
0000e6  d1dd              BNE      |L13.164|
                  |L13.232|
0000e8  f8c4b040          STR      r11,[r4,#0x40]        ;1397
0000ec  e9c4aa0e          STRD     r10,r10,[r4,#0x38]    ;1397
0000f0  4625              MOV      r5,r4                 ;1394
0000f2  f8c4b044          STR      r11,[r4,#0x44]        ;1398
                  |L13.246|
0000f6  2304              MOVS     r3,#4                 ;1404
0000f8  461a              MOV      r2,r3                 ;1404
0000fa  f8d8003c          LDR      r0,[r8,#0x3c]         ;1404
0000fe  990e              LDR      r1,[sp,#0x38]         ;1404
000100  f7fffffe          BL       Mem_SegCalcTotSize
000104  f8d81044          LDR      r1,[r8,#0x44]         ;1416
000108  4683              MOV      r11,r0                ;1404
00010a  9100              STR      r1,[sp,#0]            ;1417
00010c  4288              CMP      r0,r1                 ;1417
00010e  d909              BLS      |L13.292|
000110  9807              LDR      r0,[sp,#0x1c]         ;1418
000112  f7fffffe          BL       CPU_SR_Restore
000116  9900              LDR      r1,[sp,#0]            ;1419
000118  ebab0001          SUB      r0,r11,r1             ;1419
                  |L13.284|
00011c  6038              STR      r0,[r7,#0]            ;1471
00011e  f24270e2          MOV      r0,#0x27e2            ;1471
000122  e07e              B        |L13.546|
                  |L13.292|
000124  6be8              LDR      r0,[r5,#0x3c]         ;1425
000126  9004              STR      r0,[sp,#0x10]         ;1426
000128  e9dd2318          LDRD     r2,r3,[sp,#0x60]      ;1426
00012c  990e              LDR      r1,[sp,#0x38]         ;1426
00012e  f7fffffe          BL       Mem_SegCalcTotSize
000132  6c69              LDR      r1,[r5,#0x44]         ;1438
000134  4683              MOV      r11,r0                ;1426
000136  9100              STR      r1,[sp,#0]            ;1439
000138  4288              CMP      r0,r1                 ;1439
00013a  d906              BLS      |L13.330|
00013c  9807              LDR      r0,[sp,#0x1c]         ;1440
00013e  f7fffffe          BL       CPU_SR_Restore
000142  9900              LDR      r1,[sp,#0]            ;1441
000144  ebab0001          SUB      r0,r11,r1             ;1441
000148  e042              B        |L13.464|
                  |L13.330|
00014a  980e              LDR      r0,[sp,#0x38]         ;1449
00014c  2204              MOVS     r2,#4                 ;1451
00014e  0080              LSLS     r0,r0,#2              ;1449
000150  4601              MOV      r1,r0                 ;1451
000152  9003              STR      r0,[sp,#0xc]          ;1451
000154  4640              MOV      r0,r8                 ;1451
000156  f7fffffe          BL       Mem_SegAlloc
00015a  9000              STR      r0,[sp,#0]            ;1454
00015c  b108              CBZ      r0,|L13.354|
00015e  2000              MOVS     r0,#0                 ;1475
000160  e019              B        |L13.406|
                  |L13.354|
000162  f8d84044          LDR      r4,[r8,#0x44]         ;1456
000166  9807              LDR      r0,[sp,#0x1c]         ;1456
000168  f7fffffe          BL       CPU_SR_Restore
00016c  f1ba0f00          CMP      r10,#0                ;1458
000170  d004              BEQ      |L13.380|
000172  9803              LDR      r0,[sp,#0xc]          ;1465
                  |L13.372|
000174  42a0              CMP      r0,r4                 ;1459
000176  d9d1              BLS      |L13.284|
000178  1b00              SUBS     r0,r0,r4              ;1460
00017a  e7cf              B        |L13.284|
                  |L13.380|
00017c  9802              LDR      r0,[sp,#8]            ;1459
00017e  e7f9              B        |L13.372|
                  |L13.384|
000180  e9dd1218          LDRD     r1,r2,[sp,#0x60]      ;1476
000184  4628              MOV      r0,r5                 ;1476
000186  f7fffffe          BL       Mem_SegAlloc
00018a  b188              CBZ      r0,|L13.432|
00018c  9900              LDR      r1,[sp,#0]            ;1495
00018e  f8410028          STR      r0,[r1,r8,LSL #2]     ;1495
000192  f1080001          ADD      r0,r8,#1              ;1475
                  |L13.406|
000196  990e              LDR      r1,[sp,#0x38]         ;1475
000198  4680              MOV      r8,r0                 ;1475
00019a  4288              CMP      r0,r1                 ;1475
00019c  d3f0              BCC      |L13.384|
00019e  42a5              CMP      r5,r4                 ;1500
0001a0  d11f              BNE      |L13.482|
0001a2  9808              LDR      r0,[sp,#0x20]         ;1502
0001a4  e9c40602          STRD     r0,r6,[r4,#8]         ;1502
0001a8  9808              LDR      r0,[sp,#0x20]         ;1505
0001aa  b1a8              CBZ      r0,|L13.472|
0001ac  60c4              STR      r4,[r0,#0xc]          ;1506
0001ae  e015              B        |L13.476|
                  |L13.432|
0001b0  6bee              LDR      r6,[r5,#0x3c]         ;1480
0001b2  6c6c              LDR      r4,[r5,#0x44]         ;1480
0001b4  9807              LDR      r0,[sp,#0x1c]         ;1480
0001b6  f7fffffe          BL       CPU_SR_Restore
0001ba  980e              LDR      r0,[sp,#0x38]         ;1481
0001bc  e9dd2318          LDRD     r2,r3,[sp,#0x60]      ;1482
0001c0  eba00108          SUB      r1,r0,r8              ;1481
0001c4  4630              MOV      r0,r6                 ;1482
0001c6  f7fffffe          BL       Mem_SegCalcTotSize
0001ca  42a0              CMP      r0,r4                 ;1487
0001cc  d900              BLS      |L13.464|
0001ce  1b00              SUBS     r0,r0,r4              ;1488
                  |L13.464|
0001d0  6038              STR      r0,[r7,#0]            ;1492
0001d2  f24270d8          MOV      r0,#0x27d8            ;1492
0001d6  e024              B        |L13.546|
                  |L13.472|
0001d8  4813              LDR      r0,|L13.552|
0001da  6004              STR      r4,[r0,#0]            ;1508  ; Mem_PoolTbl
                  |L13.476|
0001dc  b13e              CBZ      r6,|L13.494|
0001de  60b4              STR      r4,[r6,#8]            ;1512
0001e0  e005              B        |L13.494|
                  |L13.482|
0001e2  6968              LDR      r0,[r5,#0x14]         ;1517
0001e4  e9c45004          STRD     r5,r0,[r4,#0x10]      ;1517
0001e8  616c              STR      r4,[r5,#0x14]         ;1523
0001ea  b100              CBZ      r0,|L13.494|
0001ec  6104              STR      r4,[r0,#0x10]         ;1524
                  |L13.494|
0001ee  4810              LDR      r0,|L13.560|
0001f0  e9c40500          STRD     r0,r5,[r4,#0]         ;1531
0001f4  9804              LDR      r0,[sp,#0x10]         ;1533
0001f6  61a0              STR      r0,[r4,#0x18]         ;1534
0001f8  9804              LDR      r0,[sp,#0x10]         ;1534
0001fa  4458              ADD      r0,r0,r11             ;1534
0001fc  1e40              SUBS     r0,r0,#1              ;1534
0001fe  61e0              STR      r0,[r4,#0x1c]         ;1535
000200  9800              LDR      r0,[sp,#0]            ;1535
000202  f8c4b028          STR      r11,[r4,#0x28]        ;1537
000206  6220              STR      r0,[r4,#0x20]         ;1537
000208  9819              LDR      r0,[sp,#0x64]         ;1537
00020a  6360              STR      r0,[r4,#0x34]         ;1538
00020c  9818              LDR      r0,[sp,#0x60]         ;1538
00020e  6320              STR      r0,[r4,#0x30]         ;1539
000210  980e              LDR      r0,[sp,#0x38]         ;1539
000212  62e0              STR      r0,[r4,#0x2c]         ;1540
000214  980e              LDR      r0,[sp,#0x38]         ;1540
000216  6260              STR      r0,[r4,#0x24]         ;1543
000218  9807              LDR      r0,[sp,#0x1c]         ;1543
00021a  f7fffffe          BL       CPU_SR_Restore
00021e  f2427010          MOV      r0,#0x2710            ;1545
                  |L13.546|
000222  f8a90000          STRH     r0,[r9,#0]            ;1545
000226  e758              B        |L13.218|
;;;1547   #endif
                          ENDP

                  |L13.552|
                          DCD      ||.data||
                  |L13.556|
                          DCD      ||.bss||
                  |L13.560|
                          DCD      0x4c4f4f50

                          AREA ||i.Mem_SegAlloc||, CODE, READONLY, ALIGN=1

                  Mem_SegAlloc PROC
;;;2366   #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)
;;;2367   static  void  *Mem_SegAlloc (MEM_POOL    *pmem_pool,
000000  b530              PUSH     {r4,r5,lr}
;;;2368                                CPU_SIZE_T   size,
;;;2369                                CPU_SIZE_T   align)
;;;2370   {
;;;2371       CPU_INT08U  *pmem_addr;
;;;2372       CPU_INT08U  *pmem_addr_next;
;;;2373       CPU_SIZE_T   mem_align;
;;;2374       CPU_SIZE_T   align_offset;
;;;2375       CPU_SIZE_T   size_tot;
;;;2376   
;;;2377   
;;;2378       pmem_addr = (CPU_INT08U *)pmem_pool->SegAddrNextAvail;
;;;2379   
;;;2380       mem_align = (CPU_SIZE_T)((CPU_ADDR)pmem_addr % align);          /* Calc mem align.                                  */
000002  6bc3              LDR      r3,[r0,#0x3c]
000004  fbb3f4f2          UDIV     r4,r3,r2
000008  fb023414          MLS      r4,r2,r4,r3
00000c  b10c              CBZ      r4,|L14.18|
;;;2381   
;;;2382       if (mem_align != 0u) {
;;;2383           align_offset = align - mem_align;
00000e  1b12              SUBS     r2,r2,r4
000010  e000              B        |L14.20|
                  |L14.18|
;;;2384       } else {
;;;2385           align_offset = 0u;
000012  2200              MOVS     r2,#0
                  |L14.20|
;;;2386       }
;;;2387   
;;;2388       size_tot = align_offset + size;
;;;2389       if (size_tot > pmem_pool->SegSizeRem) {                         /* If insufficient mem seg size rem, ...            */
000014  6c44              LDR      r4,[r0,#0x44]
000016  4411              ADD      r1,r1,r2              ;2388
000018  428c              CMP      r4,r1
00001a  d201              BCS      |L14.32|
;;;2390           return ((void *)0);                                         /* ... rtn NULL.                                    */
00001c  2000              MOVS     r0,#0
;;;2391       }
;;;2392   
;;;2393   #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
;;;2394       if ((size_tot < align_offset) ||                                /* If size ovf, ...                                 */
;;;2395           (size_tot < size)) {
;;;2396           return ((void *)0);                                         /* ... rtn NULL.                                    */
;;;2397       }
;;;2398   #endif
;;;2399   
;;;2400       pmem_addr_next = pmem_addr + size_tot;
;;;2401   
;;;2402   #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
;;;2403       if (pmem_addr_next < pmem_addr) {                               /* If addr ovf, ...                                 */
;;;2404           return ((void *)0);                                         /* ... rtn NULL.                                    */
;;;2405       }
;;;2406   #endif
;;;2407   
;;;2408       pmem_addr += align_offset;                                      /* Align mem addr.                                  */
;;;2409   
;;;2410       pmem_pool->SegAddrNextAvail  = (void     *)pmem_addr_next;      /* Adv next avail addr.                             */
;;;2411       pmem_pool->SegSizeRem       -= (CPU_SIZE_T)size_tot;            /* Adj rem mem seg size.                            */
;;;2412   
;;;2413       return ((void *)pmem_addr);
;;;2414   }
00001e  bd30              POP      {r4,r5,pc}
                  |L14.32|
000020  185d              ADDS     r5,r3,r1              ;2400
000022  1a61              SUBS     r1,r4,r1              ;2411
000024  63c5              STR      r5,[r0,#0x3c]         ;2413
000026  441a              ADD      r2,r2,r3              ;2408
000028  6441              STR      r1,[r0,#0x44]         ;2413
00002a  4610              MOV      r0,r2                 ;2413
00002c  bd30              POP      {r4,r5,pc}
;;;2415   #endif
                          ENDP


                          AREA ||i.Mem_SegCalcTotSize||, CODE, READONLY, ALIGN=1

                  Mem_SegCalcTotSize PROC
;;;2259   #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)
;;;2260   static  CPU_SIZE_T  Mem_SegCalcTotSize (void              *pmem_addr,
000000  b510              PUSH     {r4,lr}
;;;2261                                           MEM_POOL_BLK_QTY   blk_nbr,
;;;2262                                           CPU_SIZE_T         blk_size,
;;;2263                                           CPU_SIZE_T         blk_align)
;;;2264   {
;;;2265   #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
;;;2266       CPU_SIZE_T  blk_size_mem_aligned;
;;;2267       CPU_SIZE_T  blk_size_aligned;
;;;2268       CPU_SIZE_T  blk_size_aligned_nbr;
;;;2269       CPU_SIZE_T  blk_size_tot;
;;;2270   #endif
;;;2271       CPU_SIZE_T  align_offset;
;;;2272       CPU_SIZE_T  mem_align_offset;
;;;2273       CPU_SIZE_T  blk_align_offset;
;;;2274       CPU_SIZE_T  size_tot;
;;;2275   
;;;2276                                                                       /* Calc mem align (see Note #2a).                   */
;;;2277       align_offset = (CPU_ADDR)pmem_addr % blk_align;
000002  fbb0f4f3          UDIV     r4,r0,r3
000006  fb030014          MLS      r0,r3,r4,r0
00000a  b100              CBZ      r0,|L15.14|
;;;2278       if (align_offset != 0u) {
;;;2279           mem_align_offset = blk_align - align_offset;
00000c  1a18              SUBS     r0,r3,r0
                  |L15.14|
;;;2280       } else {
;;;2281           mem_align_offset = 0u;
;;;2282       }
;;;2283                                                                       /* Calc blk align (see Note #2b).                   */
;;;2284       align_offset = blk_size % blk_align;
00000e  fbb2f4f3          UDIV     r4,r2,r3
000012  fb032414          MLS      r4,r3,r4,r2
;;;2285       if (align_offset != 0u) {
000016  b10c              CBZ      r4,|L15.28|
;;;2286           blk_align_offset = blk_align - align_offset;
000018  1b1b              SUBS     r3,r3,r4
00001a  e000              B        |L15.30|
                  |L15.28|
;;;2287       } else {
;;;2288           blk_align_offset = 0u;
00001c  2300              MOVS     r3,#0
                  |L15.30|
;;;2289       }
;;;2290                                                                       /* Calc tot size  (see Note #2c).                   */
;;;2291       size_tot = mem_align_offset + ((blk_size + blk_align_offset) * ((CPU_SIZE_T)blk_nbr - 1)) + blk_size;
00001e  4410              ADD      r0,r0,r2
000020  441a              ADD      r2,r2,r3
000022  1e49              SUBS     r1,r1,#1
000024  fb020001          MLA      r0,r2,r1,r0
;;;2292   
;;;2293   #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)                     /* Chk ovf of tot size = A + [(B + C) * D] + E      */
;;;2294       blk_size_mem_aligned = mem_align_offset + blk_size;             /* Chk ovf of A + E :                               */
;;;2295       if ((blk_size_mem_aligned < mem_align_offset) ||
;;;2296           (blk_size_mem_aligned < blk_size)) {
;;;2297           return (0u);
;;;2298       }
;;;2299   
;;;2300       if (blk_nbr > 1) {
;;;2301           blk_size_aligned = blk_size + blk_align_offset;
;;;2302           if ((blk_size_aligned < blk_align_offset) ||                /* Chk ovf of      (B + C) :                        */
;;;2303               (blk_size_aligned < blk_size)) {
;;;2304               return (0u);
;;;2305           }
;;;2306   
;;;2307           blk_size_aligned_nbr = blk_size_aligned * ((CPU_SIZE_T)blk_nbr - 1);
;;;2308           if ((blk_size_aligned_nbr < blk_size_aligned) ||            /* Chk ovf of     [(B + C) * D] :                   */
;;;2309               (blk_size_aligned_nbr < blk_align_offset) ||
;;;2310               (blk_size_aligned_nbr < blk_size)) {
;;;2311               return (0u);
;;;2312           }
;;;2313   
;;;2314           blk_size_tot = blk_size_aligned_nbr + blk_size;
;;;2315           if ((blk_size_tot < blk_size_aligned_nbr) ||                /* Chk ovf of     [(B + C) * D] + E :               */
;;;2316               (blk_size_tot < blk_size)) {
;;;2317               return (0u);
;;;2318           }
;;;2319   
;;;2320           if ((size_tot < blk_size_mem_aligned) ||                    /* Chk ovf of A + [(B + C) * D] + E :               */
;;;2321               (size_tot < blk_size_aligned_nbr) ||
;;;2322               (size_tot < blk_size_tot)) {
;;;2323               return (0u);
;;;2324           }
;;;2325       }
;;;2326   #endif
;;;2327   
;;;2328       return (size_tot);
;;;2329   }
000028  bd10              POP      {r4,pc}
;;;2330   #endif
                          ENDP


                          AREA ||i.Mem_SegGetSizeRem||, CODE, READONLY, ALIGN=2

                  Mem_SegGetSizeRem PROC
;;;899    #if (LIB_MEM_CFG_ALLOC_EN == DEF_ENABLED)
;;;900    CPU_SIZE_T  Mem_SegGetSizeRem (MEM_POOL    *pmem_pool,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;901                                   CPU_SIZE_T   align,
;;;902                                   LIB_ERR     *perr)
;;;903    {
000004  4616              MOV      r6,r2
000006  460c              MOV      r4,r1
000008  4605              MOV      r5,r0
;;;904        MEM_POOL    *pmem_seg;
;;;905        MEM_POOL    *pmem_seg_size;
;;;906        CPU_SIZE_T   size_rem;
;;;907        CPU_SIZE_T   size_rem_mod;
;;;908        CPU_SIZE_T   seg_addr_mod;
;;;909        CPU_ADDR     seg_addr;
;;;910        CPU_SR_ALLOC();
;;;911    
;;;912    
;;;913    #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
;;;914                                                                    /* --------------- VALIDATE RTN ERR PTR --------------- */
;;;915        if (perr == (LIB_ERR *)0) {
;;;916            CPU_SW_EXCEPTION(0u);
;;;917        }
;;;918                                                                    /* ---------------- VALIDATE MEM ALIGN ---------------- */
;;;919        if (align < 1) {
;;;920           *perr =  LIB_MEM_ERR_INVALID_MEM_ALIGN;
;;;921            return (0u);
;;;922        }
;;;923        if (align > DEF_ALIGN_MAX_NBR_OCTETS) {
;;;924           *perr =  LIB_MEM_ERR_INVALID_MEM_ALIGN;
;;;925            return (0u);
;;;926        }
;;;927                                                                    /* ---------------- VALIDATE MEM POOL ----------------- */
;;;928        if (pmem_pool == (MEM_POOL *)0) {                           /* Validate mem ptr.                                    */
;;;929           *perr =  LIB_MEM_ERR_NULL_PTR;
;;;930            return (0u);
;;;931        }
;;;932    #endif
;;;933    
;;;934        CPU_CRITICAL_ENTER();
00000a  f7fffffe          BL       CPU_SR_Save
;;;935    
;;;936    #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
;;;937        switch (pmem_pool->Type) {                                  /* Validate mem pool type.                              */
;;;938            case LIB_MEM_TYPE_HEAP:
;;;939            case LIB_MEM_TYPE_POOL:
;;;940                 break;
;;;941    
;;;942    
;;;943            case LIB_MEM_TYPE_NONE:
;;;944            default:
;;;945                 CPU_CRITICAL_EXIT();
;;;946                *perr =  LIB_MEM_ERR_INVALID_POOL;
;;;947                 return (0u);                                       /* Prevent 'break NOT reachable' compiler warning.      */
;;;948        }
;;;949    #endif
;;;950    
;;;951                                                                    /* ------------- GET REM'ING MEM SEG SIZE ------------- */
;;;952        pmem_seg      =  pmem_pool->SegHeadPtr;                     /* Get mem pool's head seg.                             */
;;;953        pmem_seg_size = (pmem_seg->SegAddr != (void *)0)
00000e  686b              LDR      r3,[r5,#4]
000010  6b99              LDR      r1,[r3,#0x38]
000012  b901              CBNZ     r1,|L16.22|
;;;954                      ?  pmem_seg : &Mem_PoolHeap;                  /* See Note #1.                                         */
000014  4b09              LDR      r3,|L16.60|
                  |L16.22|
;;;955        size_rem      =  pmem_seg_size->SegSizeRem;                 /* Get mem seg's rem'ing mem size.                      */
;;;956        seg_addr      = (CPU_ADDR)pmem_seg_size->SegAddrNextAvail;
;;;957    
;;;958        CPU_CRITICAL_EXIT();
000016  6bdf              LDR      r7,[r3,#0x3c]
000018  6c5d              LDR      r5,[r3,#0x44]
00001a  f7fffffe          BL       CPU_SR_Restore
;;;959    
;;;960        if (align > 1) {                                            /* If align > 1 octet, ...                              */
00001e  2c01              CMP      r4,#1
000020  d906              BLS      |L16.48|
;;;961            seg_addr_mod  =  seg_addr % align;
000022  fbb7f0f4          UDIV     r0,r7,r4
000026  fb047010          MLS      r0,r4,r0,r7
;;;962            size_rem_mod  = (seg_addr_mod > 0u) ? (align - seg_addr_mod) : 0u;
00002a  b100              CBZ      r0,|L16.46|
00002c  1a20              SUBS     r0,r4,r0
                  |L16.46|
;;;963            size_rem     -=  size_rem_mod;                          /* ... adj rem'ing size by offset to align'd seg addr.  */
00002e  1a2d              SUBS     r5,r5,r0
                  |L16.48|
;;;964        }
;;;965    
;;;966    
;;;967       *perr =  LIB_MEM_ERR_NONE;
000030  f2427010          MOV      r0,#0x2710
000034  8030              STRH     r0,[r6,#0]
;;;968    
;;;969        return (size_rem);
000036  4628              MOV      r0,r5
;;;970    }
000038  e8bd81f0          POP      {r4-r8,pc}
;;;971    #endif
                          ENDP

                  |L16.60|
                          DCD      ||.bss||

                          AREA ||i.Mem_Set||, CODE, READONLY, ALIGN=2

                  Mem_Set PROC
;;;264    
;;;265    void  Mem_Set (void        *pmem,
000000  b510              PUSH     {r4,lr}
;;;266                   CPU_INT08U   data_val,
;;;267                   CPU_SIZE_T   size)
;;;268    {
;;;269        CPU_SIZE_T   size_rem;
;;;270        CPU_ALIGN    data_align;
;;;271        CPU_ALIGN   *pmem_align;
;;;272        CPU_INT08U  *pmem_08;
;;;273        CPU_DATA     mem_align_mod;
;;;274        CPU_DATA     i;
;;;275    
;;;276    
;;;277    #if (LIB_MEM_CFG_ARG_CHK_EXT_EN == DEF_ENABLED)
;;;278        if (size < 1) {                                             /* See Note #1.                                         */
;;;279            return;
;;;280        }
;;;281        if (pmem == (void *)0) {
;;;282            return;
;;;283        }
;;;284    #endif
;;;285    
;;;286    
;;;287        data_align = 0u;
000002  2300              MOVS     r3,#0
;;;288        for (i = 0u; i < sizeof(CPU_ALIGN); i++) {                  /* Fill each data_align octet with data val.            */
000004  ea4f0403          MOV.W    r4,r3
                  |L17.8|
000008  1c64              ADDS     r4,r4,#1
;;;289            data_align <<=  DEF_OCTET_NBR_BITS;
;;;290            data_align  |= (CPU_ALIGN)data_val;
00000a  ea412303          ORR      r3,r1,r3,LSL #8
00000e  2c04              CMP      r4,#4                 ;288
000010  d3fa              BCC      |L17.8|
;;;291        }
;;;292    
;;;293        size_rem      =  size;
;;;294        mem_align_mod = (CPU_INT08U)((CPU_ADDR)pmem % sizeof(CPU_ALIGN));   /* See Note #3.                                 */
000012  f0100403          ANDS     r4,r0,#3
;;;295    
;;;296        pmem_08 = (CPU_INT08U *)pmem;
;;;297        if (mem_align_mod != 0u) {                                  /* If leading octets avail,                   ...       */
000016  d105              BNE      |L17.36|
000018  e00a              B        |L17.48|
;;;298            i = mem_align_mod;
;;;299            while ((size_rem > 0) &&                                /* ... start mem buf fill with leading octets ...       */
;;;300                   (i        < sizeof(CPU_ALIGN ))) {               /* ... until next CPU_ALIGN word boundary.              */
;;;301               *pmem_08++ = data_val;
00001a  bf00              NOP      
                  |L17.28|
;;;302                size_rem -= sizeof(CPU_INT08U);
00001c  1e52              SUBS     r2,r2,#1
00001e  f8001b01          STRB     r1,[r0],#1            ;301
;;;303                i++;
000022  1c64              ADDS     r4,r4,#1
                  |L17.36|
000024  b15a              CBZ      r2,|L17.62|
000026  2c04              CMP      r4,#4                 ;300
000028  d3f8              BCC      |L17.28|
00002a  e001              B        |L17.48|
                  |L17.44|
;;;304            }
;;;305        }
;;;306    
;;;307        pmem_align = (CPU_ALIGN *)pmem_08;                          /* See Note #2a.                                        */
;;;308        while (size_rem >= sizeof(CPU_ALIGN)) {                     /* While mem buf aligned on CPU_ALIGN word boundaries,  */
;;;309           *pmem_align++ = data_align;                              /* ... fill mem buf with    CPU_ALIGN-sized data.       */
00002c  c008              STM      r0!,{r3}
;;;310            size_rem    -= sizeof(CPU_ALIGN);
00002e  1f12              SUBS     r2,r2,#4
                  |L17.48|
000030  2a04              CMP      r2,#4                 ;308
000032  d2fb              BCS      |L17.44|
000034  e003              B        |L17.62|
;;;311        }
;;;312    
;;;313        pmem_08 = (CPU_INT08U *)pmem_align;
;;;314        while (size_rem > 0) {                                      /* Finish mem buf fill with trailing octets.            */
;;;315           *pmem_08++   = data_val;
000036  bf00              NOP      
                  |L17.56|
000038  f8001b01          STRB     r1,[r0],#1
;;;316            size_rem   -= sizeof(CPU_INT08U);
00003c  1e52              SUBS     r2,r2,#1
                  |L17.62|
00003e  2a00              CMP      r2,#0                 ;314
000040  d1fa              BNE      |L17.56|
;;;317        }
;;;318    }
000042  bd10              POP      {r4,pc}
;;;319    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  Mem_PoolHeap
                          %        72
                  Mem_Heap
                          %        1024

                          AREA ||.data||, DATA, ALIGN=2

                  Mem_PoolTbl
                          DCD      0x00000000
