; generated by ARM C/C++ Compiler, 5.02 [Build 28]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\OBJ\os_mem.o --asm_dir=.\List\ --list_dir=.\List\ --depend=..\OBJ\os_mem.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\BSP -I..\CORE -I..\STM32F10x_FWLib\inc -I..\USER -I..\UCOSIII\uC-CPU -I..\UCOSIII\uC-CPU\ARM-Cortex-M3\RealView -I..\UCOSIII\uC-LIB -I..\UCOSIII\uC-LIB\Ports\ARM-Cortex-M3\RealView -I..\UCOSIII\uCOS-III -I..\UCOSIII\uCOS-III\Ports -I..\UCOSIII\uCOS-III\Ports\ARM-Cortex-M3\Generic\RealView -I..\UCOSIII\uCOS-III\Source -I..\UCOSIII\UCOS_BSP -I..\UCOSIII\uCOS_CONFIG -I..\UCOSIII-Task -I..\SYSTEM -I..\BSP\inc -I..\PAL -I..\PAL\vehicles -ID:\Keil_v4\ARM\RV31\INC -ID:\Keil_v4\ARM\CMSIS\Include -ID:\Keil_v4\ARM\Inc\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=..\OBJ\os_mem.crf ..\UCOSIII\uCOS-III\Source\os_mem.c]
                          THUMB

                          AREA ||i.OSMemCreate||, CODE, READONLY, ALIGN=2

                  OSMemCreate PROC
;;;74     
;;;75     void  OSMemCreate (OS_MEM       *p_mem,
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;76                        CPU_CHAR     *p_name,
;;;77                        void         *p_addr,
;;;78                        OS_MEM_QTY    n_blks,
;;;79                        OS_MEM_SIZE   blk_size,
;;;80                        OS_ERR       *p_err)
;;;81     {
000004  4605              MOV      r5,r0
;;;82     #if OS_CFG_ARG_CHK_EN > 0u
;;;83         CPU_DATA       align_msk;
;;;84     #endif
;;;85         OS_MEM_QTY     i;
;;;86         OS_MEM_QTY     loops;
;;;87         CPU_INT08U    *p_blk;
;;;88         void         **p_link;
;;;89         CPU_SR_ALLOC();
;;;90     
;;;91     
;;;92     
;;;93     #ifdef OS_SAFETY_CRITICAL
;;;94         if (p_err == (OS_ERR *)0) {
;;;95             OS_SAFETY_CRITICAL_EXCEPTION();
;;;96             return;
;;;97         }
;;;98     #endif
;;;99     
;;;100    #ifdef OS_SAFETY_CRITICAL_IEC61508
;;;101        if (OSSafetyCriticalStartFlag == DEF_TRUE) {
;;;102           *p_err = OS_ERR_ILLEGAL_CREATE_RUN_TIME;
;;;103            return;
;;;104        }
;;;105    #endif
;;;106    
;;;107    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;108        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
000006  482c              LDR      r0,|L1.184|
000008  e9dd860a          LDRD     r8,r6,[sp,#0x28]      ;81
00000c  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
00000e  461f              MOV      r7,r3                 ;81
000010  4614              MOV      r4,r2                 ;81
000012  468b              MOV      r11,r1                ;81
000014  b110              CBZ      r0,|L1.28|
;;;109           *p_err = OS_ERR_MEM_CREATE_ISR;
000016  f24560b9          MOV      r0,#0x56b9
;;;110            return;
00001a  e00e              B        |L1.58|
                  |L1.28|
;;;111        }
;;;112    #endif
;;;113    
;;;114    #if OS_CFG_ARG_CHK_EN > 0u
;;;115        if (p_addr == (void *)0) {                              /* Must pass a valid address for the memory part.         */
;;;116           *p_err   = OS_ERR_MEM_INVALID_P_ADDR;
00001c  f24560bb          MOV      r0,#0x56bb
000020  b15c              CBZ      r4,|L1.58|
;;;117            return;
;;;118        }
;;;119        if (n_blks < (OS_MEM_QTY)2) {                           /* Must have at least 2 blocks per partition              */
000022  2f02              CMP      r7,#2
000024  d201              BCS      |L1.42|
;;;120           *p_err = OS_ERR_MEM_INVALID_BLKS;
000026  1c40              ADDS     r0,r0,#1
;;;121            return;
000028  e007              B        |L1.58|
                  |L1.42|
;;;122        }
;;;123        if (blk_size < sizeof(void *)) {                        /* Must contain space for at least a pointer              */
;;;124           *p_err = OS_ERR_MEM_INVALID_SIZE;
00002a  f24561c1          MOV      r1,#0x56c1
00002e  f1b80f04          CMP      r8,#4                 ;123
000032  d308              BCC      |L1.70|
;;;125            return;
;;;126        }
;;;127        align_msk = sizeof(void *) - 1u;
;;;128        if (align_msk > 0) {
;;;129            if (((CPU_ADDR)p_addr & align_msk) != 0u){          /* Must be pointer size aligned                           */
000034  f0140f03          TST      r4,#3
000038  d002              BEQ      |L1.64|
                  |L1.58|
;;;130               *p_err = OS_ERR_MEM_INVALID_P_ADDR;
00003a  8030              STRH     r0,[r6,#0]
                  |L1.60|
;;;131                return;
;;;132            }
;;;133            if ((blk_size & align_msk) != 0u) {                 /* Block size must be a multiple address size             */
;;;134               *p_err = OS_ERR_MEM_INVALID_SIZE;
;;;135                return;
;;;136            }
;;;137        }
;;;138    #endif
;;;139    
;;;140        p_link = (void **)p_addr;                               /* Create linked list of free memory blocks               */
;;;141        p_blk  = (CPU_INT08U *)p_addr;
;;;142        loops  = n_blks - 1u;
;;;143        for (i = 0u; i < loops; i++) {
;;;144            p_blk +=  blk_size;
;;;145           *p_link = (void  *)p_blk;                            /* Save pointer to NEXT block in CURRENT block            */
;;;146            p_link = (void **)(void *)p_blk;                    /* Position     to NEXT block                             */
;;;147        }
;;;148       *p_link             = (void *)0;                         /* Last memory block points to NULL                       */
;;;149    
;;;150        OS_CRITICAL_ENTER();
;;;151        p_mem->Type        = OS_OBJ_TYPE_MEM;                   /* Set the type of object                                 */
;;;152        p_mem->NamePtr     = p_name;                            /* Save name of memory partition                          */
;;;153        p_mem->AddrPtr     = p_addr;                            /* Store start address of memory partition                */
;;;154        p_mem->FreeListPtr = p_addr;                            /* Initialize pointer to pool of free blocks              */
;;;155        p_mem->NbrFree     = n_blks;                            /* Store number of free blocks in MCB                     */
;;;156        p_mem->NbrMax      = n_blks;
;;;157        p_mem->BlkSize     = blk_size;                          /* Store block size of each memory blocks                 */
;;;158    
;;;159    #if OS_CFG_DBG_EN > 0u
;;;160        OS_MemDbgListAdd(p_mem);
;;;161    #endif
;;;162    
;;;163        OSMemQty++;
;;;164    
;;;165        OS_CRITICAL_EXIT_NO_SCHED();
;;;166       *p_err = OS_ERR_NONE;
;;;167    }
00003c  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.64|
000040  f0180f03          TST      r8,#3                 ;133
000044  d001              BEQ      |L1.74|
                  |L1.70|
000046  8031              STRH     r1,[r6,#0]            ;134
000048  e7f8              B        |L1.60|
                  |L1.74|
00004a  1e7a              SUBS     r2,r7,#1              ;142
00004c  b293              UXTH     r3,r2                 ;142
00004e  4621              MOV      r1,r4                 ;140
000050  2200              MOVS     r2,#0                 ;143
000052  e005              B        |L1.96|
                  |L1.84|
000054  eb010008          ADD      r0,r1,r8              ;144
000058  6008              STR      r0,[r1,#0]            ;146
00005a  1c52              ADDS     r2,r2,#1              ;143
00005c  4601              MOV      r1,r0                 ;146
00005e  b292              UXTH     r2,r2                 ;143
                  |L1.96|
000060  429a              CMP      r2,r3                 ;143
000062  d3f7              BCC      |L1.84|
000064  f04f0a00          MOV      r10,#0                ;148
000068  f8c1a000          STR      r10,[r1,#0]           ;150
00006c  f7fffffe          BL       CPU_SR_Save
000070  f8df9048          LDR      r9,|L1.188|
000074  f8991000          LDRB     r1,[r9,#0]            ;150  ; OSSchedLockNestingCtr
000078  1c49              ADDS     r1,r1,#1              ;150
00007a  f8891000          STRB     r1,[r9,#0]            ;150
00007e  f7fffffe          BL       CPU_SR_Restore
000082  480f              LDR      r0,|L1.192|
000084  e8850811          STM      r5,{r0,r4,r11}        ;151
000088  60ec              STR      r4,[r5,#0xc]          ;155
00008a  82af              STRH     r7,[r5,#0x14]         ;155
00008c  826f              STRH     r7,[r5,#0x12]         ;156
00008e  f8a58010          STRH     r8,[r5,#0x10]         ;157
000092  4628              MOV      r0,r5                 ;160
000094  f7fffffe          BL       OS_MemDbgListAdd
000098  490a              LDR      r1,|L1.196|
00009a  8808              LDRH     r0,[r1,#0]            ;163  ; OSMemQty
00009c  1c40              ADDS     r0,r0,#1              ;163
00009e  8008              STRH     r0,[r1,#0]            ;163
0000a0  f7fffffe          BL       CPU_SR_Save
0000a4  f8991000          LDRB     r1,[r9,#0]            ;165  ; OSSchedLockNestingCtr
0000a8  1e49              SUBS     r1,r1,#1              ;165
0000aa  f8891000          STRB     r1,[r9,#0]            ;165
0000ae  f7fffffe          BL       CPU_SR_Restore
0000b2  f8a6a000          STRH     r10,[r6,#0]           ;166
0000b6  e7c1              B        |L1.60|
;;;168    
                          ENDP

                  |L1.184|
                          DCD      OSIntNestingCtr
                  |L1.188|
                          DCD      OSSchedLockNestingCtr
                  |L1.192|
                          DCD      0x204d454d
                  |L1.196|
                          DCD      OSMemQty

                          AREA ||i.OSMemGet||, CODE, READONLY, ALIGN=1

                  OSMemGet PROC
;;;189    
;;;190    void  *OSMemGet (OS_MEM  *p_mem,
000000  b570              PUSH     {r4-r6,lr}
;;;191                     OS_ERR  *p_err)
;;;192    {
000002  0004              MOVS     r4,r0
000004  460d              MOV      r5,r1
000006  d010              BEQ      |L2.42|
;;;193        void    *p_blk;
;;;194        CPU_SR_ALLOC();
;;;195    
;;;196    
;;;197    
;;;198    #ifdef OS_SAFETY_CRITICAL
;;;199        if (p_err == (OS_ERR *)0) {
;;;200            OS_SAFETY_CRITICAL_EXCEPTION();
;;;201            return ((void *)0);
;;;202        }
;;;203    #endif
;;;204    
;;;205    #if OS_CFG_ARG_CHK_EN > 0u
;;;206        if (p_mem == (OS_MEM *)0) {                             /* Must point to a valid memory partition                 */
;;;207           *p_err  = OS_ERR_MEM_INVALID_P_MEM;
;;;208            return ((void *)0);
;;;209        }
;;;210    #endif
;;;211    
;;;212        CPU_CRITICAL_ENTER();
000008  f7fffffe          BL       CPU_SR_Save
00000c  4601              MOV      r1,r0
;;;213        if (p_mem->NbrFree == (OS_MEM_QTY)0) {                  /* See if there are any free memory blocks                */
00000e  8aa0              LDRH     r0,[r4,#0x14]
000010  b178              CBZ      r0,|L2.50|
;;;214            CPU_CRITICAL_EXIT();
;;;215           *p_err = OS_ERR_MEM_NO_FREE_BLKS;                    /* No,  Notify caller of empty memory partition           */
;;;216            return ((void *)0);                                 /*      Return NULL pointer to caller                     */
;;;217        }
;;;218        p_blk              = p_mem->FreeListPtr;                /* Yes, point to next free memory block                   */
;;;219        p_mem->FreeListPtr = *(void **)p_blk;                   /*      Adjust pointer to new free list                   */
000012  68e6              LDR      r6,[r4,#0xc]
;;;220        p_mem->NbrFree--;                                       /*      One less memory block in this partition           */
000014  1e40              SUBS     r0,r0,#1
000016  6832              LDR      r2,[r6,#0]            ;219
000018  60e2              STR      r2,[r4,#0xc]
00001a  82a0              STRH     r0,[r4,#0x14]
;;;221        CPU_CRITICAL_EXIT();
00001c  4608              MOV      r0,r1
00001e  f7fffffe          BL       CPU_SR_Restore
;;;222       *p_err = OS_ERR_NONE;                                    /*      No error                                          */
000022  2000              MOVS     r0,#0
000024  8028              STRH     r0,[r5,#0]
;;;223        return (p_blk);                                         /*      Return memory block to caller                     */
000026  4630              MOV      r0,r6
;;;224    }
000028  bd70              POP      {r4-r6,pc}
                  |L2.42|
00002a  f24560bf          MOV      r0,#0x56bf            ;207
00002e  8008              STRH     r0,[r1,#0]            ;207
000030  e005              B        |L2.62|
                  |L2.50|
000032  4608              MOV      r0,r1                 ;214
000034  f7fffffe          BL       CPU_SR_Restore
000038  f24560c2          MOV      r0,#0x56c2            ;215
00003c  8028              STRH     r0,[r5,#0]            ;215
                  |L2.62|
00003e  2000              MOVS     r0,#0                 ;216
000040  bd70              POP      {r4-r6,pc}
;;;225    
                          ENDP


                          AREA ||i.OSMemPut||, CODE, READONLY, ALIGN=1

                  OSMemPut PROC
;;;246    
;;;247    void  OSMemPut (OS_MEM  *p_mem,
000000  b570              PUSH     {r4-r6,lr}
;;;248                    void    *p_blk,
;;;249                    OS_ERR  *p_err)
;;;250    {
000002  460e              MOV      r6,r1
000004  0004              MOVS     r4,r0
000006  4615              MOV      r5,r2
000008  d00b              BEQ      |L3.34|
;;;251        CPU_SR_ALLOC();
;;;252    
;;;253    
;;;254    
;;;255    #ifdef OS_SAFETY_CRITICAL
;;;256        if (p_err == (OS_ERR *)0) {
;;;257            OS_SAFETY_CRITICAL_EXCEPTION();
;;;258            return;
;;;259        }
;;;260    #endif
;;;261    
;;;262    #if OS_CFG_ARG_CHK_EN > 0u
;;;263        if (p_mem == (OS_MEM *)0) {                             /* Must point to a valid memory partition                 */
;;;264           *p_err  = OS_ERR_MEM_INVALID_P_MEM;
;;;265            return;
;;;266        }
;;;267        if (p_blk == (void *)0) {                               /* Must release a valid block                             */
00000a  b16e              CBZ      r6,|L3.40|
;;;268           *p_err  = OS_ERR_MEM_INVALID_P_BLK;
;;;269            return;
;;;270        }
;;;271    #endif
;;;272    
;;;273        CPU_CRITICAL_ENTER();
00000c  f7fffffe          BL       CPU_SR_Save
;;;274        if (p_mem->NbrFree >= p_mem->NbrMax) {                  /* Make sure all blocks not already returned              */
000010  8aa1              LDRH     r1,[r4,#0x14]
000012  8a62              LDRH     r2,[r4,#0x12]
000014  4291              CMP      r1,r2
000016  d30b              BCC      |L3.48|
;;;275            CPU_CRITICAL_EXIT();
000018  f7fffffe          BL       CPU_SR_Restore
;;;276           *p_err = OS_ERR_MEM_FULL;
00001c  f24560ba          MOV      r0,#0x56ba
;;;277            return;
000020  e00f              B        |L3.66|
                  |L3.34|
000022  f24560bf          MOV      r0,#0x56bf            ;264
000026  e001              B        |L3.44|
                  |L3.40|
000028  f24560be          MOV      r0,#0x56be            ;268
                  |L3.44|
00002c  8010              STRH     r0,[r2,#0]            ;268
;;;278        }
;;;279        *(void **)p_blk    = p_mem->FreeListPtr;                /* Insert released block into free block list             */
;;;280        p_mem->FreeListPtr = p_blk;
;;;281        p_mem->NbrFree++;                                       /* One more memory block in this partition                */
;;;282        CPU_CRITICAL_EXIT();
;;;283       *p_err              = OS_ERR_NONE;                       /* Notify caller that memory block was released           */
;;;284    }
00002e  bd70              POP      {r4-r6,pc}
                  |L3.48|
000030  68e1              LDR      r1,[r4,#0xc]          ;279
000032  6031              STR      r1,[r6,#0]            ;280
000034  60e6              STR      r6,[r4,#0xc]          ;281
000036  8aa1              LDRH     r1,[r4,#0x14]         ;281
000038  1c49              ADDS     r1,r1,#1              ;281
00003a  82a1              STRH     r1,[r4,#0x14]         ;281
00003c  f7fffffe          BL       CPU_SR_Restore
000040  2000              MOVS     r0,#0                 ;283
                  |L3.66|
000042  8028              STRH     r0,[r5,#0]            ;283
000044  bd70              POP      {r4-r6,pc}
;;;285    
                          ENDP


                          AREA ||i.OS_MemDbgListAdd||, CODE, READONLY, ALIGN=2

                  OS_MemDbgListAdd PROC
;;;301    #if OS_CFG_DBG_EN > 0u
;;;302    void  OS_MemDbgListAdd (OS_MEM  *p_mem)
000000  4b05              LDR      r3,|L4.24|
;;;303    {
;;;304        p_mem->DbgPrevPtr               = (OS_MEM *)0;
000002  2200              MOVS     r2,#0
;;;305        if (OSMemDbgListPtr == (OS_MEM *)0) {
000004  6182              STR      r2,[r0,#0x18]
000006  6819              LDR      r1,[r3,#0]            ;303  ; OSMemDbgListPtr
000008  b119              CBZ      r1,|L4.18|
;;;306            p_mem->DbgNextPtr           = (OS_MEM *)0;
;;;307        } else {
;;;308            p_mem->DbgNextPtr           =  OSMemDbgListPtr;
;;;309            OSMemDbgListPtr->DbgPrevPtr =  p_mem;
00000a  61c1              STR      r1,[r0,#0x1c]
00000c  6188              STR      r0,[r1,#0x18]
                  |L4.14|
;;;310        }
;;;311        OSMemDbgListPtr                 =  p_mem;
;;;312    }
00000e  6018              STR      r0,[r3,#0]  ; OSMemDbgListPtr
000010  4770              BX       lr
                  |L4.18|
000012  61c2              STR      r2,[r0,#0x1c]         ;306
000014  e7fb              B        |L4.14|
;;;313    #endif
                          ENDP

000016  0000              DCW      0x0000
                  |L4.24|
                          DCD      OSMemDbgListPtr

                          AREA ||i.OS_MemInit||, CODE, READONLY, ALIGN=2

                  OS_MemInit PROC
;;;330    
;;;331    void  OS_MemInit (OS_ERR  *p_err)
000000  4a03              LDR      r2,|L5.16|
;;;332    {
;;;333    #ifdef OS_SAFETY_CRITICAL
;;;334        if (p_err == (OS_ERR *)0) {
;;;335            OS_SAFETY_CRITICAL_EXCEPTION();
;;;336            return;
;;;337        }
;;;338    #endif
;;;339    
;;;340    #if OS_CFG_DBG_EN > 0u
;;;341        OSMemDbgListPtr = (OS_MEM   *)0;
000002  2100              MOVS     r1,#0
;;;342    #endif
;;;343    
;;;344        OSMemQty        = (OS_OBJ_QTY)0;
000004  6011              STR      r1,[r2,#0]  ; OSMemDbgListPtr
000006  4a03              LDR      r2,|L5.20|
000008  8011              STRH     r1,[r2,#0]
;;;345       *p_err           = OS_ERR_NONE;
00000a  8001              STRH     r1,[r0,#0]
;;;346    }
00000c  4770              BX       lr
;;;347    #endif
                          ENDP

00000e  0000              DCW      0x0000
                  |L5.16|
                          DCD      OSMemDbgListPtr
                  |L5.20|
                          DCD      OSMemQty
