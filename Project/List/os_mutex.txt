; generated by ARM C/C++ Compiler, 5.02 [Build 28]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\OBJ\os_mutex.o --asm_dir=.\List\ --list_dir=.\List\ --depend=..\OBJ\os_mutex.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\BSP -I..\CORE -I..\STM32F10x_FWLib\inc -I..\USER -I..\UCOSIII\uC-CPU -I..\UCOSIII\uC-CPU\ARM-Cortex-M3\RealView -I..\UCOSIII\uC-LIB -I..\UCOSIII\uC-LIB\Ports\ARM-Cortex-M3\RealView -I..\UCOSIII\uCOS-III -I..\UCOSIII\uCOS-III\Ports -I..\UCOSIII\uCOS-III\Ports\ARM-Cortex-M3\Generic\RealView -I..\UCOSIII\uCOS-III\Source -I..\UCOSIII\UCOS_BSP -I..\UCOSIII\uCOS_CONFIG -I..\UCOSIII-Task -I..\SYSTEM -I..\BSP\inc -I..\PAL -I..\PAL\vehicles -ID:\Keil_v4\ARM\RV31\INC -ID:\Keil_v4\ARM\CMSIS\Include -ID:\Keil_v4\ARM\Inc\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=..\OBJ\os_mutex.crf ..\UCOSIII\uCOS-III\Source\os_mutex.c]
                          THUMB

                          AREA ||i.OSMutexCreate||, CODE, READONLY, ALIGN=2

                  OSMutexCreate PROC
;;;66     
;;;67     void  OSMutexCreate (OS_MUTEX  *p_mutex,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;68                          CPU_CHAR  *p_name,
;;;69                          OS_ERR    *p_err)
;;;70     {
000004  4604              MOV      r4,r0
;;;71         CPU_SR_ALLOC();
;;;72     
;;;73     
;;;74     
;;;75     #ifdef OS_SAFETY_CRITICAL
;;;76         if (p_err == (OS_ERR *)0) {
;;;77             OS_SAFETY_CRITICAL_EXCEPTION();
;;;78             return;
;;;79         }
;;;80     #endif
;;;81     
;;;82     #ifdef OS_SAFETY_CRITICAL_IEC61508
;;;83         if (OSSafetyCriticalStartFlag == DEF_TRUE) {
;;;84            *p_err = OS_ERR_ILLEGAL_CREATE_RUN_TIME;
;;;85             return;
;;;86         }
;;;87     #endif
;;;88     
;;;89     #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;90         if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to be called from an ISR                   */
000006  481a              LDR      r0,|L1.112|
000008  460f              MOV      r7,r1                 ;70
00000a  4615              MOV      r5,r2                 ;70
00000c  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
00000e  b110              CBZ      r0,|L1.22|
;;;91            *p_err = OS_ERR_CREATE_ISR;
000010  f64260e1          MOV      r0,#0x2ee1
;;;92             return;
000014  e02a              B        |L1.108|
                  |L1.22|
;;;93         }
;;;94     #endif
;;;95     
;;;96     #if OS_CFG_ARG_CHK_EN > 0u
;;;97         if (p_mutex == (OS_MUTEX *)0) {                         /* Validate 'p_mutex'                                     */
000016  b33c              CBZ      r4,|L1.104|
;;;98            *p_err = OS_ERR_OBJ_PTR_NULL;
;;;99             return;
;;;100        }
;;;101    #endif
;;;102    
;;;103        OS_CRITICAL_ENTER();
000018  f7fffffe          BL       CPU_SR_Save
00001c  4e15              LDR      r6,|L1.116|
00001e  7831              LDRB     r1,[r6,#0]  ; OSSchedLockNestingCtr
000020  1c49              ADDS     r1,r1,#1
000022  7031              STRB     r1,[r6,#0]
000024  f7fffffe          BL       CPU_SR_Restore
;;;104        p_mutex->Type              =  OS_OBJ_TYPE_MUTEX;        /* Mark the data structure as a mutex                     */
000028  4813              LDR      r0,|L1.120|
00002a  e9c40700          STRD     r0,r7,[r4,#0]
;;;105        p_mutex->NamePtr           =  p_name;
;;;106        p_mutex->OwnerTCBPtr       = (OS_TCB       *)0;
00002e  2700              MOVS     r7,#0
;;;107        p_mutex->OwnerNestingCtr   = (OS_NESTING_CTR)0;         /* Mutex is available                                     */
000030  6227              STR      r7,[r4,#0x20]
000032  f8847025          STRB     r7,[r4,#0x25]
;;;108        p_mutex->TS                = (CPU_TS        )0;
;;;109        p_mutex->OwnerOriginalPrio =  OS_CFG_PRIO_MAX;
000036  2040              MOVS     r0,#0x40
000038  62a7              STR      r7,[r4,#0x28]
00003a  f8840024          STRB     r0,[r4,#0x24]
;;;110        OS_PendListInit(&p_mutex->PendList);                    /* Initialize the waiting list                            */
00003e  f1040008          ADD      r0,r4,#8
000042  f7fffffe          BL       OS_PendListInit
;;;111    
;;;112    #if OS_CFG_DBG_EN > 0u
;;;113        OS_MutexDbgListAdd(p_mutex);
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       OS_MutexDbgListAdd
;;;114    #endif
;;;115        OSMutexQty++;
00004c  490b              LDR      r1,|L1.124|
00004e  8808              LDRH     r0,[r1,#0]  ; OSMutexQty
000050  1c40              ADDS     r0,r0,#1
000052  8008              STRH     r0,[r1,#0]
;;;116    
;;;117        OS_CRITICAL_EXIT_NO_SCHED();
000054  f7fffffe          BL       CPU_SR_Save
000058  7831              LDRB     r1,[r6,#0]  ; OSSchedLockNestingCtr
00005a  1e49              SUBS     r1,r1,#1
00005c  7031              STRB     r1,[r6,#0]
00005e  f7fffffe          BL       CPU_SR_Restore
;;;118       *p_err = OS_ERR_NONE;
000062  802f              STRH     r7,[r5,#0]
                  |L1.100|
;;;119    }
000064  e8bd81f0          POP      {r4-r8,pc}
                  |L1.104|
000068  f64550c3          MOV      r0,#0x5dc3            ;98
                  |L1.108|
00006c  8010              STRH     r0,[r2,#0]            ;98
00006e  e7f9              B        |L1.100|
;;;120    
                          ENDP

                  |L1.112|
                          DCD      OSIntNestingCtr
                  |L1.116|
                          DCD      OSSchedLockNestingCtr
                  |L1.120|
                          DCD      0x5854554d
                  |L1.124|
                          DCD      OSMutexQty

                          AREA ||i.OSMutexDel||, CODE, READONLY, ALIGN=2

                  OSMutexDel PROC
;;;159    #if OS_CFG_MUTEX_DEL_EN > 0u
;;;160    OS_OBJ_QTY  OSMutexDel (OS_MUTEX  *p_mutex,
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;161                            OS_OPT     opt,
;;;162                            OS_ERR    *p_err)
;;;163    {
000004  4605              MOV      r5,r0
;;;164        OS_OBJ_QTY     cnt;
;;;165        OS_OBJ_QTY     nbr_tasks;
;;;166        OS_PEND_DATA  *p_pend_data;
;;;167        OS_PEND_LIST  *p_pend_list;
;;;168        OS_TCB        *p_tcb;
;;;169        OS_TCB        *p_tcb_owner;
;;;170        CPU_TS         ts;
;;;171        CPU_SR_ALLOC();
;;;172    
;;;173    
;;;174    
;;;175    #ifdef OS_SAFETY_CRITICAL
;;;176        if (p_err == (OS_ERR *)0) {
;;;177            OS_SAFETY_CRITICAL_EXCEPTION();
;;;178            return ((OS_OBJ_QTY)0);
;;;179        }
;;;180    #endif
;;;181    
;;;182    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;183        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {                  /* Not allowed to delete a mutex from an ISR          */
000006  4874              LDR      r0,|L2.472|
000008  460e              MOV      r6,r1                 ;163
00000a  4614              MOV      r4,r2                 ;163
00000c  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
00000e  b110              CBZ      r0,|L2.22|
;;;184           *p_err = OS_ERR_DEL_ISR;
000010  f24320c9          MOV      r0,#0x32c9
;;;185            return ((OS_OBJ_QTY)0);
000014  e008              B        |L2.40|
                  |L2.22|
;;;186        }
;;;187    #endif
;;;188    
;;;189    #if OS_CFG_ARG_CHK_EN > 0u
;;;190        if (p_mutex == (OS_MUTEX *)0) {                             /* Validate 'p_mutex'                                 */
000016  b12d              CBZ      r5,|L2.36|
;;;191           *p_err = OS_ERR_OBJ_PTR_NULL;
;;;192            return ((OS_OBJ_QTY)0);
;;;193        }
;;;194        switch (opt) {                                              /* Validate 'opt'                                     */
000018  b146              CBZ      r6,|L2.44|
00001a  2e01              CMP      r6,#1
00001c  d006              BEQ      |L2.44|
;;;195            case OS_OPT_DEL_NO_PEND:
;;;196            case OS_OPT_DEL_ALWAYS:
;;;197                 break;
;;;198    
;;;199            default:
;;;200                *p_err =  OS_ERR_OPT_INVALID;
00001e  f6456025          MOV      r0,#0x5e25
;;;201                 return ((OS_OBJ_QTY)0);
000022  e001              B        |L2.40|
                  |L2.36|
000024  f64550c3          MOV      r0,#0x5dc3            ;191
                  |L2.40|
000028  8010              STRH     r0,[r2,#0]            ;184
00002a  e0a4              B        |L2.374|
                  |L2.44|
;;;202        }
;;;203    #endif
;;;204    
;;;205    #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
;;;206        if (p_mutex->Type != OS_OBJ_TYPE_MUTEX) {                   /* Make sure mutex was created                        */
00002c  496b              LDR      r1,|L2.476|
00002e  6828              LDR      r0,[r5,#0]
000030  4288              CMP      r0,r1
000032  d002              BEQ      |L2.58|
;;;207           *p_err = OS_ERR_OBJ_TYPE;
000034  f64550c4          MOV      r0,#0x5dc4
;;;208            return ((OS_OBJ_QTY)0);
000038  e7f6              B        |L2.40|
                  |L2.58|
;;;209        }
;;;210    #endif
;;;211    
;;;212        OS_CRITICAL_ENTER();
00003a  f7fffffe          BL       CPU_SR_Save
00003e  f8df81a0          LDR      r8,|L2.480|
000042  f8982000          LDRB     r2,[r8,#0]  ; OSSchedLockNestingCtr
000046  1c52              ADDS     r2,r2,#1
000048  f8882000          STRB     r2,[r8,#0]
00004c  f7fffffe          BL       CPU_SR_Restore
;;;213        p_pend_list = &p_mutex->PendList;
;;;214        cnt         = p_pend_list->NbrEntries;
000050  8a2f              LDRH     r7,[r5,#0x10]
;;;215        nbr_tasks   = cnt;
;;;216        switch (opt) {
;;;217            case OS_OPT_DEL_NO_PEND:                                /* Delete mutex only if no task waiting               */
;;;218                 if (nbr_tasks == (OS_OBJ_QTY)0) {
;;;219    #if OS_CFG_DBG_EN > 0u
;;;220                     OS_MutexDbgListRemove(p_mutex);
;;;221    #endif
;;;222                     OSMutexQty--;
;;;223                     OS_MutexClr(p_mutex);
;;;224                     OS_CRITICAL_EXIT();
000052  f8dfa190          LDR      r10,|L2.484|
000056  f1050908          ADD      r9,r5,#8              ;213
00005a  46bb              MOV      r11,r7                ;215
00005c  b166              CBZ      r6,|L2.120|
00005e  2e01              CMP      r6,#1                 ;216
000060  d048              BEQ      |L2.244|
;;;225                    *p_err = OS_ERR_NONE;
;;;226                 } else {
;;;227                     OS_CRITICAL_EXIT();
;;;228                    *p_err = OS_ERR_TASK_WAITING;
;;;229                 }
;;;230                 break;
;;;231    
;;;232            case OS_OPT_DEL_ALWAYS:                                            /* Always delete the mutex                 */
;;;233                 p_tcb_owner = p_mutex->OwnerTCBPtr;                           /* Did we had to change the prio of owner? */
;;;234                 if ((p_tcb_owner       != (OS_TCB *)0) &&
;;;235                     (p_tcb_owner->Prio !=  p_mutex->OwnerOriginalPrio)) {
;;;236                     switch (p_tcb_owner->TaskState) {                         /* yes                                     */
;;;237                         case OS_TASK_STATE_RDY:
;;;238                              OS_RdyListRemove(p_tcb_owner);
;;;239                              p_tcb_owner->Prio = p_mutex->OwnerOriginalPrio;  /* Lower owner's prio back                 */
;;;240                              OS_PrioInsert(p_tcb_owner->Prio);
;;;241                              OS_RdyListInsertTail(p_tcb_owner);               /* Insert owner in ready list at new prio  */
;;;242                              break;
;;;243    
;;;244                         case OS_TASK_STATE_DLY:
;;;245                         case OS_TASK_STATE_SUSPENDED:
;;;246                         case OS_TASK_STATE_DLY_SUSPENDED:
;;;247                              p_tcb_owner->Prio = p_mutex->OwnerOriginalPrio;  /* Not in any pend list, change the prio   */
;;;248                              break;
;;;249    
;;;250                         case OS_TASK_STATE_PEND:
;;;251                         case OS_TASK_STATE_PEND_TIMEOUT:
;;;252                         case OS_TASK_STATE_PEND_SUSPENDED:
;;;253                         case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
;;;254                              OS_PendListChangePrio(p_tcb_owner,               /* Owner is pending on another object      */
;;;255                                                    p_mutex->OwnerOriginalPrio);
;;;256                              break;
;;;257    
;;;258                         default:
;;;259                              OS_CRITICAL_EXIT();
;;;260                             *p_err = OS_ERR_STATE_INVALID;
;;;261                              return ((OS_OBJ_QTY)0);
;;;262                     }
;;;263                 }
;;;264    
;;;265                 ts = OS_TS_GET();                                             /* Get timestamp                           */
;;;266                 while (cnt > 0u) {                                            /* Remove all tasks from the pend list     */
;;;267                     p_pend_data = p_pend_list->HeadPtr;
;;;268                     p_tcb       = p_pend_data->TCBPtr;
;;;269                     OS_PendObjDel((OS_PEND_OBJ *)((void *)p_mutex),
;;;270                                   p_tcb,
;;;271                                   ts);
;;;272                     cnt--;
;;;273                 }
;;;274    #if OS_CFG_DBG_EN > 0u
;;;275                 OS_MutexDbgListRemove(p_mutex);
;;;276    #endif
;;;277                 OSMutexQty--;
;;;278                 OS_MutexClr(p_mutex);
;;;279                 OS_CRITICAL_EXIT_NO_SCHED();
;;;280                 OSSched();                                                    /* Find highest priority task ready to run */
;;;281                *p_err = OS_ERR_NONE;
;;;282                 break;
;;;283    
;;;284            default:
;;;285                 OS_CRITICAL_EXIT();
000062  f7fffffe          BL       CPU_SR_Save
000066  f8982000          LDRB     r2,[r8,#0]  ; OSSchedLockNestingCtr
00006a  1e52              SUBS     r2,r2,#1
00006c  f01202ff          ANDS     r2,r2,#0xff
000070  f8882000          STRB     r2,[r8,#0]
000074  d079              BEQ      |L2.362|
000076  e0aa              B        |L2.462|
                  |L2.120|
000078  f1bb0f00          CMP      r11,#0                ;218
00007c  d00a              BEQ      |L2.148|
00007e  f7fffffe          BL       CPU_SR_Save
000082  f8982000          LDRB     r2,[r8,#0]            ;227  ; OSSchedLockNestingCtr
000086  1e52              SUBS     r2,r2,#1              ;227
000088  f01202ff          ANDS     r2,r2,#0xff           ;227
00008c  f8882000          STRB     r2,[r8,#0]            ;227
000090  d020              BEQ      |L2.212|
000092  e027              B        |L2.228|
                  |L2.148|
000094  4628              MOV      r0,r5                 ;220
000096  f7fffffe          BL       OS_MutexDbgListRemove
00009a  4853              LDR      r0,|L2.488|
00009c  8801              LDRH     r1,[r0,#0]            ;222  ; OSMutexQty
00009e  1e49              SUBS     r1,r1,#1              ;222
0000a0  8001              STRH     r1,[r0,#0]            ;222
0000a2  4628              MOV      r0,r5                 ;223
0000a4  f7fffffe          BL       OS_MutexClr
0000a8  f7fffffe          BL       CPU_SR_Save
0000ac  f8982000          LDRB     r2,[r8,#0]            ;224  ; OSSchedLockNestingCtr
0000b0  1e52              SUBS     r2,r2,#1              ;224
0000b2  f01202ff          ANDS     r2,r2,#0xff           ;224
0000b6  f8882000          STRB     r2,[r8,#0]            ;224
0000ba  d107              BNE      |L2.204|
0000bc  f8ba1000          LDRH     r1,[r10,#0]           ;224  ; OSIntQNbrEntries
0000c0  b121              CBZ      r1,|L2.204|
0000c2  f7fffffe          BL       CPU_SR_Restore
0000c6  f7fffffe          BL       OS_Sched0
0000ca  e001              B        |L2.208|
                  |L2.204|
0000cc  f7fffffe          BL       CPU_SR_Restore
                  |L2.208|
0000d0  2000              MOVS     r0,#0                 ;225
0000d2  e00b              B        |L2.236|
                  |L2.212|
0000d4  f8ba1000          LDRH     r1,[r10,#0]           ;227  ; OSIntQNbrEntries
0000d8  b121              CBZ      r1,|L2.228|
0000da  f7fffffe          BL       CPU_SR_Restore
0000de  f7fffffe          BL       OS_Sched0
0000e2  e001              B        |L2.232|
                  |L2.228|
0000e4  f7fffffe          BL       CPU_SR_Restore
                  |L2.232|
0000e8  f247105f          MOV      r0,#0x715f            ;228
                  |L2.236|
0000ec  8020              STRH     r0,[r4,#0]            ;225
;;;286                *p_err = OS_ERR_OPT_INVALID;
;;;287                 break;
;;;288        }
;;;289        return (nbr_tasks);
0000ee  4658              MOV      r0,r11
                  |L2.240|
;;;290    }
0000f0  e8bd9ff0          POP      {r4-r12,pc}
                  |L2.244|
0000f4  6a2e              LDR      r6,[r5,#0x20]         ;234
0000f6  b316              CBZ      r6,|L2.318|
0000f8  f8960037          LDRB     r0,[r6,#0x37]         ;235
0000fc  f8951024          LDRB     r1,[r5,#0x24]         ;235
000100  4288              CMP      r0,r1                 ;235
000102  d01c              BEQ      |L2.318|
000104  f8960036          LDRB     r0,[r6,#0x36]         ;236
000108  2808              CMP      r0,#8                 ;236
00010a  d21c              BCS      |L2.326|
00010c  e8dff000          TBB      [pc,r0]               ;236
000110  04111414          DCB      0x04,0x11,0x14,0x14
000114  11111414          DCB      0x11,0x11,0x14,0x14
000118  4630              MOV      r0,r6                 ;238
00011a  f7fffffe          BL       OS_RdyListRemove
00011e  f8950024          LDRB     r0,[r5,#0x24]         ;239
000122  f8860037          STRB     r0,[r6,#0x37]         ;239
000126  f7fffffe          BL       OS_PrioInsert
00012a  4630              MOV      r0,r6                 ;241
00012c  f7fffffe          BL       OS_RdyListInsertTail
000130  e005              B        |L2.318|
000132  f8861037          STRB     r1,[r6,#0x37]         ;247
000136  e002              B        |L2.318|
000138  4630              MOV      r0,r6                 ;254
00013a  f7fffffe          BL       OS_PendListChangePrio
                  |L2.318|
00013e  f7fffffe          BL       CPU_TS_TmrRd
000142  4606              MOV      r6,r0                 ;265
000144  e023              B        |L2.398|
                  |L2.326|
000146  f7fffffe          BL       CPU_SR_Save
00014a  f8982000          LDRB     r2,[r8,#0]            ;259  ; OSSchedLockNestingCtr
00014e  1e52              SUBS     r2,r2,#1              ;259
000150  f01202ff          ANDS     r2,r2,#0xff           ;259
000154  f8882000          STRB     r2,[r8,#0]            ;259
000158  d108              BNE      |L2.364|
00015a  f8ba1000          LDRH     r1,[r10,#0]           ;259  ; OSIntQNbrEntries
00015e  b129              CBZ      r1,|L2.364|
000160  f7fffffe          BL       CPU_SR_Restore
000164  f7fffffe          BL       OS_Sched0
000168  e002              B        |L2.368|
                  |L2.362|
00016a  e028              B        |L2.446|
                  |L2.364|
00016c  f7fffffe          BL       CPU_SR_Restore
                  |L2.368|
000170  f646602d          MOV      r0,#0x6e2d            ;260
000174  8020              STRH     r0,[r4,#0]            ;260
                  |L2.374|
000176  2000              MOVS     r0,#0                 ;261
000178  e7ba              B        |L2.240|
00017a  bf00              NOP                            ;268
                  |L2.380|
00017c  f8d90000          LDR      r0,[r9,#0]            ;268
000180  4632              MOV      r2,r6                 ;269
000182  6881              LDR      r1,[r0,#8]            ;269
000184  4628              MOV      r0,r5                 ;269
000186  f7fffffe          BL       OS_PendObjDel
00018a  1e7f              SUBS     r7,r7,#1              ;272
00018c  b2bf              UXTH     r7,r7                 ;272
                  |L2.398|
00018e  2f00              CMP      r7,#0                 ;266
000190  d1f4              BNE      |L2.380|
000192  4628              MOV      r0,r5                 ;275
000194  f7fffffe          BL       OS_MutexDbgListRemove
000198  4813              LDR      r0,|L2.488|
00019a  8801              LDRH     r1,[r0,#0]            ;277  ; OSMutexQty
00019c  1e49              SUBS     r1,r1,#1              ;277
00019e  8001              STRH     r1,[r0,#0]            ;277
0001a0  4628              MOV      r0,r5                 ;278
0001a2  f7fffffe          BL       OS_MutexClr
0001a6  f7fffffe          BL       CPU_SR_Save
0001aa  f8982000          LDRB     r2,[r8,#0]            ;279  ; OSSchedLockNestingCtr
0001ae  1e52              SUBS     r2,r2,#1              ;279
0001b0  f8882000          STRB     r2,[r8,#0]            ;279
0001b4  f7fffffe          BL       CPU_SR_Restore
0001b8  f7fffffe          BL       OSSched
0001bc  e788              B        |L2.208|
                  |L2.446|
0001be  f8ba1000          LDRH     r1,[r10,#0]           ;285  ; OSIntQNbrEntries
0001c2  b121              CBZ      r1,|L2.462|
0001c4  f7fffffe          BL       CPU_SR_Restore
0001c8  f7fffffe          BL       OS_Sched0
0001cc  e001              B        |L2.466|
                  |L2.462|
0001ce  f7fffffe          BL       CPU_SR_Restore
                  |L2.466|
0001d2  f6456025          MOV      r0,#0x5e25            ;286
0001d6  e789              B        |L2.236|
;;;291    #endif
                          ENDP

                  |L2.472|
                          DCD      OSIntNestingCtr
                  |L2.476|
                          DCD      0x5854554d
                  |L2.480|
                          DCD      OSSchedLockNestingCtr
                  |L2.484|
                          DCD      OSIntQNbrEntries
                  |L2.488|
                          DCD      OSMutexQty

                          AREA ||i.OSMutexPend||, CODE, READONLY, ALIGN=2

                  OSMutexPend PROC
;;;338    
;;;339    void  OSMutexPend (OS_MUTEX  *p_mutex,
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;340                       OS_TICK    timeout,
;;;341                       OS_OPT     opt,
;;;342                       CPU_TS    *p_ts,
;;;343                       OS_ERR    *p_err)
;;;344    {
000004  4606              MOV      r6,r0
;;;345        OS_PEND_DATA  pend_data;
;;;346        OS_TCB       *p_tcb;
;;;347        CPU_SR_ALLOC();
;;;348    
;;;349    
;;;350    
;;;351    #ifdef OS_SAFETY_CRITICAL
;;;352        if (p_err == (OS_ERR *)0) {
;;;353            OS_SAFETY_CRITICAL_EXCEPTION();
;;;354            return;
;;;355        }
;;;356    #endif
;;;357    
;;;358    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;359        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
000006  4870              LDR      r0,|L3.456|
000008  b089              SUB      sp,sp,#0x24           ;344
00000a  4617              MOV      r7,r2                 ;344
00000c  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
00000e  9d12              LDR      r5,[sp,#0x48]         ;344
000010  461c              MOV      r4,r3                 ;344
000012  468b              MOV      r11,r1                ;344
000014  b110              CBZ      r0,|L3.28|
;;;360           *p_err = OS_ERR_PEND_ISR;
000016  f24610ae          MOV      r0,#0x61ae
;;;361            return;
00001a  e0b8              B        |L3.398|
                  |L3.28|
;;;362        }
;;;363    #endif
;;;364    
;;;365    #if OS_CFG_ARG_CHK_EN > 0u
;;;366        if (p_mutex == (OS_MUTEX *)0) {                         /* Validate arguments                                     */
00001c  b136              CBZ      r6,|L3.44|
;;;367           *p_err = OS_ERR_OBJ_PTR_NULL;
;;;368            return;
;;;369        }
;;;370        switch (opt) {                                          /* Validate 'opt'                                         */
00001e  b147              CBZ      r7,|L3.50|
000020  f5b74f00          CMP      r7,#0x8000
000024  d005              BEQ      |L3.50|
;;;371            case OS_OPT_PEND_BLOCKING:
;;;372            case OS_OPT_PEND_NON_BLOCKING:
;;;373                 break;
;;;374    
;;;375            default:
;;;376                *p_err = OS_ERR_OPT_INVALID;
000026  f6456025          MOV      r0,#0x5e25
;;;377                 return;
00002a  e0b0              B        |L3.398|
                  |L3.44|
00002c  f64550c3          MOV      r0,#0x5dc3            ;367
000030  e0ad              B        |L3.398|
                  |L3.50|
;;;378        }
;;;379    #endif
;;;380    
;;;381    #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
;;;382        if (p_mutex->Type != OS_OBJ_TYPE_MUTEX) {               /* Make sure mutex was created                            */
000032  4966              LDR      r1,|L3.460|
000034  6830              LDR      r0,[r6,#0]
000036  4288              CMP      r0,r1
000038  d002              BEQ      |L3.64|
;;;383           *p_err = OS_ERR_OBJ_TYPE;
00003a  f64550c4          MOV      r0,#0x5dc4
;;;384            return;
00003e  e0a6              B        |L3.398|
                  |L3.64|
000040  f04f0800          MOV      r8,#0
;;;385        }
;;;386    #endif
;;;387    
;;;388        if (p_ts != (CPU_TS *)0) {
000044  b10c              CBZ      r4,|L3.74|
;;;389           *p_ts  = (CPU_TS  )0;                                /* Initialize the returned timestamp                      */
000046  f8c48000          STR      r8,[r4,#0]
                  |L3.74|
;;;390        }
;;;391    
;;;392        CPU_CRITICAL_ENTER();
00004a  f7fffffe          BL       CPU_SR_Save
00004e  4601              MOV      r1,r0
;;;393        if (p_mutex->OwnerNestingCtr == (OS_NESTING_CTR)0) {    /* Resource available?                                    */
000050  f8960025          LDRB     r0,[r6,#0x25]
;;;394            p_mutex->OwnerTCBPtr       =  OSTCBCurPtr;          /* Yes, caller may proceed                                */
000054  4b5e              LDR      r3,|L3.464|
;;;395            p_mutex->OwnerOriginalPrio =  OSTCBCurPtr->Prio;
;;;396            p_mutex->OwnerNestingCtr   = (OS_NESTING_CTR)1;
000056  2201              MOVS     r2,#1
000058  b188              CBZ      r0,|L3.126|
;;;397            if (p_ts != (CPU_TS *)0) {
;;;398               *p_ts  = p_mutex->TS;
;;;399            }
;;;400            CPU_CRITICAL_EXIT();
;;;401           *p_err = OS_ERR_NONE;
;;;402            return;
;;;403        }
;;;404    
;;;405        if (OSTCBCurPtr == p_mutex->OwnerTCBPtr) {              /* See if current task is already the owner of the mutex  */
00005a  469a              MOV      r10,r3
00005c  f8d6c020          LDR      r12,[r6,#0x20]
000060  681b              LDR      r3,[r3,#0]  ; OSTCBCurPtr
000062  459c              CMP      r12,r3
000064  d11e              BNE      |L3.164|
;;;406            p_mutex->OwnerNestingCtr++;
000066  1c40              ADDS     r0,r0,#1
000068  f8860025          STRB     r0,[r6,#0x25]
;;;407            if (p_ts != (CPU_TS *)0) {
00006c  b10c              CBZ      r4,|L3.114|
;;;408               *p_ts  = p_mutex->TS;
00006e  6ab0              LDR      r0,[r6,#0x28]
000070  6020              STR      r0,[r4,#0]
                  |L3.114|
;;;409            }
;;;410            CPU_CRITICAL_EXIT();
000072  4608              MOV      r0,r1
000074  f7fffffe          BL       CPU_SR_Restore
;;;411           *p_err = OS_ERR_MUTEX_OWNER;                         /* Indicate that current task already owns the mutex      */
000078  f2457082          MOV      r0,#0x5782
;;;412            return;
00007c  e087              B        |L3.398|
                  |L3.126|
00007e  6818              LDR      r0,[r3,#0]            ;394  ; OSTCBCurPtr
000080  6230              STR      r0,[r6,#0x20]         ;395
000082  f8900037          LDRB     r0,[r0,#0x37]         ;395
000086  f8860024          STRB     r0,[r6,#0x24]         ;395
00008a  f8862025          STRB     r2,[r6,#0x25]         ;396
00008e  b10c              CBZ      r4,|L3.148|
000090  6ab0              LDR      r0,[r6,#0x28]         ;398
000092  6020              STR      r0,[r4,#0]            ;398
                  |L3.148|
000094  4608              MOV      r0,r1                 ;400
000096  f7fffffe          BL       CPU_SR_Restore
00009a  f8a58000          STRH     r8,[r5,#0]            ;401
                  |L3.158|
;;;413        }
;;;414    
;;;415        if ((opt & OS_OPT_PEND_NON_BLOCKING) != (OS_OPT)0) {    /* Caller wants to block if not available?                */
;;;416            CPU_CRITICAL_EXIT();
;;;417           *p_err = OS_ERR_PEND_WOULD_BLOCK;                    /* No                                                     */
;;;418            return;
;;;419        } else {
;;;420            if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {    /* Can't pend when the scheduler is locked                */
;;;421                CPU_CRITICAL_EXIT();
;;;422               *p_err = OS_ERR_SCHED_LOCKED;
;;;423                return;
;;;424            }
;;;425        }
;;;426    
;;;427        OS_CRITICAL_ENTER_CPU_CRITICAL_EXIT();                  /* Lock the scheduler/re-enable interrupts                */
;;;428        p_tcb = p_mutex->OwnerTCBPtr;                           /* Point to the TCB of the Mutex owner                    */
;;;429        if (p_tcb->Prio > OSTCBCurPtr->Prio) {                  /* See if mutex owner has a lower priority than current   */
;;;430            switch (p_tcb->TaskState) {
;;;431                case OS_TASK_STATE_RDY:
;;;432                     OS_RdyListRemove(p_tcb);                   /* Remove from ready list at current priority             */
;;;433                     p_tcb->Prio = OSTCBCurPtr->Prio;           /* Raise owner's priority                                 */
;;;434                     OS_PrioInsert(p_tcb->Prio);
;;;435                     OS_RdyListInsertHead(p_tcb);               /* Insert in ready list at new priority                   */
;;;436                     break;
;;;437    
;;;438                case OS_TASK_STATE_DLY:
;;;439                case OS_TASK_STATE_DLY_SUSPENDED:
;;;440                case OS_TASK_STATE_SUSPENDED:
;;;441                     p_tcb->Prio = OSTCBCurPtr->Prio;           /* Only need to raise the owner's priority                */
;;;442                     break;
;;;443    
;;;444                case OS_TASK_STATE_PEND:                        /* Change the position of the task in the wait list       */
;;;445                case OS_TASK_STATE_PEND_TIMEOUT:
;;;446                case OS_TASK_STATE_PEND_SUSPENDED:
;;;447                case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
;;;448                     OS_PendListChangePrio(p_tcb,
;;;449                                           OSTCBCurPtr->Prio);
;;;450                     break;
;;;451    
;;;452                default:
;;;453                     OS_CRITICAL_EXIT();
;;;454                    *p_err = OS_ERR_STATE_INVALID;
;;;455                     return;
;;;456            }
;;;457        }
;;;458    
;;;459        OS_Pend(&pend_data,                                     /* Block task pending on Mutex                            */
;;;460                (OS_PEND_OBJ *)((void *)p_mutex),
;;;461                 OS_TASK_PEND_ON_MUTEX,
;;;462                 timeout);
;;;463    
;;;464        OS_CRITICAL_EXIT_NO_SCHED();
;;;465    
;;;466        OSSched();                                              /* Find the next highest priority task ready to run       */
;;;467    
;;;468        CPU_CRITICAL_ENTER();
;;;469        switch (OSTCBCurPtr->PendStatus) {
;;;470            case OS_STATUS_PEND_OK:                             /* We got the mutex                                       */
;;;471                 if (p_ts != (CPU_TS *)0) {
;;;472                    *p_ts  = OSTCBCurPtr->TS;
;;;473                 }
;;;474                *p_err = OS_ERR_NONE;
;;;475                 break;
;;;476    
;;;477            case OS_STATUS_PEND_ABORT:                          /* Indicate that we aborted                               */
;;;478                 if (p_ts != (CPU_TS *)0) {
;;;479                    *p_ts  = OSTCBCurPtr->TS;
;;;480                 }
;;;481                *p_err = OS_ERR_PEND_ABORT;
;;;482                 break;
;;;483    
;;;484            case OS_STATUS_PEND_TIMEOUT:                        /* Indicate that we didn't get mutex within timeout       */
;;;485                 if (p_ts != (CPU_TS *)0) {
;;;486                    *p_ts  = (CPU_TS  )0;
;;;487                 }
;;;488                *p_err = OS_ERR_TIMEOUT;
;;;489                 break;
;;;490    
;;;491            case OS_STATUS_PEND_DEL:                            /* Indicate that object pended on has been deleted        */
;;;492                 if (p_ts != (CPU_TS *)0) {
;;;493                    *p_ts  = OSTCBCurPtr->TS;
;;;494                 }
;;;495                *p_err = OS_ERR_OBJ_DEL;
;;;496                 break;
;;;497    
;;;498            default:
;;;499                *p_err = OS_ERR_STATUS_INVALID;
;;;500                 break;
;;;501        }
;;;502        CPU_CRITICAL_EXIT();
;;;503    }
00009e  b009              ADD      sp,sp,#0x24
0000a0  e8bd8ff0          POP      {r4-r11,pc}
                  |L3.164|
0000a4  0438              LSLS     r0,r7,#16             ;415
0000a6  d505              BPL      |L3.180|
0000a8  4608              MOV      r0,r1                 ;416
0000aa  f7fffffe          BL       CPU_SR_Restore
0000ae  f24610b0          MOV      r0,#0x61b0            ;417
0000b2  e06c              B        |L3.398|
                  |L3.180|
0000b4  4847              LDR      r0,|L3.468|
0000b6  7803              LDRB     r3,[r0,#0]            ;420  ; OSSchedLockNestingCtr
0000b8  b12b              CBZ      r3,|L3.198|
0000ba  4608              MOV      r0,r1                 ;421
0000bc  f7fffffe          BL       CPU_SR_Restore
0000c0  f6465063          MOV      r0,#0x6d63            ;422
0000c4  e063              B        |L3.398|
                  |L3.198|
0000c6  4681              MOV      r9,r0                 ;427
0000c8  7002              STRB     r2,[r0,#0]            ;427
0000ca  4608              MOV      r0,r1                 ;427
0000cc  f7fffffe          BL       CPU_SR_Restore
0000d0  6a37              LDR      r7,[r6,#0x20]         ;429
0000d2  f8da0000          LDR      r0,[r10,#0]           ;429  ; OSTCBCurPtr
0000d6  f8972037          LDRB     r2,[r7,#0x37]         ;429
0000da  f8901037          LDRB     r1,[r0,#0x37]         ;429
0000de  428a              CMP      r2,r1                 ;429
0000e0  d91e              BLS      |L3.288|
0000e2  f8970036          LDRB     r0,[r7,#0x36]         ;430
0000e6  2808              CMP      r0,#8                 ;430
0000e8  d23b              BCS      |L3.354|
0000ea  e8dff000          TBB      [pc,r0]               ;430
0000ee  0413              DCB      0x04,0x13
0000f0  16161313          DCB      0x16,0x16,0x13,0x13
0000f4  1616              DCB      0x16,0x16
0000f6  4638              MOV      r0,r7                 ;432
0000f8  f7fffffe          BL       OS_RdyListRemove
0000fc  f8da0000          LDR      r0,[r10,#0]           ;433  ; OSTCBCurPtr
000100  f8900037          LDRB     r0,[r0,#0x37]         ;433
000104  f8870037          STRB     r0,[r7,#0x37]         ;433
000108  f7fffffe          BL       OS_PrioInsert
00010c  4638              MOV      r0,r7                 ;435
00010e  f7fffffe          BL       OS_RdyListInsertHead
000112  e005              B        |L3.288|
000114  f8871037          STRB     r1,[r7,#0x37]         ;441
000118  e002              B        |L3.288|
00011a  4638              MOV      r0,r7                 ;448
00011c  f7fffffe          BL       OS_PendListChangePrio
                  |L3.288|
000120  465b              MOV      r3,r11                ;459
000122  2204              MOVS     r2,#4                 ;459
000124  4631              MOV      r1,r6                 ;459
000126  4668              MOV      r0,sp                 ;459
000128  f7fffffe          BL       OS_Pend
00012c  f7fffffe          BL       CPU_SR_Save
000130  f8992000          LDRB     r2,[r9,#0]            ;464  ; OSSchedLockNestingCtr
000134  1e52              SUBS     r2,r2,#1              ;464
000136  f8892000          STRB     r2,[r9,#0]            ;464
00013a  f7fffffe          BL       CPU_SR_Restore
00013e  f7fffffe          BL       OSSched
000142  f7fffffe          BL       CPU_SR_Save
000146  f8da1000          LDR      r1,[r10,#0]           ;469  ; OSTCBCurPtr
00014a  f8912035          LDRB     r2,[r1,#0x35]         ;469
00014e  b302              CBZ      r2,|L3.402|
000150  2a01              CMP      r2,#1                 ;469
000152  d024              BEQ      |L3.414|
000154  2a02              CMP      r2,#2                 ;469
000156  d031              BEQ      |L3.444|
000158  2a03              CMP      r2,#3                 ;469
00015a  d026              BEQ      |L3.426|
00015c  f646612e          MOV      r1,#0x6e2e            ;499
000160  e028              B        |L3.436|
                  |L3.354|
000162  f7fffffe          BL       CPU_SR_Save
000166  f8992000          LDRB     r2,[r9,#0]            ;453  ; OSSchedLockNestingCtr
00016a  1e52              SUBS     r2,r2,#1              ;453
00016c  f01202ff          ANDS     r2,r2,#0xff           ;453
000170  f8892000          STRB     r2,[r9,#0]            ;453
000174  d107              BNE      |L3.390|
000176  4918              LDR      r1,|L3.472|
000178  8809              LDRH     r1,[r1,#0]            ;453  ; OSIntQNbrEntries
00017a  b121              CBZ      r1,|L3.390|
00017c  f7fffffe          BL       CPU_SR_Restore
000180  f7fffffe          BL       OS_Sched0
000184  e001              B        |L3.394|
                  |L3.390|
000186  f7fffffe          BL       CPU_SR_Restore
                  |L3.394|
00018a  f646602d          MOV      r0,#0x6e2d            ;454
                  |L3.398|
00018e  8028              STRH     r0,[r5,#0]            ;454
000190  e785              B        |L3.158|
                  |L3.402|
000192  b10c              CBZ      r4,|L3.408|
000194  6c09              LDR      r1,[r1,#0x40]         ;472
000196  6021              STR      r1,[r4,#0]            ;472
                  |L3.408|
000198  f8a58000          STRH     r8,[r5,#0]            ;474
00019c  e00b              B        |L3.438|
                  |L3.414|
00019e  b10c              CBZ      r4,|L3.420|
0001a0  6c09              LDR      r1,[r1,#0x40]         ;479
0001a2  6021              STR      r1,[r4,#0]            ;479
                  |L3.420|
0001a4  f24611a9          MOV      r1,#0x61a9            ;481
0001a8  e004              B        |L3.436|
                  |L3.426|
0001aa  b10c              CBZ      r4,|L3.432|
0001ac  f8c48000          STR      r8,[r4,#0]            ;486
                  |L3.432|
0001b0  f24721d9          MOV      r1,#0x72d9            ;488
                  |L3.436|
0001b4  8029              STRH     r1,[r5,#0]            ;481
                  |L3.438|
0001b6  f7fffffe          BL       CPU_SR_Restore
0001ba  e770              B        |L3.158|
                  |L3.444|
0001bc  b10c              CBZ      r4,|L3.450|
0001be  6c09              LDR      r1,[r1,#0x40]         ;493
0001c0  6021              STR      r1,[r4,#0]            ;493
                  |L3.450|
0001c2  f64551c2          MOV      r1,#0x5dc2            ;495
0001c6  e7f5              B        |L3.436|
;;;504    
                          ENDP

                  |L3.456|
                          DCD      OSIntNestingCtr
                  |L3.460|
                          DCD      0x5854554d
                  |L3.464|
                          DCD      OSTCBCurPtr
                  |L3.468|
                          DCD      OSSchedLockNestingCtr
                  |L3.472|
                          DCD      OSIntQNbrEntries

                          AREA ||i.OSMutexPendAbort||, CODE, READONLY, ALIGN=2

                  OSMutexPendAbort PROC
;;;537    #if OS_CFG_MUTEX_PEND_ABORT_EN > 0u
;;;538    OS_OBJ_QTY  OSMutexPendAbort (OS_MUTEX  *p_mutex,
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;539                                  OS_OPT     opt,
;;;540                                  OS_ERR    *p_err)
;;;541    {
000004  4604              MOV      r4,r0
;;;542        OS_PEND_LIST  *p_pend_list;
;;;543        OS_TCB        *p_tcb;
;;;544        CPU_TS         ts;
;;;545        OS_OBJ_QTY     nbr_tasks;
;;;546        CPU_SR_ALLOC();
;;;547    
;;;548    
;;;549    
;;;550    #ifdef OS_SAFETY_CRITICAL
;;;551        if (p_err == (OS_ERR *)0) {
;;;552            OS_SAFETY_CRITICAL_EXCEPTION();
;;;553            return ((OS_OBJ_QTY)0u);
;;;554        }
;;;555    #endif
;;;556    
;;;557    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;558        if (OSIntNestingCtr > (OS_NESTING_CTR)0u) {             /* Not allowed to Pend Abort from an ISR                  */
000006  4830              LDR      r0,|L4.200|
000008  4688              MOV      r8,r1                 ;541
00000a  4615              MOV      r5,r2                 ;541
00000c  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
00000e  b110              CBZ      r0,|L4.22|
;;;559           *p_err =  OS_ERR_PEND_ABORT_ISR;
000010  f24610aa          MOV      r0,#0x61aa
;;;560            return ((OS_OBJ_QTY)0u);
000014  e011              B        |L4.58|
                  |L4.22|
;;;561        }
;;;562    #endif
;;;563    
;;;564    #if OS_CFG_ARG_CHK_EN > 0u
;;;565        if (p_mutex == (OS_MUTEX *)0) {                         /* Validate 'p_mutex'                                     */
000016  b174              CBZ      r4,|L4.54|
;;;566           *p_err =  OS_ERR_OBJ_PTR_NULL;
;;;567            return ((OS_OBJ_QTY)0u);
;;;568        }
;;;569        switch (opt) {                                          /* Validate 'opt'                                         */
000018  0008              MOVS     r0,r1
00001a  f44f7a80          MOV      r10,#0x100
00001e  d00e              BEQ      |L4.62|
000020  4550              CMP      r0,r10
000022  d00c              BEQ      |L4.62|
000024  f5b04f00          CMP      r0,#0x8000
000028  d009              BEQ      |L4.62|
00002a  f5b14f01          CMP      r1,#0x8100
00002e  d006              BEQ      |L4.62|
;;;570            case OS_OPT_PEND_ABORT_1:
;;;571            case OS_OPT_PEND_ABORT_ALL:
;;;572            case OS_OPT_PEND_ABORT_1   | OS_OPT_POST_NO_SCHED:
;;;573            case OS_OPT_PEND_ABORT_ALL | OS_OPT_POST_NO_SCHED:
;;;574                 break;
;;;575    
;;;576            default:
;;;577                *p_err =  OS_ERR_OPT_INVALID;
000030  f6456025          MOV      r0,#0x5e25
;;;578                 return ((OS_OBJ_QTY)0u);
000034  e001              B        |L4.58|
                  |L4.54|
000036  f64550c3          MOV      r0,#0x5dc3            ;566
                  |L4.58|
00003a  8010              STRH     r0,[r2,#0]            ;559
00003c  e022              B        |L4.132|
                  |L4.62|
;;;579        }
;;;580    #endif
;;;581    
;;;582    #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
;;;583        if (p_mutex->Type != OS_OBJ_TYPE_MUTEX) {               /* Make sure mutex was created                            */
00003e  4923              LDR      r1,|L4.204|
000040  6820              LDR      r0,[r4,#0]
000042  4288              CMP      r0,r1
000044  d002              BEQ      |L4.76|
;;;584           *p_err =  OS_ERR_OBJ_TYPE;
000046  f64550c4          MOV      r0,#0x5dc4
;;;585            return ((OS_OBJ_QTY)0u);
00004a  e7f6              B        |L4.58|
                  |L4.76|
;;;586        }
;;;587    #endif
;;;588    
;;;589        CPU_CRITICAL_ENTER();
00004c  f7fffffe          BL       CPU_SR_Save
000050  4601              MOV      r1,r0
;;;590        p_pend_list = &p_mutex->PendList;
;;;591        if (p_pend_list->NbrEntries == (OS_OBJ_QTY)0u) {        /* Any task waiting on mutex?                             */
000052  8a20              LDRH     r0,[r4,#0x10]
000054  f1040708          ADD      r7,r4,#8              ;590
000058  b170              CBZ      r0,|L4.120|
;;;592            CPU_CRITICAL_EXIT();                                /* No                                                     */
;;;593           *p_err =  OS_ERR_PEND_ABORT_NONE;
;;;594            return ((OS_OBJ_QTY)0u);
;;;595        }
;;;596    
;;;597        OS_CRITICAL_ENTER_CPU_CRITICAL_EXIT();
00005a  f8df9074          LDR      r9,|L4.208|
00005e  4608              MOV      r0,r1
000060  f8992000          LDRB     r2,[r9,#0]  ; OSSchedLockNestingCtr
000064  1c52              ADDS     r2,r2,#1
000066  f8892000          STRB     r2,[r9,#0]
00006a  f7fffffe          BL       CPU_SR_Restore
;;;598        nbr_tasks = 0u;
00006e  2600              MOVS     r6,#0
;;;599        ts        = OS_TS_GET();                                /* Get local time stamp so all tasks get the same time    */
000070  f7fffffe          BL       CPU_TS_TmrRd
000074  4683              MOV      r11,r0
;;;600        while (p_pend_list->NbrEntries > (OS_OBJ_QTY)0u) {
000076  e012              B        |L4.158|
                  |L4.120|
000078  4608              MOV      r0,r1                 ;592
00007a  f7fffffe          BL       CPU_SR_Restore
00007e  f24610ab          MOV      r0,#0x61ab            ;593
000082  8028              STRH     r0,[r5,#0]            ;593
                  |L4.132|
000084  2000              MOVS     r0,#0                 ;594
                  |L4.134|
;;;601            p_tcb = p_pend_list->HeadPtr->TCBPtr;
;;;602            OS_PendAbort((OS_PEND_OBJ *)((void *)p_mutex),
;;;603                         p_tcb,
;;;604                         ts);
;;;605            nbr_tasks++;
;;;606            if (opt != OS_OPT_PEND_ABORT_ALL) {                 /* Pend abort all tasks waiting?                          */
;;;607                break;                                          /* No                                                     */
;;;608            }
;;;609        }
;;;610        OS_CRITICAL_EXIT_NO_SCHED();
;;;611    
;;;612        if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0u) {
;;;613            OSSched();                                          /* Run the scheduler                                      */
;;;614        }
;;;615    
;;;616       *p_err = OS_ERR_NONE;
;;;617        return (nbr_tasks);
;;;618    }
000086  e8bd9ff0          POP      {r4-r12,pc}
                  |L4.138|
00008a  6838              LDR      r0,[r7,#0]            ;601
00008c  465a              MOV      r2,r11                ;602
00008e  6881              LDR      r1,[r0,#8]            ;602
000090  4620              MOV      r0,r4                 ;602
000092  f7fffffe          BL       OS_PendAbort
000096  1c76              ADDS     r6,r6,#1              ;605
000098  b2b6              UXTH     r6,r6                 ;605
00009a  45d0              CMP      r8,r10                ;606
00009c  d102              BNE      |L4.164|
                  |L4.158|
00009e  8938              LDRH     r0,[r7,#8]            ;600
0000a0  2800              CMP      r0,#0                 ;600
0000a2  d1f2              BNE      |L4.138|
                  |L4.164|
0000a4  f7fffffe          BL       CPU_SR_Save
0000a8  f8992000          LDRB     r2,[r9,#0]            ;610  ; OSSchedLockNestingCtr
0000ac  1e52              SUBS     r2,r2,#1              ;610
0000ae  f8892000          STRB     r2,[r9,#0]            ;610
0000b2  f7fffffe          BL       CPU_SR_Restore
0000b6  ea5f4008          LSLS     r0,r8,#16             ;612
0000ba  d401              BMI      |L4.192|
0000bc  f7fffffe          BL       OSSched
                  |L4.192|
0000c0  2000              MOVS     r0,#0                 ;616
0000c2  8028              STRH     r0,[r5,#0]            ;616
0000c4  4630              MOV      r0,r6                 ;617
0000c6  e7de              B        |L4.134|
;;;619    #endif
                          ENDP

                  |L4.200|
                          DCD      OSIntNestingCtr
                  |L4.204|
                          DCD      0x5854554d
                  |L4.208|
                          DCD      OSSchedLockNestingCtr

                          AREA ||i.OSMutexPost||, CODE, READONLY, ALIGN=2

                  OSMutexPost PROC
;;;647    
;;;648    void  OSMutexPost (OS_MUTEX  *p_mutex,
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;649                       OS_OPT     opt,
;;;650                       OS_ERR    *p_err)
;;;651    {
000004  4604              MOV      r4,r0
;;;652        OS_PEND_LIST  *p_pend_list;
;;;653        OS_TCB        *p_tcb;
;;;654        CPU_TS         ts;
;;;655        CPU_SR_ALLOC();
;;;656    
;;;657    
;;;658    
;;;659    #ifdef OS_SAFETY_CRITICAL
;;;660        if (p_err == (OS_ERR *)0) {
;;;661            OS_SAFETY_CRITICAL_EXCEPTION();
;;;662            return;
;;;663        }
;;;664    #endif
;;;665    
;;;666    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;667        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
000006  485b              LDR      r0,|L5.372|
000008  468a              MOV      r10,r1                ;651
00000a  4615              MOV      r5,r2                 ;651
00000c  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
00000e  b110              CBZ      r0,|L5.22|
;;;668           *p_err = OS_ERR_POST_ISR;
000010  f246200e          MOV      r0,#0x620e
;;;669            return;
000014  e010              B        |L5.56|
                  |L5.22|
;;;670        }
;;;671    #endif
;;;672    
;;;673    #if OS_CFG_ARG_CHK_EN > 0u
;;;674        if (p_mutex == (OS_MUTEX *)0) {                         /* Validate 'p_mutex'                                     */
000016  b134              CBZ      r4,|L5.38|
;;;675           *p_err = OS_ERR_OBJ_PTR_NULL;
;;;676            return;
;;;677        }
;;;678        switch (opt) {                                          /* Validate 'opt'                                         */
000018  b141              CBZ      r1,|L5.44|
00001a  f5b14f00          CMP      r1,#0x8000
00001e  d005              BEQ      |L5.44|
;;;679            case OS_OPT_POST_NONE:
;;;680            case OS_OPT_POST_NO_SCHED:
;;;681                 break;
;;;682    
;;;683            default:
;;;684                *p_err =  OS_ERR_OPT_INVALID;
000020  f6456025          MOV      r0,#0x5e25
;;;685                 return;
000024  e008              B        |L5.56|
                  |L5.38|
000026  f64550c3          MOV      r0,#0x5dc3            ;675
00002a  e005              B        |L5.56|
                  |L5.44|
;;;686        }
;;;687    #endif
;;;688    
;;;689    #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
;;;690        if (p_mutex->Type != OS_OBJ_TYPE_MUTEX) {               /* Make sure mutex was created                            */
00002c  4952              LDR      r1,|L5.376|
00002e  6820              LDR      r0,[r4,#0]
000030  4288              CMP      r0,r1
000032  d004              BEQ      |L5.62|
;;;691           *p_err = OS_ERR_OBJ_TYPE;
000034  f64550c4          MOV      r0,#0x5dc4
                  |L5.56|
000038  8010              STRH     r0,[r2,#0]
                  |L5.58|
;;;692            return;
;;;693        }
;;;694    #endif
;;;695    
;;;696        CPU_CRITICAL_ENTER();
;;;697        if (OSTCBCurPtr != p_mutex->OwnerTCBPtr) {              /* Make sure the mutex owner is releasing the mutex       */
;;;698            CPU_CRITICAL_EXIT();
;;;699           *p_err = OS_ERR_MUTEX_NOT_OWNER;
;;;700            return;
;;;701        }
;;;702    
;;;703        OS_CRITICAL_ENTER_CPU_CRITICAL_EXIT();
;;;704        ts          = OS_TS_GET();                              /* Get timestamp                                          */
;;;705        p_mutex->TS = ts;
;;;706        p_mutex->OwnerNestingCtr--;                             /* Decrement owner's nesting counter                      */
;;;707        if (p_mutex->OwnerNestingCtr > (OS_NESTING_CTR)0) {     /* Are we done with all nestings?                         */
;;;708            OS_CRITICAL_EXIT();                                 /* No                                                     */
;;;709           *p_err = OS_ERR_MUTEX_NESTING;
;;;710            return;
;;;711        }
;;;712    
;;;713        p_pend_list = &p_mutex->PendList;
;;;714        if (p_pend_list->NbrEntries == (OS_OBJ_QTY)0) {         /* Any task waiting on mutex?                             */
;;;715            p_mutex->OwnerTCBPtr     = (OS_TCB       *)0;       /* No                                                     */
;;;716            p_mutex->OwnerNestingCtr = (OS_NESTING_CTR)0;
;;;717            OS_CRITICAL_EXIT();
;;;718           *p_err = OS_ERR_NONE;
;;;719            return;
;;;720        }
;;;721                                                                /* Yes                                                    */
;;;722        if (OSTCBCurPtr->Prio != p_mutex->OwnerOriginalPrio) {
;;;723            OS_RdyListRemove(OSTCBCurPtr);
;;;724            OSTCBCurPtr->Prio = p_mutex->OwnerOriginalPrio;     /* Lower owner's priority back to its original one        */
;;;725            OS_PrioInsert(OSTCBCurPtr->Prio);
;;;726            OS_RdyListInsertTail(OSTCBCurPtr);                  /* Insert owner in ready list at new priority             */
;;;727            OSPrioCur         = OSTCBCurPtr->Prio;
;;;728        }
;;;729                                                                /* Get TCB from head of pend list                         */
;;;730        p_tcb                      = p_pend_list->HeadPtr->TCBPtr;
;;;731        p_mutex->OwnerTCBPtr       = p_tcb;                     /* Give mutex to new owner                                */
;;;732        p_mutex->OwnerOriginalPrio = p_tcb->Prio;
;;;733        p_mutex->OwnerNestingCtr   = (OS_NESTING_CTR)1;
;;;734                                                                /* Post to mutex                                          */
;;;735        OS_Post((OS_PEND_OBJ *)((void *)p_mutex),
;;;736                (OS_TCB      *)p_tcb,
;;;737                (void        *)0,
;;;738                (OS_MSG_SIZE  )0,
;;;739                (CPU_TS       )ts);
;;;740    
;;;741        OS_CRITICAL_EXIT_NO_SCHED();
;;;742    
;;;743        if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0) {
;;;744            OSSched();                                          /* Run the scheduler                                      */
;;;745        }
;;;746    
;;;747       *p_err = OS_ERR_NONE;
;;;748    }
00003a  e8bd8ff8          POP      {r3-r11,pc}
                  |L5.62|
00003e  f7fffffe          BL       CPU_SR_Save
000042  f8df9138          LDR      r9,|L5.380|
000046  4601              MOV      r1,r0                 ;696
000048  6a22              LDR      r2,[r4,#0x20]         ;697
00004a  f8d90000          LDR      r0,[r9,#0]            ;697  ; OSTCBCurPtr
00004e  4282              CMP      r2,r0                 ;697
000050  d005              BEQ      |L5.94|
000052  4608              MOV      r0,r1                 ;698
000054  f7fffffe          BL       CPU_SR_Restore
000058  f2457081          MOV      r0,#0x5781            ;699
00005c  e06e              B        |L5.316|
                  |L5.94|
00005e  f8df8120          LDR      r8,|L5.384|
000062  4608              MOV      r0,r1                 ;703
000064  f8982000          LDRB     r2,[r8,#0]            ;703  ; OSSchedLockNestingCtr
000068  1c52              ADDS     r2,r2,#1              ;703
00006a  f8882000          STRB     r2,[r8,#0]            ;703
00006e  f7fffffe          BL       CPU_SR_Restore
000072  f7fffffe          BL       CPU_TS_TmrRd
000076  4606              MOV      r6,r0                 ;704
000078  62a0              STR      r0,[r4,#0x28]         ;706
00007a  f8940025          LDRB     r0,[r4,#0x25]         ;706
00007e  f8dfb104          LDR      r11,|L5.388|
000082  1e40              SUBS     r0,r0,#1              ;706
000084  f01000ff          ANDS     r0,r0,#0xff           ;706
000088  f8840025          STRB     r0,[r4,#0x25]         ;706
00008c  d016              BEQ      |L5.188|
00008e  f7fffffe          BL       CPU_SR_Save
000092  f8982000          LDRB     r2,[r8,#0]            ;708  ; OSSchedLockNestingCtr
000096  1e52              SUBS     r2,r2,#1              ;708
000098  f01202ff          ANDS     r2,r2,#0xff           ;708
00009c  f8882000          STRB     r2,[r8,#0]            ;708
0000a0  d107              BNE      |L5.178|
0000a2  f8bb1000          LDRH     r1,[r11,#0]           ;708  ; OSIntQNbrEntries
0000a6  b121              CBZ      r1,|L5.178|
0000a8  f7fffffe          BL       CPU_SR_Restore
0000ac  f7fffffe          BL       OS_Sched0
0000b0  e001              B        |L5.182|
                  |L5.178|
0000b2  f7fffffe          BL       CPU_SR_Restore
                  |L5.182|
0000b6  f2457083          MOV      r0,#0x5783            ;709
0000ba  e03f              B        |L5.316|
                  |L5.188|
0000bc  8a20              LDRH     r0,[r4,#0x10]         ;714
0000be  f1040708          ADD      r7,r4,#8              ;713
0000c2  b3e8              CBZ      r0,|L5.320|
0000c4  f8d91000          LDR      r1,[r9,#0]            ;722  ; OSTCBCurPtr
0000c8  f8943024          LDRB     r3,[r4,#0x24]         ;722
0000cc  f8912037          LDRB     r2,[r1,#0x37]         ;722
0000d0  429a              CMP      r2,r3                 ;722
0000d2  d014              BEQ      |L5.254|
0000d4  4608              MOV      r0,r1                 ;722
0000d6  f7fffffe          BL       OS_RdyListRemove
0000da  f8d91000          LDR      r1,[r9,#0]            ;724  ; OSTCBCurPtr
0000de  f8940024          LDRB     r0,[r4,#0x24]         ;724
0000e2  f8810037          STRB     r0,[r1,#0x37]         ;724
0000e6  f7fffffe          BL       OS_PrioInsert
0000ea  f8d90000          LDR      r0,[r9,#0]            ;726  ; OSTCBCurPtr
0000ee  f7fffffe          BL       OS_RdyListInsertTail
0000f2  f8d90000          LDR      r0,[r9,#0]            ;727  ; OSTCBCurPtr
0000f6  4924              LDR      r1,|L5.392|
0000f8  f8900037          LDRB     r0,[r0,#0x37]         ;727
0000fc  7008              STRB     r0,[r1,#0]            ;727
                  |L5.254|
0000fe  6838              LDR      r0,[r7,#0]            ;730
000100  2300              MOVS     r3,#0                 ;735
000102  461a              MOV      r2,r3                 ;735
000104  6881              LDR      r1,[r0,#8]            ;731
000106  6221              STR      r1,[r4,#0x20]         ;732
000108  f8910037          LDRB     r0,[r1,#0x37]         ;732
00010c  f8840024          STRB     r0,[r4,#0x24]         ;732
000110  2001              MOVS     r0,#1                 ;733
000112  f8840025          STRB     r0,[r4,#0x25]         ;733
000116  4620              MOV      r0,r4                 ;735
000118  9600              STR      r6,[sp,#0]            ;735
00011a  f7fffffe          BL       OS_Post
00011e  f7fffffe          BL       CPU_SR_Save
000122  f8982000          LDRB     r2,[r8,#0]            ;741  ; OSSchedLockNestingCtr
000126  1e52              SUBS     r2,r2,#1              ;741
000128  f8882000          STRB     r2,[r8,#0]            ;741
00012c  f7fffffe          BL       CPU_SR_Restore
000130  ea5f400a          LSLS     r0,r10,#16            ;743
000134  d401              BMI      |L5.314|
000136  f7fffffe          BL       OSSched
                  |L5.314|
00013a  2000              MOVS     r0,#0                 ;747
                  |L5.316|
00013c  8028              STRH     r0,[r5,#0]            ;747
00013e  e77c              B        |L5.58|
                  |L5.320|
000140  e7ff              B        |L5.322|
                  |L5.322|
000142  2600              MOVS     r6,#0                 ;715
000144  6226              STR      r6,[r4,#0x20]         ;717
000146  f7fffffe          BL       CPU_SR_Save
00014a  f8982000          LDRB     r2,[r8,#0]            ;717  ; OSSchedLockNestingCtr
00014e  1e52              SUBS     r2,r2,#1              ;717
000150  f01202ff          ANDS     r2,r2,#0xff           ;717
000154  f8882000          STRB     r2,[r8,#0]            ;717
000158  d107              BNE      |L5.362|
00015a  f8bb1000          LDRH     r1,[r11,#0]           ;717  ; OSIntQNbrEntries
00015e  b121              CBZ      r1,|L5.362|
000160  f7fffffe          BL       CPU_SR_Restore
000164  f7fffffe          BL       OS_Sched0
000168  e001              B        |L5.366|
                  |L5.362|
00016a  f7fffffe          BL       CPU_SR_Restore
                  |L5.366|
00016e  802e              STRH     r6,[r5,#0]            ;718
000170  e763              B        |L5.58|
;;;749    
                          ENDP

000172  0000              DCW      0x0000
                  |L5.372|
                          DCD      OSIntNestingCtr
                  |L5.376|
                          DCD      0x5854554d
                  |L5.380|
                          DCD      OSTCBCurPtr
                  |L5.384|
                          DCD      OSSchedLockNestingCtr
                  |L5.388|
                          DCD      OSIntQNbrEntries
                  |L5.392|
                          DCD      OSPrioCur

                          AREA ||i.OS_MutexClr||, CODE, READONLY, ALIGN=2

                  OS_MutexClr PROC
;;;766    
;;;767    void  OS_MutexClr (OS_MUTEX  *p_mutex)
000000  4907              LDR      r1,|L6.32|
;;;768    {
;;;769        p_mutex->Type              =  OS_OBJ_TYPE_NONE;         /* Mark the data structure as a NONE                      */
;;;770        p_mutex->NamePtr           = (CPU_CHAR     *)((void *)"?MUTEX");
000002  6001              STR      r1,[r0,#0]
000004  4907              LDR      r1,|L6.36|
;;;771        p_mutex->OwnerTCBPtr       = (OS_TCB       *)0;
000006  6041              STR      r1,[r0,#4]
000008  2100              MOVS     r1,#0
;;;772        p_mutex->OwnerNestingCtr   = (OS_NESTING_CTR)0;
00000a  6201              STR      r1,[r0,#0x20]
00000c  f8801025          STRB     r1,[r0,#0x25]
;;;773        p_mutex->TS                = (CPU_TS        )0;
;;;774        p_mutex->OwnerOriginalPrio =  OS_CFG_PRIO_MAX;
000010  6281              STR      r1,[r0,#0x28]
000012  2140              MOVS     r1,#0x40
000014  f8801024          STRB     r1,[r0,#0x24]
;;;775        OS_PendListInit(&p_mutex->PendList);                    /* Initialize the waiting list                            */
000018  3008              ADDS     r0,r0,#8
00001a  f7ffbffe          B.W      OS_PendListInit
;;;776    }
;;;777    
                          ENDP

00001e  0000              DCW      0x0000
                  |L6.32|
                          DCD      0x454e4f4e
                  |L6.36|
                          DCD      ||.constdata||

                          AREA ||i.OS_MutexDbgListAdd||, CODE, READONLY, ALIGN=2

                  OS_MutexDbgListAdd PROC
;;;794    #if OS_CFG_DBG_EN > 0u
;;;795    void  OS_MutexDbgListAdd (OS_MUTEX  *p_mutex)
000000  2200              MOVS     r2,#0
;;;796    {
;;;797        p_mutex->DbgNamePtr               = (CPU_CHAR *)((void *)" ");
;;;798        p_mutex->DbgPrevPtr               = (OS_MUTEX *)0;
;;;799        if (OSMutexDbgListPtr == (OS_MUTEX *)0) {
000002  4b07              LDR      r3,|L7.32|
000004  a105              ADR      r1,|L7.28|
000006  6142              STR      r2,[r0,#0x14]
000008  61c1              STR      r1,[r0,#0x1c]
00000a  6819              LDR      r1,[r3,#0]            ;796  ; OSMutexDbgListPtr
00000c  b119              CBZ      r1,|L7.22|
;;;800            p_mutex->DbgNextPtr           = (OS_MUTEX *)0;
;;;801        } else {
;;;802            p_mutex->DbgNextPtr           =  OSMutexDbgListPtr;
;;;803            OSMutexDbgListPtr->DbgPrevPtr =  p_mutex;
00000e  6181              STR      r1,[r0,#0x18]
000010  6148              STR      r0,[r1,#0x14]
                  |L7.18|
;;;804        }
;;;805        OSMutexDbgListPtr                 =  p_mutex;
;;;806    }
000012  6018              STR      r0,[r3,#0]  ; OSMutexDbgListPtr
000014  4770              BX       lr
                  |L7.22|
000016  6182              STR      r2,[r0,#0x18]         ;800
000018  e7fb              B        |L7.18|
;;;807    
                          ENDP

00001a  0000              DCW      0x0000
                  |L7.28|
00001c  2000              DCB      " ",0
00001e  00                DCB      0
00001f  00                DCB      0
                  |L7.32|
                          DCD      OSMutexDbgListPtr

                          AREA ||i.OS_MutexDbgListRemove||, CODE, READONLY, ALIGN=2

                  OS_MutexDbgListRemove PROC
;;;809    
;;;810    void  OS_MutexDbgListRemove (OS_MUTEX  *p_mutex)
000000  e9d02105          LDRD     r2,r1,[r0,#0x14]
;;;811    {
000004  2300              MOVS     r3,#0
000006  b12a              CBZ      r2,|L8.20|
;;;812        OS_MUTEX  *p_mutex_next;
;;;813        OS_MUTEX  *p_mutex_prev;
;;;814    
;;;815    
;;;816        p_mutex_prev = p_mutex->DbgPrevPtr;
;;;817        p_mutex_next = p_mutex->DbgNextPtr;
;;;818    
;;;819        if (p_mutex_prev == (OS_MUTEX *)0) {
;;;820            OSMutexDbgListPtr = p_mutex_next;
;;;821            if (p_mutex_next != (OS_MUTEX *)0) {
;;;822                p_mutex_next->DbgPrevPtr = (OS_MUTEX *)0;
;;;823            }
;;;824            p_mutex->DbgNextPtr = (OS_MUTEX *)0;
;;;825    
;;;826        } else if (p_mutex_next == (OS_MUTEX *)0) {
000008  b151              CBZ      r1,|L8.32|
;;;827            p_mutex_prev->DbgNextPtr = (OS_MUTEX *)0;
;;;828            p_mutex->DbgPrevPtr      = (OS_MUTEX *)0;
;;;829    
;;;830        } else {
;;;831            p_mutex_prev->DbgNextPtr =  p_mutex_next;
;;;832            p_mutex_next->DbgPrevPtr =  p_mutex_prev;
00000a  6191              STR      r1,[r2,#0x18]
;;;833            p_mutex->DbgNextPtr      = (OS_MUTEX *)0;
00000c  614a              STR      r2,[r1,#0x14]
00000e  6183              STR      r3,[r0,#0x18]
                  |L8.16|
;;;834            p_mutex->DbgPrevPtr      = (OS_MUTEX *)0;
000010  6143              STR      r3,[r0,#0x14]
;;;835        }
;;;836    }
000012  4770              BX       lr
                  |L8.20|
000014  4a03              LDR      r2,|L8.36|
000016  6011              STR      r1,[r2,#0]            ;821  ; OSMutexDbgListPtr
000018  b101              CBZ      r1,|L8.28|
00001a  614b              STR      r3,[r1,#0x14]         ;822
                  |L8.28|
00001c  6183              STR      r3,[r0,#0x18]         ;824
00001e  4770              BX       lr
                  |L8.32|
000020  6193              STR      r3,[r2,#0x18]         ;828
000022  e7f5              B        |L8.16|
;;;837    #endif
                          ENDP

                  |L8.36|
                          DCD      OSMutexDbgListPtr

                          AREA ||i.OS_MutexInit||, CODE, READONLY, ALIGN=2

                  OS_MutexInit PROC
;;;856    
;;;857    void  OS_MutexInit (OS_ERR  *p_err)
000000  4a03              LDR      r2,|L9.16|
;;;858    {
;;;859    #ifdef OS_SAFETY_CRITICAL
;;;860        if (p_err == (OS_ERR *)0) {
;;;861            OS_SAFETY_CRITICAL_EXCEPTION();
;;;862            return;
;;;863        }
;;;864    #endif
;;;865    
;;;866    #if OS_CFG_DBG_EN > 0u
;;;867        OSMutexDbgListPtr = (OS_MUTEX *)0;
000002  2100              MOVS     r1,#0
;;;868    #endif
;;;869    
;;;870        OSMutexQty        = (OS_OBJ_QTY)0;
000004  6011              STR      r1,[r2,#0]  ; OSMutexDbgListPtr
000006  4a03              LDR      r2,|L9.20|
000008  8011              STRH     r1,[r2,#0]
;;;871       *p_err             =  OS_ERR_NONE;
00000a  8001              STRH     r1,[r0,#0]
;;;872    }
00000c  4770              BX       lr
;;;873    
                          ENDP

00000e  0000              DCW      0x0000
                  |L9.16|
                          DCD      OSMutexDbgListPtr
                  |L9.20|
                          DCD      OSMutexQty

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

000000  3f4d5554          DCB      0x3f,0x4d,0x55,0x54
000004  455800            DCB      0x45,0x58,0x00
