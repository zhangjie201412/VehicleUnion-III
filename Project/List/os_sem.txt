; generated by ARM C/C++ Compiler, 5.02 [Build 28]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\OBJ\os_sem.o --asm_dir=.\List\ --list_dir=.\List\ --depend=..\OBJ\os_sem.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\BSP -I..\CORE -I..\STM32F10x_FWLib\inc -I..\USER -I..\UCOSIII\uC-CPU -I..\UCOSIII\uC-CPU\ARM-Cortex-M3\RealView -I..\UCOSIII\uC-LIB -I..\UCOSIII\uC-LIB\Ports\ARM-Cortex-M3\RealView -I..\UCOSIII\uCOS-III -I..\UCOSIII\uCOS-III\Ports -I..\UCOSIII\uCOS-III\Ports\ARM-Cortex-M3\Generic\RealView -I..\UCOSIII\uCOS-III\Source -I..\UCOSIII\UCOS_BSP -I..\UCOSIII\uCOS_CONFIG -I..\UCOSIII-Task -I..\SYSTEM -I..\BSP\inc -I..\PAL -I..\PAL\vehicles -ID:\Keil_v4\ARM\RV31\INC -ID:\Keil_v4\ARM\CMSIS\Include -ID:\Keil_v4\ARM\Inc\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=..\OBJ\os_sem.crf ..\UCOSIII\uCOS-III\Source\os_sem.c]
                          THUMB

                          AREA ||i.OSSemCreate||, CODE, READONLY, ALIGN=2

                  OSSemCreate PROC
;;;72     
;;;73     void  OSSemCreate (OS_SEM      *p_sem,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;74                        CPU_CHAR    *p_name,
;;;75                        OS_SEM_CTR   cnt,
;;;76                        OS_ERR      *p_err)
;;;77     {
000004  4604              MOV      r4,r0
;;;78         CPU_SR_ALLOC();
;;;79     
;;;80     
;;;81     
;;;82     #ifdef OS_SAFETY_CRITICAL
;;;83         if (p_err == (OS_ERR *)0) {
;;;84             OS_SAFETY_CRITICAL_EXCEPTION();
;;;85             return;
;;;86         }
;;;87     #endif
;;;88     
;;;89     #ifdef OS_SAFETY_CRITICAL_IEC61508
;;;90         if (OSSafetyCriticalStartFlag == DEF_TRUE) {
;;;91            *p_err = OS_ERR_ILLEGAL_CREATE_RUN_TIME;
;;;92             return;
;;;93         }
;;;94     #endif
;;;95     
;;;96     #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;97         if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to be called from an ISR                   */
000006  4818              LDR      r0,|L1.104|
000008  4617              MOV      r7,r2                 ;77
00000a  4688              MOV      r8,r1                 ;77
00000c  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
00000e  461d              MOV      r5,r3                 ;77
000010  b110              CBZ      r0,|L1.24|
;;;98            *p_err = OS_ERR_CREATE_ISR;
000012  f64260e1          MOV      r0,#0x2ee1
;;;99             return;
000016  e025              B        |L1.100|
                  |L1.24|
;;;100        }
;;;101    #endif
;;;102    
;;;103    #if OS_CFG_ARG_CHK_EN > 0u
;;;104        if (p_sem == (OS_SEM *)0) {                             /* Validate 'p_sem'                                       */
000018  b314              CBZ      r4,|L1.96|
;;;105           *p_err = OS_ERR_OBJ_PTR_NULL;
;;;106            return;
;;;107        }
;;;108    #endif
;;;109    
;;;110        OS_CRITICAL_ENTER();
00001a  f7fffffe          BL       CPU_SR_Save
00001e  4e13              LDR      r6,|L1.108|
000020  7831              LDRB     r1,[r6,#0]  ; OSSchedLockNestingCtr
000022  1c49              ADDS     r1,r1,#1
000024  7031              STRB     r1,[r6,#0]
000026  f7fffffe          BL       CPU_SR_Restore
;;;111        p_sem->Type    = OS_OBJ_TYPE_SEM;                       /* Mark the data structure as a semaphore                 */
;;;112        p_sem->Ctr     = cnt;                                   /* Set semaphore value                                    */
;;;113        p_sem->TS      = (CPU_TS)0;
00002a  6227              STR      r7,[r4,#0x20]
00002c  2700              MOVS     r7,#0
00002e  4810              LDR      r0,|L1.112|
000030  6267              STR      r7,[r4,#0x24]
000032  e9c40800          STRD     r0,r8,[r4,#0]
;;;114        p_sem->NamePtr = p_name;                                /* Save the name of the semaphore                         */
;;;115        OS_PendListInit(&p_sem->PendList);                      /* Initialize the waiting list                            */
000036  f1040008          ADD      r0,r4,#8
00003a  f7fffffe          BL       OS_PendListInit
;;;116    
;;;117    #if OS_CFG_DBG_EN > 0u
;;;118        OS_SemDbgListAdd(p_sem);
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       OS_SemDbgListAdd
;;;119    #endif
;;;120        OSSemQty++;
000044  490b              LDR      r1,|L1.116|
000046  8808              LDRH     r0,[r1,#0]  ; OSSemQty
000048  1c40              ADDS     r0,r0,#1
00004a  8008              STRH     r0,[r1,#0]
;;;121    
;;;122        OS_CRITICAL_EXIT_NO_SCHED();
00004c  f7fffffe          BL       CPU_SR_Save
000050  7831              LDRB     r1,[r6,#0]  ; OSSchedLockNestingCtr
000052  1e49              SUBS     r1,r1,#1
000054  7031              STRB     r1,[r6,#0]
000056  f7fffffe          BL       CPU_SR_Restore
;;;123       *p_err = OS_ERR_NONE;
00005a  802f              STRH     r7,[r5,#0]
                  |L1.92|
;;;124    }
00005c  e8bd81f0          POP      {r4-r8,pc}
                  |L1.96|
000060  f64550c3          MOV      r0,#0x5dc3            ;105
                  |L1.100|
000064  8018              STRH     r0,[r3,#0]            ;105
000066  e7f9              B        |L1.92|
;;;125    
                          ENDP

                  |L1.104|
                          DCD      OSIntNestingCtr
                  |L1.108|
                          DCD      OSSchedLockNestingCtr
                  |L1.112|
                          DCD      0x414d4553
                  |L1.116|
                          DCD      OSSemQty

                          AREA ||i.OSSemDel||, CODE, READONLY, ALIGN=2

                  OSSemDel PROC
;;;162    #if OS_CFG_SEM_DEL_EN > 0u
;;;163    OS_OBJ_QTY  OSSemDel (OS_SEM  *p_sem,
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;164                          OS_OPT   opt,
;;;165                          OS_ERR  *p_err)
;;;166    {
000004  4606              MOV      r6,r0
;;;167        OS_OBJ_QTY     cnt;
;;;168        OS_OBJ_QTY     nbr_tasks;
;;;169        OS_PEND_DATA  *p_pend_data;
;;;170        OS_PEND_LIST  *p_pend_list;
;;;171        OS_TCB        *p_tcb;
;;;172        CPU_TS         ts;
;;;173        CPU_SR_ALLOC();
;;;174    
;;;175    
;;;176    
;;;177    #ifdef OS_SAFETY_CRITICAL
;;;178        if (p_err == (OS_ERR *)0) {
;;;179            OS_SAFETY_CRITICAL_EXCEPTION();
;;;180            return ((OS_OBJ_QTY)0);
;;;181        }
;;;182    #endif
;;;183    
;;;184    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;185        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to delete a semaphore from an ISR          */
000006  483e              LDR      r0,|L2.256|
000008  4689              MOV      r9,r1                 ;166
00000a  4614              MOV      r4,r2                 ;166
00000c  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
00000e  b110              CBZ      r0,|L2.22|
;;;186           *p_err = OS_ERR_DEL_ISR;
000010  f24320c9          MOV      r0,#0x32c9
;;;187            return ((OS_OBJ_QTY)0);
000014  e00a              B        |L2.44|
                  |L2.22|
;;;188        }
;;;189    #endif
;;;190    
;;;191    #if OS_CFG_ARG_CHK_EN > 0u
;;;192        if (p_sem == (OS_SEM *)0) {                             /* Validate 'p_sem'                                       */
000016  b13e              CBZ      r6,|L2.40|
;;;193           *p_err = OS_ERR_OBJ_PTR_NULL;
;;;194            return ((OS_OBJ_QTY)0);
;;;195        }
;;;196        switch (opt) {                                          /* Validate 'opt'                                         */
;;;197            case OS_OPT_DEL_NO_PEND:
;;;198            case OS_OPT_DEL_ALWAYS:
;;;199                 break;
;;;200    
;;;201            default:
;;;202                *p_err = OS_ERR_OPT_INVALID;
000018  f6456b25          MOV      r11,#0x5e25
00001c  b151              CBZ      r1,|L2.52|
00001e  2901              CMP      r1,#1                 ;196
000020  d008              BEQ      |L2.52|
000022  f8a2b000          STRH     r11,[r2,#0]
;;;203                 return ((OS_OBJ_QTY)0);
000026  e002              B        |L2.46|
                  |L2.40|
000028  f64550c3          MOV      r0,#0x5dc3            ;193
                  |L2.44|
00002c  8010              STRH     r0,[r2,#0]            ;186
                  |L2.46|
;;;204        }
;;;205    #endif
;;;206    
;;;207    #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
;;;208        if (p_sem->Type != OS_OBJ_TYPE_SEM) {                   /* Make sure semaphore was created                        */
;;;209           *p_err = OS_ERR_OBJ_TYPE;
;;;210            return ((OS_OBJ_QTY)0);
00002e  2000              MOVS     r0,#0
                  |L2.48|
;;;211        }
;;;212    #endif
;;;213    
;;;214        CPU_CRITICAL_ENTER();
;;;215        p_pend_list = &p_sem->PendList;
;;;216        cnt         = p_pend_list->NbrEntries;
;;;217        nbr_tasks   = cnt;
;;;218        switch (opt) {
;;;219            case OS_OPT_DEL_NO_PEND:                            /* Delete semaphore only if no task waiting               */
;;;220                 if (nbr_tasks == (OS_OBJ_QTY)0) {
;;;221    #if OS_CFG_DBG_EN > 0u
;;;222                     OS_SemDbgListRemove(p_sem);
;;;223    #endif
;;;224                     OSSemQty--;
;;;225                     OS_SemClr(p_sem);
;;;226                     CPU_CRITICAL_EXIT();
;;;227                    *p_err = OS_ERR_NONE;
;;;228                 } else {
;;;229                     CPU_CRITICAL_EXIT();
;;;230                    *p_err = OS_ERR_TASK_WAITING;
;;;231                 }
;;;232                 break;
;;;233    
;;;234            case OS_OPT_DEL_ALWAYS:                             /* Always delete the semaphore                            */
;;;235                 OS_CRITICAL_ENTER_CPU_CRITICAL_EXIT();
;;;236                 ts = OS_TS_GET();                              /* Get local time stamp so all tasks get the same time    */
;;;237                 while (cnt > 0u) {                             /* Remove all tasks on the pend list                      */
;;;238                     p_pend_data = p_pend_list->HeadPtr;
;;;239                     p_tcb       = p_pend_data->TCBPtr;
;;;240                     OS_PendObjDel((OS_PEND_OBJ *)((void *)p_sem),
;;;241                                   p_tcb,
;;;242                                   ts);
;;;243                     cnt--;
;;;244                 }
;;;245    #if OS_CFG_DBG_EN > 0u
;;;246                 OS_SemDbgListRemove(p_sem);
;;;247    #endif
;;;248                 OSSemQty--;
;;;249                 OS_SemClr(p_sem);
;;;250                 OS_CRITICAL_EXIT_NO_SCHED();
;;;251                 OSSched();                                     /* Find highest priority task ready to run                */
;;;252                *p_err = OS_ERR_NONE;
;;;253                 break;
;;;254    
;;;255            default:
;;;256                 CPU_CRITICAL_EXIT();
;;;257                *p_err = OS_ERR_OPT_INVALID;
;;;258                 break;
;;;259        }
;;;260        return ((OS_OBJ_QTY)nbr_tasks);
;;;261    }
000030  e8bd9ff0          POP      {r4-r12,pc}
                  |L2.52|
000034  4933              LDR      r1,|L2.260|
000036  6830              LDR      r0,[r6,#0]            ;208
000038  4288              CMP      r0,r1                 ;208
00003a  d002              BEQ      |L2.66|
00003c  f64550c4          MOV      r0,#0x5dc4            ;209
000040  e7f4              B        |L2.44|
                  |L2.66|
000042  f7fffffe          BL       CPU_SR_Save
000046  4682              MOV      r10,r0                ;214
000048  8a35              LDRH     r5,[r6,#0x10]         ;216
00004a  ea5f0009          MOVS     r0,r9                 ;218
00004e  f8df90b8          LDR      r9,|L2.264|
000052  f1060708          ADD      r7,r6,#8              ;215
000056  46a8              MOV      r8,r5                 ;217
000058  d008              BEQ      |L2.108|
00005a  2801              CMP      r0,#1                 ;218
00005c  d01f              BEQ      |L2.158|
00005e  4650              MOV      r0,r10                ;256
000060  f7fffffe          BL       CPU_SR_Restore
000064  f8a4b000          STRH     r11,[r4,#0]           ;257
                  |L2.104|
000068  4640              MOV      r0,r8                 ;260
00006a  e7e1              B        |L2.48|
                  |L2.108|
00006c  f1b80f00          CMP      r8,#0                 ;220
000070  d006              BEQ      |L2.128|
000072  4650              MOV      r0,r10                ;229
000074  f7fffffe          BL       CPU_SR_Restore
000078  f247105f          MOV      r0,#0x715f            ;230
                  |L2.124|
00007c  8020              STRH     r0,[r4,#0]            ;227
00007e  e7f3              B        |L2.104|
                  |L2.128|
000080  4630              MOV      r0,r6                 ;222
000082  f7fffffe          BL       OS_SemDbgListRemove
000086  f8b91000          LDRH     r1,[r9,#0]            ;224  ; OSSemQty
00008a  4630              MOV      r0,r6                 ;225
00008c  1e49              SUBS     r1,r1,#1              ;224
00008e  f8a91000          STRH     r1,[r9,#0]            ;224
000092  f7fffffe          BL       OS_SemClr
000096  4650              MOV      r0,r10                ;226
000098  f7fffffe          BL       CPU_SR_Restore
00009c  e02d              B        |L2.250|
                  |L2.158|
00009e  f8dfb06c          LDR      r11,|L2.268|
0000a2  4650              MOV      r0,r10                ;235
0000a4  f89b1000          LDRB     r1,[r11,#0]           ;235  ; OSSchedLockNestingCtr
0000a8  1c49              ADDS     r1,r1,#1              ;235
0000aa  f88b1000          STRB     r1,[r11,#0]           ;235
0000ae  f7fffffe          BL       CPU_SR_Restore
0000b2  f7fffffe          BL       CPU_TS_TmrRd
0000b6  4682              MOV      r10,r0                ;236
0000b8  e007              B        |L2.202|
                  |L2.186|
0000ba  6838              LDR      r0,[r7,#0]            ;239
0000bc  4652              MOV      r2,r10                ;240
0000be  6881              LDR      r1,[r0,#8]            ;240
0000c0  4630              MOV      r0,r6                 ;240
0000c2  f7fffffe          BL       OS_PendObjDel
0000c6  1e6d              SUBS     r5,r5,#1              ;243
0000c8  b2ad              UXTH     r5,r5                 ;243
                  |L2.202|
0000ca  2d00              CMP      r5,#0                 ;237
0000cc  d1f5              BNE      |L2.186|
0000ce  4630              MOV      r0,r6                 ;246
0000d0  f7fffffe          BL       OS_SemDbgListRemove
0000d4  f8b91000          LDRH     r1,[r9,#0]            ;248  ; OSSemQty
0000d8  4630              MOV      r0,r6                 ;249
0000da  1e49              SUBS     r1,r1,#1              ;248
0000dc  f8a91000          STRH     r1,[r9,#0]            ;248
0000e0  f7fffffe          BL       OS_SemClr
0000e4  f7fffffe          BL       CPU_SR_Save
0000e8  f89b2000          LDRB     r2,[r11,#0]           ;250  ; OSSchedLockNestingCtr
0000ec  1e52              SUBS     r2,r2,#1              ;250
0000ee  f88b2000          STRB     r2,[r11,#0]           ;250
0000f2  f7fffffe          BL       CPU_SR_Restore
0000f6  f7fffffe          BL       OSSched
                  |L2.250|
0000fa  2000              MOVS     r0,#0                 ;252
0000fc  e7be              B        |L2.124|
;;;262    #endif
                          ENDP

0000fe  0000              DCW      0x0000
                  |L2.256|
                          DCD      OSIntNestingCtr
                  |L2.260|
                          DCD      0x414d4553
                  |L2.264|
                          DCD      OSSemQty
                  |L2.268|
                          DCD      OSSchedLockNestingCtr

                          AREA ||i.OSSemPend||, CODE, READONLY, ALIGN=2

                  OSSemPend PROC
;;;310    
;;;311    OS_SEM_CTR  OSSemPend (OS_SEM   *p_sem,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;312                           OS_TICK   timeout,
;;;313                           OS_OPT    opt,
;;;314                           CPU_TS   *p_ts,
;;;315                           OS_ERR   *p_err)
;;;316    {
000004  4606              MOV      r6,r0
;;;317        OS_SEM_CTR    ctr;
;;;318        OS_PEND_DATA  pend_data;
;;;319        CPU_SR_ALLOC();
;;;320    
;;;321    
;;;322    
;;;323    #ifdef OS_SAFETY_CRITICAL
;;;324        if (p_err == (OS_ERR *)0) {
;;;325            OS_SAFETY_CRITICAL_EXCEPTION();
;;;326            return ((OS_SEM_CTR)0);
;;;327        }
;;;328    #endif
;;;329    
;;;330    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;331        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
000006  4848              LDR      r0,|L3.296|
000008  b088              SUB      sp,sp,#0x20           ;316
00000a  4691              MOV      r9,r2                 ;316
00000c  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
00000e  9d10              LDR      r5,[sp,#0x40]         ;316
000010  461c              MOV      r4,r3                 ;316
000012  468a              MOV      r10,r1                ;316
000014  b110              CBZ      r0,|L3.28|
;;;332           *p_err = OS_ERR_PEND_ISR;
000016  f24610ae          MOV      r0,#0x61ae
;;;333            return ((OS_SEM_CTR)0);
00001a  e009              B        |L3.48|
                  |L3.28|
;;;334        }
;;;335    #endif
;;;336    
;;;337    #if OS_CFG_ARG_CHK_EN > 0u
;;;338        if (p_sem == (OS_SEM *)0) {                             /* Validate 'p_sem'                                       */
00001c  b136              CBZ      r6,|L3.44|
;;;339           *p_err = OS_ERR_OBJ_PTR_NULL;
;;;340            return ((OS_SEM_CTR)0);
;;;341        }
;;;342        switch (opt) {                                          /* Validate 'opt'                                         */
00001e  b14a              CBZ      r2,|L3.52|
000020  f5b24f00          CMP      r2,#0x8000
000024  d006              BEQ      |L3.52|
;;;343            case OS_OPT_PEND_BLOCKING:
;;;344            case OS_OPT_PEND_NON_BLOCKING:
;;;345                 break;
;;;346    
;;;347            default:
;;;348                *p_err = OS_ERR_OPT_INVALID;
000026  f6456025          MOV      r0,#0x5e25
;;;349                 return ((OS_SEM_CTR)0);
00002a  e001              B        |L3.48|
                  |L3.44|
00002c  f64550c3          MOV      r0,#0x5dc3            ;339
                  |L3.48|
000030  8028              STRH     r0,[r5,#0]            ;332
000032  e05b              B        |L3.236|
                  |L3.52|
;;;350        }
;;;351    #endif
;;;352    
;;;353    #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
;;;354        if (p_sem->Type != OS_OBJ_TYPE_SEM) {                   /* Make sure semaphore was created                        */
000034  483d              LDR      r0,|L3.300|
000036  6831              LDR      r1,[r6,#0]
000038  4281              CMP      r1,r0
00003a  d002              BEQ      |L3.66|
;;;355           *p_err = OS_ERR_OBJ_TYPE;
00003c  f64550c4          MOV      r0,#0x5dc4
;;;356            return ((OS_SEM_CTR)0);
000040  e7f6              B        |L3.48|
                  |L3.66|
000042  2700              MOVS     r7,#0
;;;357        }
;;;358    #endif
;;;359    
;;;360        if (p_ts != (CPU_TS *)0) {
000044  b104              CBZ      r4,|L3.72|
;;;361           *p_ts  = (CPU_TS)0;                                  /* Initialize the returned timestamp                      */
000046  6027              STR      r7,[r4,#0]
                  |L3.72|
;;;362        }
;;;363        CPU_CRITICAL_ENTER();
000048  f7fffffe          BL       CPU_SR_Save
;;;364        if (p_sem->Ctr > (OS_SEM_CTR)0) {                       /* Resource available?                                    */
00004c  f8d68020          LDR      r8,[r6,#0x20]
000050  f1b80f00          CMP      r8,#0
000054  d00b              BEQ      |L3.110|
;;;365            p_sem->Ctr--;                                       /* Yes, caller may proceed                                */
000056  f1a80801          SUB      r8,r8,#1
;;;366            if (p_ts != (CPU_TS *)0) {
00005a  f8c68020          STR      r8,[r6,#0x20]
00005e  b10c              CBZ      r4,|L3.100|
;;;367               *p_ts  = p_sem->TS;                              /*      get timestamp of last post                        */
000060  6a71              LDR      r1,[r6,#0x24]
000062  6021              STR      r1,[r4,#0]
                  |L3.100|
;;;368            }
;;;369            ctr   = p_sem->Ctr;
;;;370            CPU_CRITICAL_EXIT();
000064  6a34              LDR      r4,[r6,#0x20]
000066  f7fffffe          BL       CPU_SR_Restore
;;;371           *p_err = OS_ERR_NONE;
00006a  802f              STRH     r7,[r5,#0]
;;;372            return (ctr);
00006c  e054              B        |L3.280|
                  |L3.110|
;;;373        }
;;;374    
;;;375        if ((opt & OS_OPT_PEND_NON_BLOCKING) != (OS_OPT)0) {    /* Caller wants to block if not available?                */
00006e  ea5f4109          LSLS     r1,r9,#16
000072  d508              BPL      |L3.134|
;;;376            ctr   = p_sem->Ctr;                                 /* No                                                     */
;;;377            CPU_CRITICAL_EXIT();
000074  f7fffffe          BL       CPU_SR_Restore
;;;378           *p_err = OS_ERR_PEND_WOULD_BLOCK;
000078  f24610b0          MOV      r0,#0x61b0
00007c  8028              STRH     r0,[r5,#0]
;;;379            return (ctr);
00007e  4640              MOV      r0,r8
                  |L3.128|
;;;380        } else {                                                /* Yes                                                    */
;;;381            if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {    /* Can't pend when the scheduler is locked                */
;;;382                CPU_CRITICAL_EXIT();
;;;383               *p_err = OS_ERR_SCHED_LOCKED;
;;;384                return ((OS_SEM_CTR)0);
;;;385            }
;;;386        }
;;;387    
;;;388        OS_CRITICAL_ENTER_CPU_CRITICAL_EXIT();                  /* Lock the scheduler/re-enable interrupts                */
;;;389        OS_Pend(&pend_data,                                     /* Block task pending on Semaphore                        */
;;;390                (OS_PEND_OBJ *)((void *)p_sem),
;;;391                OS_TASK_PEND_ON_SEM,
;;;392                timeout);
;;;393    
;;;394        OS_CRITICAL_EXIT_NO_SCHED();
;;;395    
;;;396        OSSched();                                              /* Find the next highest priority task ready to run       */
;;;397    
;;;398        CPU_CRITICAL_ENTER();
;;;399        switch (OSTCBCurPtr->PendStatus) {
;;;400            case OS_STATUS_PEND_OK:                             /* We got the semaphore                                   */
;;;401                 if (p_ts != (CPU_TS *)0) {
;;;402                    *p_ts  =  OSTCBCurPtr->TS;
;;;403                 }
;;;404                *p_err = OS_ERR_NONE;
;;;405                 break;
;;;406    
;;;407            case OS_STATUS_PEND_ABORT:                          /* Indicate that we aborted                               */
;;;408                 if (p_ts != (CPU_TS *)0) {
;;;409                    *p_ts  =  OSTCBCurPtr->TS;
;;;410                 }
;;;411                *p_err = OS_ERR_PEND_ABORT;
;;;412                 break;
;;;413    
;;;414            case OS_STATUS_PEND_TIMEOUT:                        /* Indicate that we didn't get semaphore within timeout   */
;;;415                 if (p_ts != (CPU_TS *)0) {
;;;416                    *p_ts  = (CPU_TS  )0;
;;;417                 }
;;;418                *p_err = OS_ERR_TIMEOUT;
;;;419                 break;
;;;420    
;;;421            case OS_STATUS_PEND_DEL:                            /* Indicate that object pended on has been deleted        */
;;;422                 if (p_ts != (CPU_TS *)0) {
;;;423                    *p_ts  =  OSTCBCurPtr->TS;
;;;424                 }
;;;425                *p_err = OS_ERR_OBJ_DEL;
;;;426                 break;
;;;427    
;;;428            default:
;;;429                *p_err = OS_ERR_STATUS_INVALID;
;;;430                 CPU_CRITICAL_EXIT();
;;;431                 return ((OS_SEM_CTR)0);
;;;432        }
;;;433        ctr = p_sem->Ctr;
;;;434        CPU_CRITICAL_EXIT();
;;;435        return (ctr);
;;;436    }
000080  b008              ADD      sp,sp,#0x20
000082  e8bd87f0          POP      {r4-r10,pc}
                  |L3.134|
000086  492a              LDR      r1,|L3.304|
000088  780a              LDRB     r2,[r1,#0]            ;381  ; OSSchedLockNestingCtr
00008a  b122              CBZ      r2,|L3.150|
00008c  f7fffffe          BL       CPU_SR_Restore
000090  f6465063          MOV      r0,#0x6d63            ;383
000094  e7cc              B        |L3.48|
                  |L3.150|
000096  4688              MOV      r8,r1                 ;388
000098  2101              MOVS     r1,#1                 ;388
00009a  f8881000          STRB     r1,[r8,#0]            ;388
00009e  f7fffffe          BL       CPU_SR_Restore
0000a2  4653              MOV      r3,r10                ;389
0000a4  2206              MOVS     r2,#6                 ;389
0000a6  4631              MOV      r1,r6                 ;389
0000a8  4668              MOV      r0,sp                 ;389
0000aa  f7fffffe          BL       OS_Pend
0000ae  f7fffffe          BL       CPU_SR_Save
0000b2  f8981000          LDRB     r1,[r8,#0]            ;394  ; OSSchedLockNestingCtr
0000b6  1e49              SUBS     r1,r1,#1              ;394
0000b8  f8881000          STRB     r1,[r8,#0]            ;394
0000bc  f7fffffe          BL       CPU_SR_Restore
0000c0  f7fffffe          BL       OSSched
0000c4  f7fffffe          BL       CPU_SR_Save
0000c8  4601              MOV      r1,r0                 ;398
0000ca  481a              LDR      r0,|L3.308|
0000cc  6800              LDR      r0,[r0,#0]            ;399  ; OSTCBCurPtr
0000ce  f8902035          LDRB     r2,[r0,#0x35]         ;399
0000d2  b16a              CBZ      r2,|L3.240|
0000d4  2a01              CMP      r2,#1                 ;399
0000d6  d010              BEQ      |L3.250|
0000d8  2a02              CMP      r2,#2                 ;399
0000da  d01f              BEQ      |L3.284|
0000dc  2a03              CMP      r2,#3                 ;399
0000de  d012              BEQ      |L3.262|
0000e0  f646602e          MOV      r0,#0x6e2e            ;429
0000e4  8028              STRH     r0,[r5,#0]            ;429
0000e6  4608              MOV      r0,r1                 ;430
0000e8  f7fffffe          BL       CPU_SR_Restore
                  |L3.236|
0000ec  2000              MOVS     r0,#0                 ;431
0000ee  e7c7              B        |L3.128|
                  |L3.240|
0000f0  b10c              CBZ      r4,|L3.246|
0000f2  6c00              LDR      r0,[r0,#0x40]         ;402
0000f4  6020              STR      r0,[r4,#0]            ;402
                  |L3.246|
0000f6  802f              STRH     r7,[r5,#0]            ;404
0000f8  e00a              B        |L3.272|
                  |L3.250|
0000fa  b10c              CBZ      r4,|L3.256|
0000fc  6c00              LDR      r0,[r0,#0x40]         ;409
0000fe  6020              STR      r0,[r4,#0]            ;409
                  |L3.256|
000100  f24610a9          MOV      r0,#0x61a9            ;411
000104  e003              B        |L3.270|
                  |L3.262|
000106  b104              CBZ      r4,|L3.266|
000108  6027              STR      r7,[r4,#0]            ;416
                  |L3.266|
00010a  f24720d9          MOV      r0,#0x72d9            ;418
                  |L3.270|
00010e  8028              STRH     r0,[r5,#0]            ;411
                  |L3.272|
000110  4608              MOV      r0,r1                 ;434
000112  6a34              LDR      r4,[r6,#0x20]         ;434
000114  f7fffffe          BL       CPU_SR_Restore
                  |L3.280|
000118  4620              MOV      r0,r4                 ;435
00011a  e7b1              B        |L3.128|
                  |L3.284|
00011c  b10c              CBZ      r4,|L3.290|
00011e  6c00              LDR      r0,[r0,#0x40]         ;423
000120  6020              STR      r0,[r4,#0]            ;423
                  |L3.290|
000122  f64550c2          MOV      r0,#0x5dc2            ;425
000126  e7f2              B        |L3.270|
;;;437    
                          ENDP

                  |L3.296|
                          DCD      OSIntNestingCtr
                  |L3.300|
                          DCD      0x414d4553
                  |L3.304|
                          DCD      OSSchedLockNestingCtr
                  |L3.308|
                          DCD      OSTCBCurPtr

                          AREA ||i.OSSemPendAbort||, CODE, READONLY, ALIGN=2

                  OSSemPendAbort PROC
;;;470    #if OS_CFG_SEM_PEND_ABORT_EN > 0u
;;;471    OS_OBJ_QTY  OSSemPendAbort (OS_SEM  *p_sem,
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;472                                OS_OPT   opt,
;;;473                                OS_ERR  *p_err)
;;;474    {
000004  4604              MOV      r4,r0
;;;475        OS_PEND_LIST  *p_pend_list;
;;;476        OS_TCB        *p_tcb;
;;;477        CPU_TS         ts;
;;;478        OS_OBJ_QTY     nbr_tasks;
;;;479        CPU_SR_ALLOC();
;;;480    
;;;481    
;;;482    
;;;483    #ifdef OS_SAFETY_CRITICAL
;;;484        if (p_err == (OS_ERR *)0) {
;;;485            OS_SAFETY_CRITICAL_EXCEPTION();
;;;486            return ((OS_OBJ_QTY)0u);
;;;487        }
;;;488    #endif
;;;489    
;;;490    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;491        if (OSIntNestingCtr > (OS_NESTING_CTR)0u) {             /* Not allowed to Pend Abort from an ISR                  */
000006  4830              LDR      r0,|L4.200|
000008  4688              MOV      r8,r1                 ;474
00000a  4615              MOV      r5,r2                 ;474
00000c  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
00000e  b110              CBZ      r0,|L4.22|
;;;492           *p_err =  OS_ERR_PEND_ABORT_ISR;
000010  f24610aa          MOV      r0,#0x61aa
;;;493            return ((OS_OBJ_QTY)0u);
000014  e011              B        |L4.58|
                  |L4.22|
;;;494        }
;;;495    #endif
;;;496    
;;;497    #if OS_CFG_ARG_CHK_EN > 0u
;;;498        if (p_sem == (OS_SEM *)0) {                             /* Validate 'p_sem'                                       */
000016  b174              CBZ      r4,|L4.54|
;;;499           *p_err =  OS_ERR_OBJ_PTR_NULL;
;;;500            return ((OS_OBJ_QTY)0u);
;;;501        }
;;;502        switch (opt) {                                          /* Validate 'opt'                                         */
000018  0008              MOVS     r0,r1
00001a  f44f7a80          MOV      r10,#0x100
00001e  d00e              BEQ      |L4.62|
000020  4550              CMP      r0,r10
000022  d00c              BEQ      |L4.62|
000024  f5b04f00          CMP      r0,#0x8000
000028  d009              BEQ      |L4.62|
00002a  f5b14f01          CMP      r1,#0x8100
00002e  d006              BEQ      |L4.62|
;;;503            case OS_OPT_PEND_ABORT_1:
;;;504            case OS_OPT_PEND_ABORT_ALL:
;;;505            case OS_OPT_PEND_ABORT_1   | OS_OPT_POST_NO_SCHED:
;;;506            case OS_OPT_PEND_ABORT_ALL | OS_OPT_POST_NO_SCHED:
;;;507                 break;
;;;508    
;;;509            default:
;;;510                *p_err =  OS_ERR_OPT_INVALID;
000030  f6456025          MOV      r0,#0x5e25
;;;511                 return ((OS_OBJ_QTY)0u);
000034  e001              B        |L4.58|
                  |L4.54|
000036  f64550c3          MOV      r0,#0x5dc3            ;499
                  |L4.58|
00003a  8010              STRH     r0,[r2,#0]            ;492
00003c  e022              B        |L4.132|
                  |L4.62|
;;;512        }
;;;513    #endif
;;;514    
;;;515    #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
;;;516        if (p_sem->Type != OS_OBJ_TYPE_SEM) {                   /* Make sure semaphore was created                        */
00003e  4923              LDR      r1,|L4.204|
000040  6820              LDR      r0,[r4,#0]
000042  4288              CMP      r0,r1
000044  d002              BEQ      |L4.76|
;;;517           *p_err =  OS_ERR_OBJ_TYPE;
000046  f64550c4          MOV      r0,#0x5dc4
;;;518            return ((OS_OBJ_QTY)0u);
00004a  e7f6              B        |L4.58|
                  |L4.76|
;;;519        }
;;;520    #endif
;;;521    
;;;522        CPU_CRITICAL_ENTER();
00004c  f7fffffe          BL       CPU_SR_Save
000050  4601              MOV      r1,r0
;;;523        p_pend_list = &p_sem->PendList;
;;;524        if (p_pend_list->NbrEntries == (OS_OBJ_QTY)0u) {        /* Any task waiting on semaphore?                         */
000052  8a20              LDRH     r0,[r4,#0x10]
000054  f1040708          ADD      r7,r4,#8              ;523
000058  b170              CBZ      r0,|L4.120|
;;;525            CPU_CRITICAL_EXIT();                                /* No                                                     */
;;;526           *p_err =  OS_ERR_PEND_ABORT_NONE;
;;;527            return ((OS_OBJ_QTY)0u);
;;;528        }
;;;529    
;;;530        OS_CRITICAL_ENTER_CPU_CRITICAL_EXIT();
00005a  f8df9074          LDR      r9,|L4.208|
00005e  4608              MOV      r0,r1
000060  f8992000          LDRB     r2,[r9,#0]  ; OSSchedLockNestingCtr
000064  1c52              ADDS     r2,r2,#1
000066  f8892000          STRB     r2,[r9,#0]
00006a  f7fffffe          BL       CPU_SR_Restore
;;;531        nbr_tasks = 0u;
00006e  2600              MOVS     r6,#0
;;;532        ts        = OS_TS_GET();                                /* Get local time stamp so all tasks get the same time    */
000070  f7fffffe          BL       CPU_TS_TmrRd
000074  4683              MOV      r11,r0
;;;533        while (p_pend_list->NbrEntries > (OS_OBJ_QTY)0u) {
000076  e012              B        |L4.158|
                  |L4.120|
000078  4608              MOV      r0,r1                 ;525
00007a  f7fffffe          BL       CPU_SR_Restore
00007e  f24610ab          MOV      r0,#0x61ab            ;526
000082  8028              STRH     r0,[r5,#0]            ;526
                  |L4.132|
000084  2000              MOVS     r0,#0                 ;527
                  |L4.134|
;;;534            p_tcb = p_pend_list->HeadPtr->TCBPtr;
;;;535            OS_PendAbort((OS_PEND_OBJ *)((void *)p_sem),
;;;536                         p_tcb,
;;;537                         ts);
;;;538            nbr_tasks++;
;;;539            if (opt != OS_OPT_PEND_ABORT_ALL) {                 /* Pend abort all tasks waiting?                          */
;;;540                break;                                          /* No                                                     */
;;;541            }
;;;542        }
;;;543        OS_CRITICAL_EXIT_NO_SCHED();
;;;544    
;;;545        if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0u) {
;;;546            OSSched();                                          /* Run the scheduler                                      */
;;;547        }
;;;548    
;;;549       *p_err = OS_ERR_NONE;
;;;550        return (nbr_tasks);
;;;551    }
000086  e8bd9ff0          POP      {r4-r12,pc}
                  |L4.138|
00008a  6838              LDR      r0,[r7,#0]            ;534
00008c  465a              MOV      r2,r11                ;535
00008e  6881              LDR      r1,[r0,#8]            ;535
000090  4620              MOV      r0,r4                 ;535
000092  f7fffffe          BL       OS_PendAbort
000096  1c76              ADDS     r6,r6,#1              ;538
000098  b2b6              UXTH     r6,r6                 ;538
00009a  45d0              CMP      r8,r10                ;539
00009c  d102              BNE      |L4.164|
                  |L4.158|
00009e  8938              LDRH     r0,[r7,#8]            ;533
0000a0  2800              CMP      r0,#0                 ;533
0000a2  d1f2              BNE      |L4.138|
                  |L4.164|
0000a4  f7fffffe          BL       CPU_SR_Save
0000a8  f8992000          LDRB     r2,[r9,#0]            ;543  ; OSSchedLockNestingCtr
0000ac  1e52              SUBS     r2,r2,#1              ;543
0000ae  f8892000          STRB     r2,[r9,#0]            ;543
0000b2  f7fffffe          BL       CPU_SR_Restore
0000b6  ea5f4008          LSLS     r0,r8,#16             ;545
0000ba  d401              BMI      |L4.192|
0000bc  f7fffffe          BL       OSSched
                  |L4.192|
0000c0  2000              MOVS     r0,#0                 ;549
0000c2  8028              STRH     r0,[r5,#0]            ;549
0000c4  4630              MOV      r0,r6                 ;550
0000c6  e7de              B        |L4.134|
;;;552    #endif
                          ENDP

                  |L4.200|
                          DCD      OSIntNestingCtr
                  |L4.204|
                          DCD      0x414d4553
                  |L4.208|
                          DCD      OSSchedLockNestingCtr

                          AREA ||i.OSSemPost||, CODE, READONLY, ALIGN=2

                  OSSemPost PROC
;;;583    
;;;584    OS_SEM_CTR  OSSemPost (OS_SEM  *p_sem,
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;585                           OS_OPT   opt,
;;;586                           OS_ERR  *p_err)
;;;587    {
000004  460e              MOV      r6,r1
000006  0005              MOVS     r5,r0
000008  4614              MOV      r4,r2
00000a  d00d              BEQ      |L5.40|
;;;588        OS_SEM_CTR  ctr;
;;;589        CPU_TS      ts;
;;;590    
;;;591    
;;;592    
;;;593    #ifdef OS_SAFETY_CRITICAL
;;;594        if (p_err == (OS_ERR *)0) {
;;;595            OS_SAFETY_CRITICAL_EXCEPTION();
;;;596            return ((OS_SEM_CTR)0);
;;;597        }
;;;598    #endif
;;;599    
;;;600    #if OS_CFG_ARG_CHK_EN > 0u
;;;601        if (p_sem == (OS_SEM *)0) {                             /* Validate 'p_sem'                                       */
;;;602           *p_err  = OS_ERR_OBJ_PTR_NULL;
;;;603            return ((OS_SEM_CTR)0);
;;;604        }
;;;605        switch (opt) {                                          /* Validate 'opt'                                         */
00000c  b17e              CBZ      r6,|L5.46|
00000e  f5b67f00          CMP      r6,#0x200
000012  d00c              BEQ      |L5.46|
000014  f5b64f00          CMP      r6,#0x8000
000018  d009              BEQ      |L5.46|
00001a  f5b64f02          CMP      r6,#0x8200
00001e  d006              BEQ      |L5.46|
;;;606            case OS_OPT_POST_1:
;;;607            case OS_OPT_POST_ALL:
;;;608            case OS_OPT_POST_1   | OS_OPT_POST_NO_SCHED:
;;;609            case OS_OPT_POST_ALL | OS_OPT_POST_NO_SCHED:
;;;610                 break;
;;;611    
;;;612            default:
;;;613                *p_err =  OS_ERR_OPT_INVALID;
000020  f6456025          MOV      r0,#0x5e25
                  |L5.36|
000024  8010              STRH     r0,[r2,#0]            ;602
000026  e01a              B        |L5.94|
                  |L5.40|
000028  f64550c3          MOV      r0,#0x5dc3            ;602
00002c  e7fa              B        |L5.36|
                  |L5.46|
;;;614                 return ((OS_SEM_CTR)0u);
;;;615        }
;;;616    #endif
;;;617    
;;;618    #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
;;;619        if (p_sem->Type != OS_OBJ_TYPE_SEM) {                   /* Make sure semaphore was created                        */
00002e  4f12              LDR      r7,|L5.120|
000030  6828              LDR      r0,[r5,#0]
000032  42b8              CMP      r0,r7
000034  d002              BEQ      |L5.60|
;;;620           *p_err = OS_ERR_OBJ_TYPE;
000036  f64550c4          MOV      r0,#0x5dc4
;;;621            return ((OS_SEM_CTR)0);
00003a  e7f3              B        |L5.36|
                  |L5.60|
;;;622        }
;;;623    #endif
;;;624    
;;;625        ts = OS_TS_GET();                                       /* Get timestamp                                          */
00003c  f7fffffe          BL       CPU_TS_TmrRd
000040  4602              MOV      r2,r0
;;;626    
;;;627    #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
;;;628        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if called from an ISR                              */
000042  480e              LDR      r0,|L5.124|
000044  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
000046  b170              CBZ      r0,|L5.102|
;;;629            OS_IntQPost((OS_OBJ_TYPE)OS_OBJ_TYPE_SEM,           /* Post to ISR queue                                      */
000048  2000              MOVS     r0,#0
00004a  e9cd2402          STRD     r2,r4,[sp,#8]
00004e  e9cd0600          STRD     r0,r6,[sp,#0]
000052  4603              MOV      r3,r0
000054  4602              MOV      r2,r0
000056  4629              MOV      r1,r5
000058  4638              MOV      r0,r7
00005a  f7fffffe          BL       OS_IntQPost
                  |L5.94|
;;;630                        (void      *)p_sem,
;;;631                        (void      *)0,
;;;632                        (OS_MSG_SIZE)0,
;;;633                        (OS_FLAGS   )0,
;;;634                        (OS_OPT     )opt,
;;;635                        (CPU_TS     )ts,
;;;636                        (OS_ERR    *)p_err);
;;;637            return ((OS_SEM_CTR)0);
;;;638        }
;;;639    #endif
;;;640    
;;;641        ctr = OS_SemPost(p_sem,                                 /* Post to semaphore                                      */
;;;642                         opt,
;;;643                         ts,
;;;644                         p_err);
;;;645    
;;;646        return (ctr);
;;;647    }
00005e  b004              ADD      sp,sp,#0x10
000060  2000              MOVS     r0,#0                 ;637
000062  e8bd81f0          POP      {r4-r8,pc}
                  |L5.102|
000066  b004              ADD      sp,sp,#0x10           ;641
000068  4623              MOV      r3,r4                 ;641
00006a  4631              MOV      r1,r6                 ;641
00006c  4628              MOV      r0,r5                 ;641
00006e  e8bd41f0          POP      {r4-r8,lr}            ;641
000072  f7ffbffe          B.W      OS_SemPost
;;;648    
                          ENDP

000076  0000              DCW      0x0000
                  |L5.120|
                          DCD      0x414d4553
                  |L5.124|
                          DCD      OSIntNestingCtr

                          AREA ||i.OSSemSet||, CODE, READONLY, ALIGN=2

                  OSSemSet PROC
;;;675    #if OS_CFG_SEM_SET_EN > 0u
;;;676    void  OSSemSet (OS_SEM      *p_sem,
000000  b570              PUSH     {r4-r6,lr}
;;;677                    OS_SEM_CTR   cnt,
;;;678                    OS_ERR      *p_err)
;;;679    {
000002  4604              MOV      r4,r0
;;;680        OS_PEND_LIST  *p_pend_list;
;;;681        CPU_SR_ALLOC();
;;;682    
;;;683    
;;;684    
;;;685    #ifdef OS_SAFETY_CRITICAL
;;;686        if (p_err == (OS_ERR *)0) {
;;;687            OS_SAFETY_CRITICAL_EXCEPTION();
;;;688            return;
;;;689        }
;;;690    #endif
;;;691    
;;;692    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;693        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Can't call this function from an ISR                   */
000004  4813              LDR      r0,|L6.84|
000006  460e              MOV      r6,r1                 ;679
000008  4615              MOV      r5,r2                 ;679
00000a  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
00000c  b110              CBZ      r0,|L6.20|
;;;694           *p_err = OS_ERR_SET_ISR;
00000e  f64650c6          MOV      r0,#0x6dc6
;;;695            return;
000012  e006              B        |L6.34|
                  |L6.20|
;;;696        }
;;;697    #endif
;;;698    
;;;699    #if OS_CFG_ARG_CHK_EN > 0u
;;;700        if (p_sem == (OS_SEM *)0) {                             /* Validate 'p_sem'                                       */
000014  b13c              CBZ      r4,|L6.38|
;;;701           *p_err = OS_ERR_OBJ_PTR_NULL;
;;;702            return;
;;;703        }
;;;704    #endif
;;;705    
;;;706    #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
;;;707        if (p_sem->Type != OS_OBJ_TYPE_SEM) {                   /* Make sure semaphore was created                        */
000016  4910              LDR      r1,|L6.88|
000018  6820              LDR      r0,[r4,#0]
00001a  4288              CMP      r0,r1
00001c  d006              BEQ      |L6.44|
;;;708           *p_err = OS_ERR_OBJ_TYPE;
00001e  f64550c4          MOV      r0,#0x5dc4
                  |L6.34|
000022  8010              STRH     r0,[r2,#0]
;;;709            return;
;;;710        }
;;;711    #endif
;;;712    
;;;713       *p_err = OS_ERR_NONE;
;;;714        CPU_CRITICAL_ENTER();
;;;715        if (p_sem->Ctr > (OS_SEM_CTR)0) {                       /* See if semaphore already has a count                   */
;;;716            p_sem->Ctr = cnt;                                   /* Yes, set it to the new value specified.                */
;;;717        } else {
;;;718            p_pend_list = &p_sem->PendList;                     /* No                                                     */
;;;719            if (p_pend_list->NbrEntries == (OS_OBJ_QTY)0) {     /*      See if task(s) waiting?                           */
;;;720                p_sem->Ctr = cnt;                               /*      No, OK to set the value                           */
;;;721            } else {
;;;722               *p_err      = OS_ERR_TASK_WAITING;
;;;723            }
;;;724        }
;;;725        CPU_CRITICAL_EXIT();
;;;726    }
000024  bd70              POP      {r4-r6,pc}
                  |L6.38|
000026  f64550c3          MOV      r0,#0x5dc3            ;701
00002a  e7fa              B        |L6.34|
                  |L6.44|
00002c  2000              MOVS     r0,#0                 ;713
00002e  8028              STRH     r0,[r5,#0]            ;713
000030  f7fffffe          BL       CPU_SR_Save
000034  4601              MOV      r1,r0                 ;714
000036  6a20              LDR      r0,[r4,#0x20]         ;715
000038  b948              CBNZ     r0,|L6.78|
00003a  8a20              LDRH     r0,[r4,#0x10]         ;719
00003c  b138              CBZ      r0,|L6.78|
00003e  f247105f          MOV      r0,#0x715f            ;722
000042  8028              STRH     r0,[r5,#0]            ;722
                  |L6.68|
000044  e8bd4070          POP      {r4-r6,lr}            ;725
000048  4608              MOV      r0,r1                 ;725
00004a  f7ffbffe          B.W      CPU_SR_Restore
                  |L6.78|
00004e  6226              STR      r6,[r4,#0x20]         ;720
000050  e7f8              B        |L6.68|
;;;727    #endif
                          ENDP

000052  0000              DCW      0x0000
                  |L6.84|
                          DCD      OSIntNestingCtr
                  |L6.88|
                          DCD      0x414d4553

                          AREA ||i.OS_SemClr||, CODE, READONLY, ALIGN=2

                  OS_SemClr PROC
;;;745    
;;;746    void  OS_SemClr (OS_SEM  *p_sem)
000000  4904              LDR      r1,|L7.20|
;;;747    {
;;;748        p_sem->Type    = OS_OBJ_TYPE_NONE;                      /* Mark the data structure as a NONE                      */
;;;749        p_sem->Ctr     = (OS_SEM_CTR)0;                         /* Set semaphore value                                    */
000002  6001              STR      r1,[r0,#0]
000004  2100              MOVS     r1,#0
;;;750        p_sem->TS      = (CPU_TS    )0;                         /* Clear the time stamp                                   */
000006  6201              STR      r1,[r0,#0x20]
;;;751        p_sem->NamePtr = (CPU_CHAR *)((void *)"?SEM");
000008  6241              STR      r1,[r0,#0x24]
00000a  4903              LDR      r1,|L7.24|
;;;752        OS_PendListInit(&p_sem->PendList);                      /* Initialize the waiting list                            */
00000c  6041              STR      r1,[r0,#4]
00000e  3008              ADDS     r0,r0,#8
000010  f7ffbffe          B.W      OS_PendListInit
;;;753    }
;;;754    
                          ENDP

                  |L7.20|
                          DCD      0x454e4f4e
                  |L7.24|
                          DCD      ||.constdata||

                          AREA ||i.OS_SemDbgListAdd||, CODE, READONLY, ALIGN=2

                  OS_SemDbgListAdd PROC
;;;771    #if OS_CFG_DBG_EN > 0u
;;;772    void  OS_SemDbgListAdd (OS_SEM  *p_sem)
000000  2200              MOVS     r2,#0
;;;773    {
;;;774        p_sem->DbgNamePtr               = (CPU_CHAR *)((void *)" ");
;;;775        p_sem->DbgPrevPtr               = (OS_SEM   *)0;
;;;776        if (OSSemDbgListPtr == (OS_SEM *)0) {
000002  4b07              LDR      r3,|L8.32|
000004  a105              ADR      r1,|L8.28|
000006  6142              STR      r2,[r0,#0x14]
000008  61c1              STR      r1,[r0,#0x1c]
00000a  6819              LDR      r1,[r3,#0]            ;773  ; OSSemDbgListPtr
00000c  b119              CBZ      r1,|L8.22|
;;;777            p_sem->DbgNextPtr           = (OS_SEM   *)0;
;;;778        } else {
;;;779            p_sem->DbgNextPtr           =  OSSemDbgListPtr;
;;;780            OSSemDbgListPtr->DbgPrevPtr =  p_sem;
00000e  6181              STR      r1,[r0,#0x18]
000010  6148              STR      r0,[r1,#0x14]
                  |L8.18|
;;;781        }
;;;782        OSSemDbgListPtr                 =  p_sem;
;;;783    }
000012  6018              STR      r0,[r3,#0]  ; OSSemDbgListPtr
000014  4770              BX       lr
                  |L8.22|
000016  6182              STR      r2,[r0,#0x18]         ;777
000018  e7fb              B        |L8.18|
;;;784    
                          ENDP

00001a  0000              DCW      0x0000
                  |L8.28|
00001c  2000              DCB      " ",0
00001e  00                DCB      0
00001f  00                DCB      0
                  |L8.32|
                          DCD      OSSemDbgListPtr

                          AREA ||i.OS_SemDbgListRemove||, CODE, READONLY, ALIGN=2

                  OS_SemDbgListRemove PROC
;;;786    
;;;787    void  OS_SemDbgListRemove (OS_SEM  *p_sem)
000000  e9d02105          LDRD     r2,r1,[r0,#0x14]
;;;788    {
000004  2300              MOVS     r3,#0
000006  b12a              CBZ      r2,|L9.20|
;;;789        OS_SEM  *p_sem_next;
;;;790        OS_SEM  *p_sem_prev;
;;;791    
;;;792    
;;;793        p_sem_prev = p_sem->DbgPrevPtr;
;;;794        p_sem_next = p_sem->DbgNextPtr;
;;;795    
;;;796        if (p_sem_prev == (OS_SEM *)0) {
;;;797            OSSemDbgListPtr = p_sem_next;
;;;798            if (p_sem_next != (OS_SEM *)0) {
;;;799                p_sem_next->DbgPrevPtr = (OS_SEM *)0;
;;;800            }
;;;801            p_sem->DbgNextPtr = (OS_SEM *)0;
;;;802    
;;;803        } else if (p_sem_next == (OS_SEM *)0) {
000008  b151              CBZ      r1,|L9.32|
;;;804            p_sem_prev->DbgNextPtr = (OS_SEM *)0;
;;;805            p_sem->DbgPrevPtr      = (OS_SEM *)0;
;;;806    
;;;807        } else {
;;;808            p_sem_prev->DbgNextPtr =  p_sem_next;
;;;809            p_sem_next->DbgPrevPtr =  p_sem_prev;
00000a  6191              STR      r1,[r2,#0x18]
;;;810            p_sem->DbgNextPtr      = (OS_SEM *)0;
00000c  614a              STR      r2,[r1,#0x14]
00000e  6183              STR      r3,[r0,#0x18]
                  |L9.16|
;;;811            p_sem->DbgPrevPtr      = (OS_SEM *)0;
000010  6143              STR      r3,[r0,#0x14]
;;;812        }
;;;813    }
000012  4770              BX       lr
                  |L9.20|
000014  4a03              LDR      r2,|L9.36|
000016  6011              STR      r1,[r2,#0]            ;798  ; OSSemDbgListPtr
000018  b101              CBZ      r1,|L9.28|
00001a  614b              STR      r3,[r1,#0x14]         ;799
                  |L9.28|
00001c  6183              STR      r3,[r0,#0x18]         ;801
00001e  4770              BX       lr
                  |L9.32|
000020  6193              STR      r3,[r2,#0x18]         ;805
000022  e7f5              B        |L9.16|
;;;814    #endif
                          ENDP

                  |L9.36|
                          DCD      OSSemDbgListPtr

                          AREA ||i.OS_SemInit||, CODE, READONLY, ALIGN=2

                  OS_SemInit PROC
;;;833    
;;;834    void  OS_SemInit (OS_ERR  *p_err)
000000  4a03              LDR      r2,|L10.16|
;;;835    {
;;;836    #ifdef OS_SAFETY_CRITICAL
;;;837        if (p_err == (OS_ERR *)0) {
;;;838            OS_SAFETY_CRITICAL_EXCEPTION();
;;;839            return;
;;;840        }
;;;841    #endif
;;;842    
;;;843    #if OS_CFG_DBG_EN > 0u
;;;844        OSSemDbgListPtr = (OS_SEM *)0;
000002  2100              MOVS     r1,#0
;;;845    #endif
;;;846    
;;;847        OSSemQty        = (OS_OBJ_QTY)0;
000004  6011              STR      r1,[r2,#0]  ; OSSemDbgListPtr
000006  4a03              LDR      r2,|L10.20|
000008  8011              STRH     r1,[r2,#0]
;;;848       *p_err           = OS_ERR_NONE;
00000a  8001              STRH     r1,[r0,#0]
;;;849    }
00000c  4770              BX       lr
;;;850    
                          ENDP

00000e  0000              DCW      0x0000
                  |L10.16|
                          DCD      OSSemDbgListPtr
                  |L10.20|
                          DCD      OSSemQty

                          AREA ||i.OS_SemPost||, CODE, READONLY, ALIGN=2

                  OS_SemPost PROC
;;;883    
;;;884    OS_SEM_CTR  OS_SemPost (OS_SEM  *p_sem,
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;885                            OS_OPT   opt,
;;;886                            CPU_TS   ts,
;;;887                            OS_ERR  *p_err)
;;;888    {
000004  4688              MOV      r8,r1
000006  461e              MOV      r6,r3
000008  4691              MOV      r9,r2
00000a  4604              MOV      r4,r0
;;;889        OS_OBJ_QTY     cnt;
;;;890        OS_SEM_CTR     ctr;
;;;891        OS_PEND_LIST  *p_pend_list;
;;;892        OS_PEND_DATA  *p_pend_data;
;;;893        OS_PEND_DATA  *p_pend_data_next;
;;;894        OS_TCB        *p_tcb;
;;;895        CPU_SR_ALLOC();
;;;896    
;;;897    
;;;898    
;;;899        CPU_CRITICAL_ENTER();
00000c  f7fffffe          BL       CPU_SR_Save
000010  4601              MOV      r1,r0
;;;900        p_pend_list = &p_sem->PendList;
;;;901        if (p_pend_list->NbrEntries == (OS_OBJ_QTY)0) {         /* Any task waiting on semaphore?                         */
000012  8a20              LDRH     r0,[r4,#0x10]
000014  f1040708          ADD      r7,r4,#8              ;900
000018  f04f0b00          MOV      r11,#0
00001c  b178              CBZ      r0,|L11.62|
;;;902            switch (sizeof(OS_SEM_CTR)) {
;;;903                case 1u:
;;;904                     if (p_sem->Ctr == DEF_INT_08U_MAX_VAL) {
;;;905                         CPU_CRITICAL_EXIT();
;;;906                        *p_err = OS_ERR_SEM_OVF;
;;;907                         return ((OS_SEM_CTR)0);
;;;908                     }
;;;909                     break;
;;;910    
;;;911                case 2u:
;;;912                     if (p_sem->Ctr == DEF_INT_16U_MAX_VAL) {
;;;913                         CPU_CRITICAL_EXIT();
;;;914                        *p_err = OS_ERR_SEM_OVF;
;;;915                         return ((OS_SEM_CTR)0);
;;;916                     }
;;;917                     break;
;;;918    
;;;919                case 4u:
;;;920                     if (p_sem->Ctr == DEF_INT_32U_MAX_VAL) {
;;;921                         CPU_CRITICAL_EXIT();
;;;922                        *p_err = OS_ERR_SEM_OVF;
;;;923                         return ((OS_SEM_CTR)0);
;;;924                     }
;;;925                     break;
;;;926    
;;;927                default:
;;;928                     break;
;;;929            }
;;;930            p_sem->Ctr++;                                       /* No                                                     */
;;;931            ctr       = p_sem->Ctr;
;;;932            p_sem->TS = ts;                                     /* Save timestamp in semaphore control block              */
;;;933            CPU_CRITICAL_EXIT();
;;;934           *p_err     = OS_ERR_NONE;
;;;935            return (ctr);
;;;936        }
;;;937    
;;;938        OS_CRITICAL_ENTER_CPU_CRITICAL_EXIT();
00001e  f8dfa090          LDR      r10,|L11.176|
000022  4608              MOV      r0,r1
000024  f89a2000          LDRB     r2,[r10,#0]  ; OSSchedLockNestingCtr
000028  1c52              ADDS     r2,r2,#1
00002a  f88a2000          STRB     r2,[r10,#0]
00002e  f7fffffe          BL       CPU_SR_Restore
;;;939        if ((opt & OS_OPT_POST_ALL) != (OS_OPT)0) {             /* Post message to all tasks waiting?                     */
000032  ea5f5088          LSLS     r0,r8,#22
000036  d518              BPL      |L11.106|
;;;940            cnt = p_pend_list->NbrEntries;                      /* Yes                                                    */
000038  893d              LDRH     r5,[r7,#8]
;;;941        } else {
;;;942            cnt = (OS_OBJ_QTY)1;                                /* No                                                     */
;;;943        }
;;;944        p_pend_data = p_pend_list->HeadPtr;
00003a  683f              LDR      r7,[r7,#0]
00003c  e022              B        |L11.132|
                  |L11.62|
00003e  6a25              LDR      r5,[r4,#0x20]         ;920
000040  1c68              ADDS     r0,r5,#1              ;920
000042  d00a              BEQ      |L11.90|
000044  1c6d              ADDS     r5,r5,#1              ;930
000046  e9c45908          STRD     r5,r9,[r4,#0x20]      ;930
00004a  4608              MOV      r0,r1                 ;933
00004c  f7fffffe          BL       CPU_SR_Restore
000050  f8a6b000          STRH     r11,[r6,#0]           ;934
000054  4628              MOV      r0,r5                 ;935
                  |L11.86|
;;;945        while (cnt > 0u) {
;;;946            p_tcb            = p_pend_data->TCBPtr;
;;;947            p_pend_data_next = p_pend_data->NextPtr;
;;;948            OS_Post((OS_PEND_OBJ *)((void *)p_sem),
;;;949                    p_tcb,
;;;950                    (void      *)0,
;;;951                    (OS_MSG_SIZE)0,
;;;952                    ts);
;;;953            p_pend_data = p_pend_data_next;
;;;954            cnt--;
;;;955        }
;;;956        ctr = p_sem->Ctr;
;;;957        OS_CRITICAL_EXIT_NO_SCHED();
;;;958        if ((opt & OS_OPT_POST_NO_SCHED) == (OS_OPT)0) {
;;;959            OSSched();                                          /* Run the scheduler                                      */
;;;960        }
;;;961       *p_err = OS_ERR_NONE;
;;;962        return (ctr);
;;;963    }
000056  e8bd8ff8          POP      {r3-r11,pc}
                  |L11.90|
00005a  4608              MOV      r0,r1                 ;921
00005c  f7fffffe          BL       CPU_SR_Restore
000060  f64650c5          MOV      r0,#0x6dc5            ;922
000064  8030              STRH     r0,[r6,#0]            ;922
000066  2000              MOVS     r0,#0                 ;923
000068  e7f5              B        |L11.86|
                  |L11.106|
00006a  683f              LDR      r7,[r7,#0]            ;944
00006c  2501              MOVS     r5,#1                 ;942
                  |L11.110|
00006e  2300              MOVS     r3,#0                 ;948
000070  68b9              LDR      r1,[r7,#8]            ;947
000072  687f              LDR      r7,[r7,#4]            ;947
000074  461a              MOV      r2,r3                 ;948
000076  4620              MOV      r0,r4                 ;948
000078  f8cd9000          STR      r9,[sp,#0]            ;948
00007c  f7fffffe          BL       OS_Post
000080  1e6d              SUBS     r5,r5,#1              ;954
000082  b2ad              UXTH     r5,r5                 ;954
                  |L11.132|
000084  2d00              CMP      r5,#0                 ;945
000086  d1f2              BNE      |L11.110|
000088  6a24              LDR      r4,[r4,#0x20]         ;956
00008a  f7fffffe          BL       CPU_SR_Save
00008e  f89a2000          LDRB     r2,[r10,#0]           ;957  ; OSSchedLockNestingCtr
000092  1e52              SUBS     r2,r2,#1              ;957
000094  f88a2000          STRB     r2,[r10,#0]           ;957
000098  f7fffffe          BL       CPU_SR_Restore
00009c  ea5f4008          LSLS     r0,r8,#16             ;958
0000a0  d401              BMI      |L11.166|
0000a2  f7fffffe          BL       OSSched
                  |L11.166|
0000a6  f8a6b000          STRH     r11,[r6,#0]           ;961
0000aa  4620              MOV      r0,r4                 ;962
0000ac  e7d3              B        |L11.86|
;;;964    
                          ENDP

0000ae  0000              DCW      0x0000
                  |L11.176|
                          DCD      OSSchedLockNestingCtr

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

000000  3f53454d          DCB      0x3f,0x53,0x45,0x4d
000004  00                DCB      0x00
