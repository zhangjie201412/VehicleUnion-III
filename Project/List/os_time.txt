; generated by ARM C/C++ Compiler, 5.02 [Build 28]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\OBJ\os_time.o --asm_dir=.\List\ --list_dir=.\List\ --depend=..\OBJ\os_time.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\BSP -I..\CORE -I..\STM32F10x_FWLib\inc -I..\USER -I..\UCOSIII\uC-CPU -I..\UCOSIII\uC-CPU\ARM-Cortex-M3\RealView -I..\UCOSIII\uC-LIB -I..\UCOSIII\uC-LIB\Ports\ARM-Cortex-M3\RealView -I..\UCOSIII\uCOS-III -I..\UCOSIII\uCOS-III\Ports -I..\UCOSIII\uCOS-III\Ports\ARM-Cortex-M3\Generic\RealView -I..\UCOSIII\uCOS-III\Source -I..\UCOSIII\UCOS_BSP -I..\UCOSIII\uCOS_CONFIG -I..\UCOSIII-Task -I..\SYSTEM -I..\BSP\inc -I..\PAL -I..\PAL\vehicles -ID:\Keil_v4\ARM\RV31\INC -ID:\Keil_v4\ARM\CMSIS\Include -ID:\Keil_v4\ARM\Inc\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=..\OBJ\os_time.crf ..\UCOSIII\uCOS-III\Source\os_time.c]
                          THUMB

                          AREA ||i.OSTimeDly||, CODE, READONLY, ALIGN=2

                  OSTimeDly PROC
;;;79     
;;;80     void  OSTimeDly (OS_TICK   dly,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;81                      OS_OPT    opt,
;;;82                      OS_ERR   *p_err)
;;;83     {
000004  4606              MOV      r6,r0
;;;84         CPU_SR_ALLOC();
;;;85     
;;;86     
;;;87     
;;;88     #ifdef OS_SAFETY_CRITICAL
;;;89         if (p_err == (OS_ERR *)0) {
;;;90             OS_SAFETY_CRITICAL_EXCEPTION();
;;;91             return;
;;;92         }
;;;93     #endif
;;;94     
;;;95     #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;96         if (OSIntNestingCtr > (OS_NESTING_CTR)0u) {             /* Not allowed to call from an ISR                        */
000006  4825              LDR      r0,|L1.156|
000008  4688              MOV      r8,r1                 ;83
00000a  4615              MOV      r5,r2                 ;83
00000c  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
00000e  b110              CBZ      r0,|L1.22|
;;;97            *p_err = OS_ERR_TIME_DLY_ISR;
000010  f2472075          MOV      r0,#0x7275
;;;98             return;
000014  e02f              B        |L1.118|
                  |L1.22|
;;;99         }
;;;100    #endif
;;;101    
;;;102        if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0u) {       /* Can't delay when the scheduler is locked               */
000016  4c22              LDR      r4,|L1.160|
000018  7820              LDRB     r0,[r4,#0]  ; OSSchedLockNestingCtr
00001a  b110              CBZ      r0,|L1.34|
;;;103           *p_err = OS_ERR_SCHED_LOCKED;
00001c  f6465063          MOV      r0,#0x6d63
;;;104            return;
000020  e029              B        |L1.118|
                  |L1.34|
;;;105        }
;;;106    
;;;107        switch (opt) {
000022  0008              MOVS     r0,r1
000024  d008              BEQ      |L1.56|
000026  2802              CMP      r0,#2
000028  d006              BEQ      |L1.56|
00002a  2804              CMP      r0,#4
00002c  d005              BEQ      |L1.58|
00002e  2908              CMP      r1,#8
000030  d002              BEQ      |L1.56|
;;;108            case OS_OPT_TIME_DLY:
;;;109            case OS_OPT_TIME_TIMEOUT:
;;;110            case OS_OPT_TIME_PERIODIC:
;;;111                 if (dly == (OS_TICK)0u) {                      /* 0 means no delay!                                      */
;;;112                    *p_err = OS_ERR_TIME_ZERO_DLY;
;;;113                     return;
;;;114                 }
;;;115                 break;
;;;116    
;;;117            case OS_OPT_TIME_MATCH:
;;;118                 break;
;;;119    
;;;120            default:
;;;121                *p_err = OS_ERR_OPT_INVALID;
000032  f6456025          MOV      r0,#0x5e25
;;;122                 return;
000036  e01e              B        |L1.118|
                  |L1.56|
000038  b1de              CBZ      r6,|L1.114|
                  |L1.58|
;;;123        }
;;;124    
;;;125        OS_CRITICAL_ENTER();
00003a  f7fffffe          BL       CPU_SR_Save
00003e  7821              LDRB     r1,[r4,#0]  ; OSSchedLockNestingCtr
000040  1c49              ADDS     r1,r1,#1
000042  7021              STRB     r1,[r4,#0]
000044  f7fffffe          BL       CPU_SR_Restore
;;;126        OSTCBCurPtr->TaskState = OS_TASK_STATE_DLY;
000048  4f16              LDR      r7,|L1.164|
00004a  2101              MOVS     r1,#1
;;;127        OS_TickListInsert(OSTCBCurPtr,
00004c  462b              MOV      r3,r5
00004e  6838              LDR      r0,[r7,#0]            ;126  ; OSTCBCurPtr
000050  4642              MOV      r2,r8
000052  f8801036          STRB     r1,[r0,#0x36]         ;126
000056  4631              MOV      r1,r6
000058  f7fffffe          BL       OS_TickListInsert
;;;128                          dly,
;;;129                          opt,
;;;130                          p_err);
;;;131        if (*p_err != OS_ERR_NONE) {
00005c  8828              LDRH     r0,[r5,#0]
00005e  b168              CBZ      r0,|L1.124|
;;;132             OS_CRITICAL_EXIT_NO_SCHED();
000060  f7fffffe          BL       CPU_SR_Save
000064  7821              LDRB     r1,[r4,#0]  ; OSSchedLockNestingCtr
000066  1e49              SUBS     r1,r1,#1
000068  7021              STRB     r1,[r4,#0]
00006a  e8bd41f0          POP      {r4-r8,lr}
00006e  f7ffbffe          B.W      CPU_SR_Restore
                  |L1.114|
000072  f247207e          MOV      r0,#0x727e            ;112
                  |L1.118|
000076  8010              STRH     r0,[r2,#0]            ;121
                  |L1.120|
;;;133             return;
;;;134        }
;;;135        OS_RdyListRemove(OSTCBCurPtr);                          /* Remove current task from ready list                    */
;;;136        OS_CRITICAL_EXIT_NO_SCHED();
;;;137        OSSched();                                              /* Find next task to run!                                 */
;;;138       *p_err = OS_ERR_NONE;
;;;139    }
000078  e8bd81f0          POP      {r4-r8,pc}
                  |L1.124|
00007c  6838              LDR      r0,[r7,#0]            ;135  ; OSTCBCurPtr
00007e  f7fffffe          BL       OS_RdyListRemove
000082  f7fffffe          BL       CPU_SR_Save
000086  7821              LDRB     r1,[r4,#0]            ;136  ; OSSchedLockNestingCtr
000088  1e49              SUBS     r1,r1,#1              ;136
00008a  7021              STRB     r1,[r4,#0]            ;136
00008c  f7fffffe          BL       CPU_SR_Restore
000090  f7fffffe          BL       OSSched
000094  2000              MOVS     r0,#0                 ;138
000096  8028              STRH     r0,[r5,#0]            ;138
000098  e7ee              B        |L1.120|
;;;140    
                          ENDP

00009a  0000              DCW      0x0000
                  |L1.156|
                          DCD      OSIntNestingCtr
                  |L1.160|
                          DCD      OSSchedLockNestingCtr
                  |L1.164|
                          DCD      OSTCBCurPtr

                          AREA ||i.OSTimeDlyHMSM||, CODE, READONLY, ALIGN=2

                  OSTimeDlyHMSM PROC
;;;199    #if OS_CFG_TIME_DLY_HMSM_EN > 0u
;;;200    void  OSTimeDlyHMSM (CPU_INT16U   hours,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;201                         CPU_INT16U   minutes,
;;;202                         CPU_INT16U   seconds,
;;;203                         CPU_INT32U   milli,
;;;204                         OS_OPT       opt,
;;;205                         OS_ERR      *p_err)
;;;206    {
;;;207    #if OS_CFG_ARG_CHK_EN > 0u
;;;208        CPU_BOOLEAN  opt_invalid;
;;;209        CPU_BOOLEAN  opt_non_strict;
;;;210    #endif
;;;211        OS_OPT       opt_time;
;;;212        OS_RATE_HZ   tick_rate;
;;;213        OS_TICK      ticks;
;;;214        CPU_SR_ALLOC();
;;;215    
;;;216    
;;;217    
;;;218    #ifdef OS_SAFETY_CRITICAL
;;;219        if (p_err == (OS_ERR *)0) {
;;;220            OS_SAFETY_CRITICAL_EXCEPTION();
;;;221            return;
;;;222        }
;;;223    #endif
;;;224    
;;;225    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;226        if (OSIntNestingCtr > (OS_NESTING_CTR)0u) {             /* Not allowed to call from an ISR                        */
000004  4e4b              LDR      r6,|L2.308|
000006  e9dd5408          LDRD     r5,r4,[sp,#0x20]      ;206
00000a  7836              LDRB     r6,[r6,#0]  ; OSIntNestingCtr
00000c  b116              CBZ      r6,|L2.20|
;;;227           *p_err = OS_ERR_TIME_DLY_ISR;
00000e  f2472075          MOV      r0,#0x7275
;;;228            return;
000012  e088              B        |L2.294|
                  |L2.20|
;;;229        }
;;;230    #endif
;;;231    
;;;232        if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0u) {       /* Can't delay when the scheduler is locked               */
000014  f8dfa120          LDR      r10,|L2.312|
000018  f89a6000          LDRB     r6,[r10,#0]  ; OSSchedLockNestingCtr
00001c  b116              CBZ      r6,|L2.36|
;;;233           *p_err = OS_ERR_SCHED_LOCKED;
00001e  f6465063          MOV      r0,#0x6d63
;;;234            return;
000022  e080              B        |L2.294|
                  |L2.36|
;;;235        }
;;;236    
;;;237        opt_time = opt & OS_OPT_TIME_MASK;                      /* Retrieve time options only.                            */
000024  f015060e          ANDS     r6,r5,#0xe
;;;238        switch (opt_time) {
;;;239            case OS_OPT_TIME_DLY:
;;;240            case OS_OPT_TIME_TIMEOUT:
;;;241            case OS_OPT_TIME_PERIODIC:
;;;242                 if (milli == (CPU_INT32U)0u) {                 /* Make sure we didn't specify a 0 delay                  */
;;;243                     if (seconds == (CPU_INT16U)0u) {
;;;244                         if (minutes == (CPU_INT16U)0u) {
;;;245                             if (hours == (CPU_INT16U)0u) {
;;;246                                *p_err = OS_ERR_TIME_ZERO_DLY;
000028  f247297e          MOV      r9,#0x727e
;;;247                                 return;
;;;248                             }
;;;249                         }
;;;250                     }
;;;251                 }
;;;252                 break;
;;;253    
;;;254            case OS_OPT_TIME_MATCH:
;;;255                 break;
;;;256    
;;;257            default:
;;;258                *p_err = OS_ERR_OPT_INVALID;
00002c  f6456725          MOV      r7,#0x5e25
000030  d005              BEQ      |L2.62|
000032  2e02              CMP      r6,#2                 ;238
000034  d003              BEQ      |L2.62|
000036  2e04              CMP      r6,#4                 ;238
000038  d005              BEQ      |L2.70|
00003a  2e08              CMP      r6,#8                 ;238
00003c  d106              BNE      |L2.76|
                  |L2.62|
00003e  b913              CBNZ     r3,|L2.70|
000040  b90a              CBNZ     r2,|L2.70|
000042  b901              CBNZ     r1,|L2.70|
000044  b3f0              CBZ      r0,|L2.196|
                  |L2.70|
;;;259                 return;
;;;260        }
;;;261    
;;;262    #if OS_CFG_ARG_CHK_EN > 0u                                  /* Validate arguments to be within range                  */
;;;263        opt_invalid = DEF_BIT_IS_SET_ANY(opt, ~OS_OPT_TIME_OPTS_MASK);
000046  f0350c1e          BICS     r12,r5,#0x1e
00004a  d002              BEQ      |L2.82|
                  |L2.76|
;;;264        if (opt_invalid == DEF_YES) {
;;;265           *p_err = OS_ERR_OPT_INVALID;
00004c  8027              STRH     r7,[r4,#0]
                  |L2.78|
;;;266            return;
;;;267        }
;;;268    
;;;269        opt_non_strict = DEF_BIT_IS_SET(opt, OS_OPT_TIME_HMSM_NON_STRICT);
;;;270        if (opt_non_strict != DEF_YES) {
;;;271             if (milli   > (CPU_INT32U)999u) {
;;;272                *p_err = OS_ERR_TIME_INVALID_MILLISECONDS;
;;;273                 return;
;;;274             }
;;;275             if (seconds > (CPU_INT16U)59u) {
;;;276                *p_err = OS_ERR_TIME_INVALID_SECONDS;
;;;277                 return;
;;;278             }
;;;279             if (minutes > (CPU_INT16U)59u) {
;;;280                *p_err = OS_ERR_TIME_INVALID_MINUTES;
;;;281                 return;
;;;282             }
;;;283             if (hours   > (CPU_INT16U)99u) {
;;;284                *p_err = OS_ERR_TIME_INVALID_HOURS;
;;;285                 return;
;;;286             }
;;;287        } else {
;;;288             if (minutes > (CPU_INT16U)9999u) {
;;;289                *p_err = OS_ERR_TIME_INVALID_MINUTES;
;;;290                 return;
;;;291             }
;;;292             if (hours   > (CPU_INT16U)999u) {
;;;293                *p_err = OS_ERR_TIME_INVALID_HOURS;
;;;294                 return;
;;;295             }
;;;296        }
;;;297    #endif
;;;298    
;;;299                                                                /* Compute the total number of clock ticks required..     */
;;;300                                                                /* .. (rounded to the nearest tick)                       */
;;;301        tick_rate = OSCfg_TickRate_Hz;
;;;302        ticks     = ((OS_TICK)hours * (OS_TICK)3600u + (OS_TICK)minutes * (OS_TICK)60u + (OS_TICK)seconds) * tick_rate
;;;303                  + (tick_rate * ((OS_TICK)milli + (OS_TICK)500u / tick_rate)) / (OS_TICK)1000u;
;;;304    
;;;305        if (ticks > (OS_TICK)0u) {
;;;306            OS_CRITICAL_ENTER();
;;;307            OSTCBCurPtr->TaskState = OS_TASK_STATE_DLY;
;;;308            OS_TickListInsert(OSTCBCurPtr,
;;;309                              ticks,
;;;310                              opt_time,
;;;311                              p_err);
;;;312            if (*p_err != OS_ERR_NONE) {
;;;313                 OS_CRITICAL_EXIT_NO_SCHED();
;;;314                 return;
;;;315            }
;;;316            OS_RdyListRemove(OSTCBCurPtr);                      /* Remove current task from ready list                    */
;;;317            OS_CRITICAL_EXIT_NO_SCHED();
;;;318            OSSched();                                          /* Find next task to run!                                 */
;;;319           *p_err = OS_ERR_NONE;
;;;320        } else {
;;;321           *p_err = OS_ERR_TIME_ZERO_DLY;
;;;322        }
;;;323    }
00004e  e8bd87f0          POP      {r4-r10,pc}
                  |L2.82|
000052  f3c51500          UBFX     r5,r5,#4,#1           ;269
000056  f2472c79          MOV      r12,#0x7279           ;280
00005a  f2472878          MOV      r8,#0x7278            ;284
00005e  f44f777a          MOV      r7,#0x3e8             ;271
000062  b135              CBZ      r5,|L2.114|
000064  f242750f          MOV      r5,#0x270f            ;288
000068  42a9              CMP      r1,r5                 ;288
00006a  d911              BLS      |L2.144|
                  |L2.108|
00006c  f8a4c000          STRH     r12,[r4,#0]           ;289
000070  e7ed              B        |L2.78|
                  |L2.114|
000072  42bb              CMP      r3,r7                 ;271
000074  d302              BCC      |L2.124|
000076  f247207b          MOV      r0,#0x727b            ;272
00007a  e054              B        |L2.294|
                  |L2.124|
00007c  2a3b              CMP      r2,#0x3b              ;275
00007e  d902              BLS      |L2.134|
000080  f247207a          MOV      r0,#0x727a            ;276
000084  e04f              B        |L2.294|
                  |L2.134|
000086  293b              CMP      r1,#0x3b              ;279
000088  d8f0              BHI      |L2.108|
00008a  2863              CMP      r0,#0x63              ;283
00008c  d802              BHI      |L2.148|
00008e  e004              B        |L2.154|
                  |L2.144|
000090  42b8              CMP      r0,r7                 ;292
000092  d302              BCC      |L2.154|
                  |L2.148|
000094  f8a48000          STRH     r8,[r4,#0]            ;293
000098  e7d9              B        |L2.78|
                  |L2.154|
00009a  4d28              LDR      r5,|L2.316|
00009c  f44f7cfa          MOV      r12,#0x1f4            ;302
0000a0  ebc11101          RSB      r1,r1,r1,LSL #4       ;302
0000a4  682d              LDR      r5,[r5,#0]            ;301  ; OSCfg_TickRate_Hz
0000a6  fbbcfcf5          UDIV     r12,r12,r5            ;302
0000aa  4463              ADD      r3,r3,r12             ;302
0000ac  436b              MULS     r3,r5,r3              ;302
0000ae  fbb3f3f7          UDIV     r3,r3,r7              ;302
0000b2  f44f6761          MOV      r7,#0xe10             ;302
0000b6  4378              MULS     r0,r7,r0              ;302
0000b8  eb000081          ADD      r0,r0,r1,LSL #2       ;302
0000bc  4410              ADD      r0,r0,r2              ;302
0000be  fb003705          MLA      r7,r0,r5,r3           ;302
0000c2  e000              B        |L2.198|
                  |L2.196|
0000c4  e031              B        |L2.298|
                  |L2.198|
0000c6  b387              CBZ      r7,|L2.298|
0000c8  f7fffffe          BL       CPU_SR_Save
0000cc  f89a1000          LDRB     r1,[r10,#0]           ;306  ; OSSchedLockNestingCtr
0000d0  4655              MOV      r5,r10                ;306
0000d2  1c49              ADDS     r1,r1,#1              ;306
0000d4  f88a1000          STRB     r1,[r10,#0]           ;306
0000d8  f7fffffe          BL       CPU_SR_Restore
0000dc  f8df8060          LDR      r8,|L2.320|
0000e0  2101              MOVS     r1,#1                 ;307
0000e2  4623              MOV      r3,r4                 ;308
0000e4  f8d80000          LDR      r0,[r8,#0]            ;307  ; OSTCBCurPtr
0000e8  4632              MOV      r2,r6                 ;308
0000ea  f8801036          STRB     r1,[r0,#0x36]         ;307
0000ee  4639              MOV      r1,r7                 ;308
0000f0  f7fffffe          BL       OS_TickListInsert
0000f4  8820              LDRH     r0,[r4,#0]            ;312
0000f6  b140              CBZ      r0,|L2.266|
0000f8  f7fffffe          BL       CPU_SR_Save
0000fc  7829              LDRB     r1,[r5,#0]            ;313  ; OSSchedLockNestingCtr
0000fe  1e49              SUBS     r1,r1,#1              ;313
000100  7029              STRB     r1,[r5,#0]            ;313
000102  e8bd47f0          POP      {r4-r10,lr}           ;313
000106  f7ffbffe          B.W      CPU_SR_Restore
                  |L2.266|
00010a  f8d80000          LDR      r0,[r8,#0]            ;316  ; OSTCBCurPtr
00010e  f7fffffe          BL       OS_RdyListRemove
000112  f7fffffe          BL       CPU_SR_Save
000116  7829              LDRB     r1,[r5,#0]            ;317  ; OSSchedLockNestingCtr
000118  1e49              SUBS     r1,r1,#1              ;317
00011a  7029              STRB     r1,[r5,#0]            ;317
00011c  f7fffffe          BL       CPU_SR_Restore
000120  f7fffffe          BL       OSSched
000124  2000              MOVS     r0,#0                 ;319
                  |L2.294|
000126  8020              STRH     r0,[r4,#0]            ;319
000128  e791              B        |L2.78|
                  |L2.298|
00012a  e7ff              B        |L2.300|
                  |L2.300|
00012c  f8a49000          STRH     r9,[r4,#0]            ;321
000130  e78d              B        |L2.78|
;;;324    #endif
                          ENDP

000132  0000              DCW      0x0000
                  |L2.308|
                          DCD      OSIntNestingCtr
                  |L2.312|
                          DCD      OSSchedLockNestingCtr
                  |L2.316|
                          DCD      OSCfg_TickRate_Hz
                  |L2.320|
                          DCD      OSTCBCurPtr

                          AREA ||i.OSTimeDlyResume||, CODE, READONLY, ALIGN=2

                  OSTimeDlyResume PROC
;;;348    #if OS_CFG_TIME_DLY_RESUME_EN > 0u
;;;349    void  OSTimeDlyResume (OS_TCB  *p_tcb,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;350                           OS_ERR  *p_err)
;;;351    {
000004  4606              MOV      r6,r0
;;;352        CPU_SR_ALLOC();
;;;353    
;;;354    
;;;355    
;;;356    #ifdef OS_SAFETY_CRITICAL
;;;357        if (p_err == (OS_ERR *)0) {
;;;358            OS_SAFETY_CRITICAL_EXCEPTION();
;;;359            return;
;;;360        }
;;;361    #endif
;;;362    
;;;363    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;364        if (OSIntNestingCtr > (OS_NESTING_CTR)0u) {             /* Not allowed to call from an ISR                        */
000006  482d              LDR      r0,|L3.188|
000008  460c              MOV      r4,r1                 ;351
00000a  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
00000c  b120              CBZ      r0,|L3.24|
;;;365           *p_err = OS_ERR_TIME_DLY_RESUME_ISR;
00000e  f2472076          MOV      r0,#0x7276
000012  8008              STRH     r0,[r1,#0]
                  |L3.20|
;;;366            return;
;;;367        }
;;;368    #endif
;;;369    
;;;370    #if OS_CFG_ARG_CHK_EN > 0u
;;;371        if (p_tcb == (OS_TCB *)0) {                             /* Not possible for the running task to be delayed!       */
;;;372           *p_err = OS_ERR_TASK_NOT_DLY;
;;;373            return;
;;;374        }
;;;375    #endif
;;;376    
;;;377        CPU_CRITICAL_ENTER();
;;;378        if (p_tcb == OSTCBCurPtr) {                             /* Not possible for the running task to be delayed!       */
;;;379           *p_err = OS_ERR_TASK_NOT_DLY;
;;;380            CPU_CRITICAL_EXIT();
;;;381            return;
;;;382        }
;;;383    
;;;384        switch (p_tcb->TaskState) {
;;;385            case OS_TASK_STATE_RDY:                             /* Cannot Abort delay if task is ready                    */
;;;386                 CPU_CRITICAL_EXIT();
;;;387                *p_err = OS_ERR_TASK_NOT_DLY;
;;;388                 break;
;;;389    
;;;390            case OS_TASK_STATE_DLY:
;;;391                 OS_CRITICAL_ENTER_CPU_CRITICAL_EXIT();
;;;392                 p_tcb->TaskState = OS_TASK_STATE_RDY;
;;;393                 OS_TickListRemove(p_tcb);                      /* Remove task from tick list                             */
;;;394                 OS_RdyListInsert(p_tcb);                       /* Add to ready list                                      */
;;;395                 OS_CRITICAL_EXIT_NO_SCHED();
;;;396                *p_err = OS_ERR_NONE;
;;;397                 break;
;;;398    
;;;399            case OS_TASK_STATE_PEND:
;;;400                 CPU_CRITICAL_EXIT();
;;;401                *p_err = OS_ERR_TASK_NOT_DLY;
;;;402                 break;
;;;403    
;;;404            case OS_TASK_STATE_PEND_TIMEOUT:
;;;405                 CPU_CRITICAL_EXIT();
;;;406                *p_err = OS_ERR_TASK_NOT_DLY;
;;;407                 break;
;;;408    
;;;409            case OS_TASK_STATE_SUSPENDED:
;;;410                 CPU_CRITICAL_EXIT();
;;;411                *p_err = OS_ERR_TASK_NOT_DLY;
;;;412                 break;
;;;413    
;;;414            case OS_TASK_STATE_DLY_SUSPENDED:
;;;415                 OS_CRITICAL_ENTER_CPU_CRITICAL_EXIT();
;;;416                 p_tcb->TaskState = OS_TASK_STATE_SUSPENDED;
;;;417                 OS_TickListRemove(p_tcb);                      /* Remove task from tick list                             */
;;;418                 OS_CRITICAL_EXIT_NO_SCHED();
;;;419                *p_err            = OS_ERR_TASK_SUSPENDED;
;;;420                 break;
;;;421    
;;;422            case OS_TASK_STATE_PEND_SUSPENDED:
;;;423                 CPU_CRITICAL_EXIT();
;;;424                *p_err = OS_ERR_TASK_NOT_DLY;
;;;425                 break;
;;;426    
;;;427            case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
;;;428                 CPU_CRITICAL_EXIT();
;;;429                *p_err = OS_ERR_TASK_NOT_DLY;
;;;430                 break;
;;;431    
;;;432            default:
;;;433                 CPU_CRITICAL_EXIT();
;;;434                *p_err = OS_ERR_STATE_INVALID;
;;;435                 break;
;;;436        }
;;;437    
;;;438        OSSched();
;;;439    }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L3.24|
000018  f2471551          MOV      r5,#0x7151            ;372
00001c  b156              CBZ      r6,|L3.52|
00001e  f7fffffe          BL       CPU_SR_Save
000022  4927              LDR      r1,|L3.192|
000024  6809              LDR      r1,[r1,#0]            ;378  ; OSTCBCurPtr
000026  428e              CMP      r6,r1                 ;378
000028  d106              BNE      |L3.56|
00002a  8025              STRH     r5,[r4,#0]            ;379
00002c  e8bd41f0          POP      {r4-r8,lr}            ;380
000030  f7ffbffe          B.W      CPU_SR_Restore
                  |L3.52|
000034  800d              STRH     r5,[r1,#0]            ;372
000036  e7ed              B        |L3.20|
                  |L3.56|
000038  f8961036          LDRB     r1,[r6,#0x36]         ;384
00003c  4f21              LDR      r7,|L3.196|
00003e  2908              CMP      r1,#8                 ;384
000040  d236              BCS      |L3.176|
000042  e8dff001          TBB      [pc,r1]               ;384
000046  0408              DCB      0x04,0x08
000048  0404041c          DCB      0x04,0x04,0x04,0x1c
00004c  0404              DCB      0x04,0x04
                  |L3.78|
00004e  f7fffffe          BL       CPU_SR_Restore
000052  8025              STRH     r5,[r4,#0]            ;387
000054  e028              B        |L3.168|
000056  7839              LDRB     r1,[r7,#0]            ;391  ; OSSchedLockNestingCtr
000058  1c49              ADDS     r1,r1,#1              ;391
00005a  7039              STRB     r1,[r7,#0]            ;391
00005c  f7fffffe          BL       CPU_SR_Restore
000060  2500              MOVS     r5,#0                 ;392
000062  f8865036          STRB     r5,[r6,#0x36]         ;392
000066  4630              MOV      r0,r6                 ;393
000068  f7fffffe          BL       OS_TickListRemove
00006c  4630              MOV      r0,r6                 ;394
00006e  f7fffffe          BL       OS_RdyListInsert
000072  f7fffffe          BL       CPU_SR_Save
000076  7839              LDRB     r1,[r7,#0]            ;395  ; OSSchedLockNestingCtr
000078  1e49              SUBS     r1,r1,#1              ;395
00007a  7039              STRB     r1,[r7,#0]            ;395
00007c  e7e7              B        |L3.78|
00007e  7839              LDRB     r1,[r7,#0]            ;415  ; OSSchedLockNestingCtr
000080  1c49              ADDS     r1,r1,#1              ;415
000082  7039              STRB     r1,[r7,#0]            ;415
000084  f7fffffe          BL       CPU_SR_Restore
000088  2004              MOVS     r0,#4                 ;416
00008a  f8860036          STRB     r0,[r6,#0x36]         ;416
00008e  4630              MOV      r0,r6                 ;417
000090  f7fffffe          BL       OS_TickListRemove
000094  f7fffffe          BL       CPU_SR_Save
000098  7839              LDRB     r1,[r7,#0]            ;418  ; OSSchedLockNestingCtr
00009a  1e49              SUBS     r1,r1,#1              ;418
00009c  7039              STRB     r1,[r7,#0]            ;418
00009e  f7fffffe          BL       CPU_SR_Restore
0000a2  f247105a          MOV      r0,#0x715a            ;419
                  |L3.166|
0000a6  8020              STRH     r0,[r4,#0]            ;419
                  |L3.168|
0000a8  e8bd41f0          POP      {r4-r8,lr}            ;438
0000ac  f7ffbffe          B.W      OSSched
                  |L3.176|
0000b0  f7fffffe          BL       CPU_SR_Restore
0000b4  f646602d          MOV      r0,#0x6e2d            ;434
0000b8  e7f5              B        |L3.166|
;;;440    #endif
                          ENDP

0000ba  0000              DCW      0x0000
                  |L3.188|
                          DCD      OSIntNestingCtr
                  |L3.192|
                          DCD      OSTCBCurPtr
                  |L3.196|
                          DCD      OSSchedLockNestingCtr

                          AREA ||i.OSTimeGet||, CODE, READONLY, ALIGN=2

                  OSTimeGet PROC
;;;456    
;;;457    OS_TICK  OSTimeGet (OS_ERR  *p_err)
000000  b570              PUSH     {r4-r6,lr}
;;;458    {
000002  4605              MOV      r5,r0
;;;459        OS_TICK  ticks;
;;;460        CPU_SR_ALLOC();
;;;461    
;;;462    
;;;463    
;;;464    #ifdef OS_SAFETY_CRITICAL
;;;465        if (p_err == (OS_ERR *)0) {
;;;466            OS_SAFETY_CRITICAL_EXCEPTION();
;;;467            return ((OS_TICK)0);
;;;468        }
;;;469    #endif
;;;470    
;;;471        CPU_CRITICAL_ENTER();
000004  f7fffffe          BL       CPU_SR_Save
;;;472        ticks = OSTickCtr;
000008  4903              LDR      r1,|L4.24|
;;;473        CPU_CRITICAL_EXIT();
00000a  680c              LDR      r4,[r1,#0]  ; OSTickCtr
00000c  f7fffffe          BL       CPU_SR_Restore
;;;474       *p_err = OS_ERR_NONE;
000010  2000              MOVS     r0,#0
000012  8028              STRH     r0,[r5,#0]
;;;475        return (ticks);
000014  4620              MOV      r0,r4
;;;476    }
000016  bd70              POP      {r4-r6,pc}
;;;477    
                          ENDP

                  |L4.24|
                          DCD      OSTickCtr

                          AREA ||i.OSTimeSet||, CODE, READONLY, ALIGN=2

                  OSTimeSet PROC
;;;493    
;;;494    void  OSTimeSet (OS_TICK   ticks,
000000  b570              PUSH     {r4-r6,lr}
;;;495                     OS_ERR   *p_err)
;;;496    {
000002  460c              MOV      r4,r1
000004  4605              MOV      r5,r0
;;;497        CPU_SR_ALLOC();
;;;498    
;;;499    
;;;500    
;;;501    #ifdef OS_SAFETY_CRITICAL
;;;502        if (p_err == (OS_ERR *)0) {
;;;503            OS_SAFETY_CRITICAL_EXCEPTION();
;;;504            return;
;;;505        }
;;;506    #endif
;;;507    
;;;508        CPU_CRITICAL_ENTER();
000006  f7fffffe          BL       CPU_SR_Save
;;;509        OSTickCtr = ticks;
00000a  4903              LDR      r1,|L5.24|
;;;510        CPU_CRITICAL_EXIT();
00000c  600d              STR      r5,[r1,#0]  ; OSTickCtr
00000e  f7fffffe          BL       CPU_SR_Restore
;;;511       *p_err     = OS_ERR_NONE;
000012  2000              MOVS     r0,#0
000014  8020              STRH     r0,[r4,#0]
;;;512    }
000016  bd70              POP      {r4-r6,pc}
;;;513    
                          ENDP

                  |L5.24|
                          DCD      OSTickCtr

                          AREA ||i.OSTimeTick||, CODE, READONLY, ALIGN=2

                  OSTimeTick PROC
;;;527    
;;;528    void  OSTimeTick (void)
000000  b500              PUSH     {lr}
;;;529    {
000002  b085              SUB      sp,sp,#0x14
;;;530        OS_ERR  err;
;;;531    #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
;;;532        CPU_TS  ts;
;;;533    #endif
;;;534    
;;;535    
;;;536        OSTimeTickHook();                                       /* Call user definable hook                               */
000004  f7fffffe          BL       OSTimeTickHook
;;;537    
;;;538    #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
;;;539    
;;;540        ts = OS_TS_GET();                                       /* Get timestamp                                          */
000008  f7fffffe          BL       CPU_TS_TmrRd
;;;541        OS_IntQPost((OS_OBJ_TYPE) OS_OBJ_TYPE_TICK,             /* Post to ISR queue                                      */
00000c  aa04              ADD      r2,sp,#0x10
00000e  2100              MOVS     r1,#0
000010  9203              STR      r2,[sp,#0xc]
000012  9100              STR      r1,[sp,#0]
000014  e9cd1001          STRD     r1,r0,[sp,#4]
000018  4806              LDR      r0,|L6.52|
00001a  4907              LDR      r1,|L6.56|
00001c  2300              MOVS     r3,#0
00001e  7800              LDRB     r0,[r0,#0]  ; OSPrioCur
000020  461a              MOV      r2,r3
000022  eb000040          ADD      r0,r0,r0,LSL #1
000026  eb010180          ADD      r1,r1,r0,LSL #2
00002a  4804              LDR      r0,|L6.60|
00002c  f7fffffe          BL       OS_IntQPost
;;;542                    (void      *)&OSRdyList[OSPrioCur],
;;;543                    (void      *) 0,
;;;544                    (OS_MSG_SIZE) 0u,
;;;545                    (OS_FLAGS   ) 0u,
;;;546                    (OS_OPT     ) 0u,
;;;547                    (CPU_TS     ) ts,
;;;548                    (OS_ERR    *)&err);
;;;549    
;;;550    #else
;;;551    
;;;552       (void)OSTaskSemPost((OS_TCB *)&OSTickTaskTCB,            /* Signal tick task                                       */
;;;553                           (OS_OPT  ) OS_OPT_POST_NONE,
;;;554                           (OS_ERR *)&err);
;;;555    
;;;556    
;;;557    #if OS_CFG_SCHED_ROUND_ROBIN_EN > 0u
;;;558        OS_SchedRoundRobin(&OSRdyList[OSPrioCur]);
;;;559    #endif
;;;560    
;;;561    #if OS_CFG_TMR_EN > 0u
;;;562        OSTmrUpdateCtr--;
;;;563        if (OSTmrUpdateCtr == (OS_CTR)0u) {
;;;564            OSTmrUpdateCtr = OSTmrUpdateCnt;
;;;565            OSTaskSemPost((OS_TCB *)&OSTmrTaskTCB,              /* Signal timer task                                      */
;;;566                          (OS_OPT  ) OS_OPT_POST_NONE,
;;;567                          (OS_ERR *)&err);
;;;568        }
;;;569    #endif
;;;570    
;;;571    #endif
;;;572    }
000030  b005              ADD      sp,sp,#0x14
000032  bd00              POP      {pc}
                          ENDP

                  |L6.52|
                          DCD      OSPrioCur
                  |L6.56|
                          DCD      OSRdyList
                  |L6.60|
                          DCD      0x4b434954
