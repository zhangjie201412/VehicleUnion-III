; generated by ARM C/C++ Compiler, 5.02 [Build 28]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\OBJ\os_core.o --asm_dir=.\List\ --list_dir=.\List\ --depend=..\OBJ\os_core.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\BSP -I..\CORE -I..\STM32F10x_FWLib\inc -I..\USER -I..\UCOSIII\uC-CPU -I..\UCOSIII\uC-CPU\ARM-Cortex-M3\RealView -I..\UCOSIII\uC-LIB -I..\UCOSIII\uC-LIB\Ports\ARM-Cortex-M3\RealView -I..\UCOSIII\uCOS-III -I..\UCOSIII\uCOS-III\Ports -I..\UCOSIII\uCOS-III\Ports\ARM-Cortex-M3\Generic\RealView -I..\UCOSIII\uCOS-III\Source -I..\UCOSIII\UCOS_BSP -I..\UCOSIII\uCOS_CONFIG -I..\UCOSIII-Task -I..\SYSTEM -I..\BSP\inc -I..\PAL -I..\PAL\vehicles -ID:\Keil_v4\ARM\RV31\INC -ID:\Keil_v4\ARM\CMSIS\Include -ID:\Keil_v4\ARM\Inc\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=..\OBJ\os_core.crf ..\UCOSIII\uCOS-III\Source\os_core.c]
                          THUMB

                          AREA ||i.OSInit||, CODE, READONLY, ALIGN=2

                  OSInit PROC
;;;54     
;;;55     void  OSInit (OS_ERR  *p_err)
000000  b510              PUSH     {r4,lr}
;;;56     {
000002  4604              MOV      r4,r0
;;;57         CPU_STK      *p_stk;
;;;58         CPU_STK_SIZE  size;
;;;59     
;;;60     
;;;61     
;;;62     #ifdef OS_SAFETY_CRITICAL
;;;63         if (p_err == (OS_ERR *)0) {
;;;64             OS_SAFETY_CRITICAL_EXCEPTION();
;;;65             return;
;;;66         }
;;;67     #endif
;;;68     
;;;69         OSInitHook();                                           /* Call port specific initialization code                 */
000004  f7fffffe          BL       OSInitHook
;;;70     
;;;71         OSIntNestingCtr                 = (OS_NESTING_CTR)0;    /* Clear the interrupt nesting counter                    */
000008  4846              LDR      r0,|L1.292|
00000a  2100              MOVS     r1,#0
;;;72     
;;;73         OSRunning                       =  OS_STATE_OS_STOPPED; /* Indicate that multitasking not started                 */
;;;74     
;;;75         OSSchedLockNestingCtr           = (OS_NESTING_CTR)0;    /* Clear the scheduling lock counter                      */
;;;76     
;;;77         OSTCBCurPtr                     = (OS_TCB *)0;          /* Initialize OS_TCB pointers to a known state            */
;;;78         OSTCBHighRdyPtr                 = (OS_TCB *)0;
;;;79     
;;;80         OSPrioCur                       = (OS_PRIO)0;           /* Initialize priority variables to a known state         */
;;;81         OSPrioHighRdy                   = (OS_PRIO)0;
;;;82         OSPrioSaved                     = (OS_PRIO)0;
;;;83     
;;;84     #if OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u
;;;85         OSSchedLockTimeBegin            = (CPU_TS)0;
;;;86         OSSchedLockTimeMax              = (CPU_TS)0;
;;;87         OSSchedLockTimeMaxCur           = (CPU_TS)0;
;;;88     #endif
;;;89     
;;;90     #ifdef OS_SAFETY_CRITICAL_IEC61508
;;;91         OSSafetyCriticalStartFlag       =  DEF_FALSE;
;;;92     #endif
;;;93     
;;;94     #if OS_CFG_SCHED_ROUND_ROBIN_EN > 0u
;;;95         OSSchedRoundRobinEn             = DEF_FALSE;
;;;96         OSSchedRoundRobinDfltTimeQuanta = OSCfg_TickRate_Hz / 10u;
00000c  220a              MOVS     r2,#0xa
00000e  7001              STRB     r1,[r0,#0]            ;71
000010  4845              LDR      r0,|L1.296|
000012  7001              STRB     r1,[r0,#0]            ;73
000014  4845              LDR      r0,|L1.300|
000016  7001              STRB     r1,[r0,#0]            ;75
000018  4845              LDR      r0,|L1.304|
00001a  6001              STR      r1,[r0,#0]            ;78  ; OSTCBCurPtr
00001c  4845              LDR      r0,|L1.308|
00001e  6001              STR      r1,[r0,#0]            ;80  ; OSTCBHighRdyPtr
000020  4845              LDR      r0,|L1.312|
000022  7001              STRB     r1,[r0,#0]            ;80
000024  4845              LDR      r0,|L1.316|
000026  7001              STRB     r1,[r0,#0]            ;81
000028  4845              LDR      r0,|L1.320|
00002a  7001              STRB     r1,[r0,#0]            ;82
00002c  4845              LDR      r0,|L1.324|
00002e  6001              STR      r1,[r0,#0]            ;86  ; OSSchedLockTimeBegin
000030  4845              LDR      r0,|L1.328|
000032  6001              STR      r1,[r0,#0]            ;87  ; OSSchedLockTimeMax
000034  4845              LDR      r0,|L1.332|
000036  6001              STR      r1,[r0,#0]            ;95  ; OSSchedLockTimeMaxCur
000038  4845              LDR      r0,|L1.336|
00003a  7001              STRB     r1,[r0,#0]            ;95
00003c  4845              LDR      r0,|L1.340|
00003e  6800              LDR      r0,[r0,#0]  ; OSCfg_TickRate_Hz
000040  fbb0f0f2          UDIV     r0,r0,r2
000044  4a44              LDR      r2,|L1.344|
;;;97     #endif
;;;98     
;;;99         if (OSCfg_ISRStkSize > (CPU_STK_SIZE)0) {
000046  6010              STR      r0,[r2,#0]  ; OSSchedRoundRobinDfltTimeQuanta
000048  4a44              LDR      r2,|L1.348|
00004a  6810              LDR      r0,[r2,#0]  ; OSCfg_ISRStkSize
00004c  b130              CBZ      r0,|L1.92|
;;;100            p_stk = OSCfg_ISRStkBasePtr;                        /* Clear exception stack for stack checking.              */
00004e  4844              LDR      r0,|L1.352|
000050  6800              LDR      r0,[r0,#0]  ; OSCfg_ISRStkBasePtr
;;;101            if (p_stk != (CPU_STK *)0) {
000052  b118              CBZ      r0,|L1.92|
;;;102                size  = OSCfg_ISRStkSize;
000054  6812              LDR      r2,[r2,#0]  ; OSCfg_ISRStkSize
                  |L1.86|
;;;103                while (size > (CPU_STK_SIZE)0) {
;;;104                    size--;
;;;105                   *p_stk = (CPU_STK)0;
000056  c002              STM      r0!,{r1}
000058  1e52              SUBS     r2,r2,#1              ;104
;;;106                    p_stk++;
00005a  d1fc              BNE      |L1.86|
                  |L1.92|
;;;107                }
;;;108            }
;;;109        }
;;;110    
;;;111    #if OS_CFG_APP_HOOKS_EN > 0u
;;;112        OS_AppTaskCreateHookPtr = (OS_APP_HOOK_TCB )0;          /* Clear application hook pointers                        */
00005c  4841              LDR      r0,|L1.356|
;;;113        OS_AppTaskDelHookPtr    = (OS_APP_HOOK_TCB )0;
00005e  6001              STR      r1,[r0,#0]  ; OS_AppTaskCreateHookPtr
000060  4841              LDR      r0,|L1.360|
;;;114        OS_AppTaskReturnHookPtr = (OS_APP_HOOK_TCB )0;
000062  6001              STR      r1,[r0,#0]  ; OS_AppTaskDelHookPtr
000064  4841              LDR      r0,|L1.364|
;;;115    
;;;116        OS_AppIdleTaskHookPtr   = (OS_APP_HOOK_VOID)0;
000066  6001              STR      r1,[r0,#0]  ; OS_AppTaskReturnHookPtr
000068  4841              LDR      r0,|L1.368|
;;;117        OS_AppStatTaskHookPtr   = (OS_APP_HOOK_VOID)0;
00006a  6001              STR      r1,[r0,#0]  ; OS_AppIdleTaskHookPtr
00006c  4841              LDR      r0,|L1.372|
;;;118        OS_AppTaskSwHookPtr     = (OS_APP_HOOK_VOID)0;
00006e  6001              STR      r1,[r0,#0]  ; OS_AppStatTaskHookPtr
000070  4841              LDR      r0,|L1.376|
;;;119        OS_AppTimeTickHookPtr   = (OS_APP_HOOK_VOID)0;
000072  6001              STR      r1,[r0,#0]  ; OS_AppTaskSwHookPtr
000074  4841              LDR      r0,|L1.380|
;;;120    #endif
;;;121    
;;;122    #if OS_CFG_TASK_REG_TBL_SIZE > 0u
;;;123        OSTaskRegNextAvailID    = (OS_REG_ID)0;
000076  6001              STR      r1,[r0,#0]  ; OS_AppTimeTickHookPtr
000078  4841              LDR      r0,|L1.384|
00007a  7001              STRB     r1,[r0,#0]
;;;124    #endif
;;;125    
;;;126        OS_PrioInit();                                          /* Initialize the priority bitmap table                   */
00007c  f7fffffe          BL       OS_PrioInit
;;;127    
;;;128        OS_RdyListInit();                                       /* Initialize the Ready List                              */
000080  f7fffffe          BL       OS_RdyListInit
;;;129    
;;;130        
;;;131    #if OS_CFG_FLAG_EN > 0u                                     /* Initialize the Event Flag module                       */
;;;132        OS_FlagInit(p_err);
000084  4620              MOV      r0,r4
000086  f7fffffe          BL       OS_FlagInit
;;;133        if (*p_err != OS_ERR_NONE) {
00008a  8820              LDRH     r0,[r4,#0]
00008c  2800              CMP      r0,#0
00008e  d147              BNE      |L1.288|
;;;134            return;
;;;135        }
;;;136    #endif
;;;137    
;;;138    
;;;139    #if OS_CFG_MEM_EN > 0u                                      /* Initialize the Memory Manager module                   */
;;;140        OS_MemInit(p_err);
000090  4620              MOV      r0,r4
000092  f7fffffe          BL       OS_MemInit
;;;141        if (*p_err != OS_ERR_NONE) {
000096  8820              LDRH     r0,[r4,#0]
000098  2800              CMP      r0,#0
00009a  d141              BNE      |L1.288|
;;;142            return;
;;;143        }
;;;144    #endif
;;;145    
;;;146    
;;;147    #if (OS_MSG_EN) > 0u                                        /* Initialize the free list of OS_MSGs                    */
;;;148        OS_MsgPoolInit(p_err);
00009c  4620              MOV      r0,r4
00009e  f7fffffe          BL       OS_MsgPoolInit
;;;149        if (*p_err != OS_ERR_NONE) {
0000a2  8820              LDRH     r0,[r4,#0]
0000a4  2800              CMP      r0,#0
0000a6  d13b              BNE      |L1.288|
;;;150            return;
;;;151        }
;;;152    #endif
;;;153    
;;;154    
;;;155    #if OS_CFG_MUTEX_EN > 0u                                    /* Initialize the Mutex Manager module                    */
;;;156        OS_MutexInit(p_err);
0000a8  4620              MOV      r0,r4
0000aa  f7fffffe          BL       OS_MutexInit
;;;157        if (*p_err != OS_ERR_NONE) {
0000ae  8820              LDRH     r0,[r4,#0]
0000b0  2800              CMP      r0,#0
0000b2  d135              BNE      |L1.288|
;;;158            return;
;;;159        }
;;;160    #endif
;;;161    
;;;162    
;;;163    #if OS_CFG_Q_EN > 0u
;;;164        OS_QInit(p_err);                                        /* Initialize the Message Queue Manager module            */
0000b4  4620              MOV      r0,r4
0000b6  f7fffffe          BL       OS_QInit
;;;165        if (*p_err != OS_ERR_NONE) {
0000ba  8820              LDRH     r0,[r4,#0]
0000bc  2800              CMP      r0,#0
0000be  d12f              BNE      |L1.288|
;;;166            return;
;;;167        }
;;;168    #endif
;;;169    
;;;170    
;;;171    #if OS_CFG_SEM_EN > 0u                                      /* Initialize the Semaphore Manager module                */
;;;172        OS_SemInit(p_err);
0000c0  4620              MOV      r0,r4
0000c2  f7fffffe          BL       OS_SemInit
;;;173        if (*p_err != OS_ERR_NONE) {
0000c6  8820              LDRH     r0,[r4,#0]
0000c8  2800              CMP      r0,#0
0000ca  d129              BNE      |L1.288|
;;;174            return;
;;;175        }
;;;176    #endif
;;;177    
;;;178    
;;;179    #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
;;;180        OS_TLS_Init(p_err);                                     /* Initialize Task Local Storage, before creating tasks   */
;;;181        if (*p_err != OS_ERR_NONE) {
;;;182            return;
;;;183        }
;;;184    #endif
;;;185    
;;;186    
;;;187        OS_TaskInit(p_err);                                     /* Initialize the task manager                            */
0000cc  4620              MOV      r0,r4
0000ce  f7fffffe          BL       OS_TaskInit
;;;188        if (*p_err != OS_ERR_NONE) {
0000d2  8820              LDRH     r0,[r4,#0]
0000d4  2800              CMP      r0,#0
0000d6  d123              BNE      |L1.288|
;;;189            return;
;;;190        }
;;;191    
;;;192    
;;;193    #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
;;;194        OS_IntQTaskInit(p_err);                                 /* Initialize the Interrupt Queue Handler Task            */
0000d8  4620              MOV      r0,r4
0000da  f7fffffe          BL       OS_IntQTaskInit
;;;195        if (*p_err != OS_ERR_NONE) {
0000de  8820              LDRH     r0,[r4,#0]
0000e0  2800              CMP      r0,#0
0000e2  d11d              BNE      |L1.288|
;;;196            return;
;;;197        }
;;;198    #endif
;;;199    
;;;200        
;;;201        OS_IdleTaskInit(p_err);                                 /* Initialize the Idle Task                               */
0000e4  4620              MOV      r0,r4
0000e6  f7fffffe          BL       OS_IdleTaskInit
;;;202        if (*p_err != OS_ERR_NONE) {
0000ea  8820              LDRH     r0,[r4,#0]
0000ec  2800              CMP      r0,#0
0000ee  d117              BNE      |L1.288|
;;;203            return;
;;;204        }
;;;205    
;;;206    
;;;207        OS_TickTaskInit(p_err);                                 /* Initialize the Tick Task                               */
0000f0  4620              MOV      r0,r4
0000f2  f7fffffe          BL       OS_TickTaskInit
;;;208        if (*p_err != OS_ERR_NONE) {
0000f6  8820              LDRH     r0,[r4,#0]
0000f8  2800              CMP      r0,#0
0000fa  d111              BNE      |L1.288|
;;;209            return;
;;;210        }
;;;211    
;;;212    
;;;213    #if OS_CFG_STAT_TASK_EN > 0u                                /* Initialize the Statistic Task                          */
;;;214        OS_StatTaskInit(p_err);
0000fc  4620              MOV      r0,r4
0000fe  f7fffffe          BL       OS_StatTaskInit
;;;215        if (*p_err != OS_ERR_NONE) {
000102  8820              LDRH     r0,[r4,#0]
000104  2800              CMP      r0,#0
000106  d10b              BNE      |L1.288|
;;;216            return;
;;;217        }
;;;218    #endif
;;;219    
;;;220    
;;;221    #if OS_CFG_TMR_EN > 0u                                      /* Initialize the Timer Manager module                    */
;;;222        OS_TmrInit(p_err);
000108  4620              MOV      r0,r4
00010a  f7fffffe          BL       OS_TmrInit
;;;223        if (*p_err != OS_ERR_NONE) {
00010e  8820              LDRH     r0,[r4,#0]
000110  2800              CMP      r0,#0
000112  d105              BNE      |L1.288|
;;;224            return;
;;;225        }
;;;226    #endif
;;;227    
;;;228    
;;;229    #if OS_CFG_DBG_EN > 0u
;;;230        OS_Dbg_Init();
000114  f7fffffe          BL       OS_Dbg_Init
;;;231    #endif
;;;232    
;;;233    
;;;234        OSCfg_Init();
000118  e8bd4010          POP      {r4,lr}
00011c  f7ffbffe          B.W      OSCfg_Init
                  |L1.288|
;;;235    }
000120  bd10              POP      {r4,pc}
;;;236    
                          ENDP

000122  0000              DCW      0x0000
                  |L1.292|
                          DCD      OSIntNestingCtr
                  |L1.296|
                          DCD      OSRunning
                  |L1.300|
                          DCD      OSSchedLockNestingCtr
                  |L1.304|
                          DCD      OSTCBCurPtr
                  |L1.308|
                          DCD      OSTCBHighRdyPtr
                  |L1.312|
                          DCD      OSPrioCur
                  |L1.316|
                          DCD      OSPrioHighRdy
                  |L1.320|
                          DCD      OSPrioSaved
                  |L1.324|
                          DCD      OSSchedLockTimeBegin
                  |L1.328|
                          DCD      OSSchedLockTimeMax
                  |L1.332|
                          DCD      OSSchedLockTimeMaxCur
                  |L1.336|
                          DCD      OSSchedRoundRobinEn
                  |L1.340|
                          DCD      OSCfg_TickRate_Hz
                  |L1.344|
                          DCD      OSSchedRoundRobinDfltTimeQuanta
                  |L1.348|
                          DCD      OSCfg_ISRStkSize
                  |L1.352|
                          DCD      OSCfg_ISRStkBasePtr
                  |L1.356|
                          DCD      OS_AppTaskCreateHookPtr
                  |L1.360|
                          DCD      OS_AppTaskDelHookPtr
                  |L1.364|
                          DCD      OS_AppTaskReturnHookPtr
                  |L1.368|
                          DCD      OS_AppIdleTaskHookPtr
                  |L1.372|
                          DCD      OS_AppStatTaskHookPtr
                  |L1.376|
                          DCD      OS_AppTaskSwHookPtr
                  |L1.380|
                          DCD      OS_AppTimeTickHookPtr
                  |L1.384|
                          DCD      OSTaskRegNextAvailID

                          AREA ||i.OSIntEnter||, CODE, READONLY, ALIGN=2

                  OSIntEnter PROC
;;;265    
;;;266    void  OSIntEnter (void)
000000  4805              LDR      r0,|L2.24|
;;;267    {
;;;268        if (OSRunning != OS_STATE_OS_RUNNING) {                 /* Is OS running?                                         */
000002  7800              LDRB     r0,[r0,#0]  ; OSRunning
000004  2801              CMP      r0,#1
000006  d105              BNE      |L2.20|
;;;269            return;                                             /* No                                                     */
;;;270        }
;;;271    
;;;272        if (OSIntNestingCtr >= (OS_NESTING_CTR)250u) {          /* Have we nested past 250 levels?                        */
000008  4904              LDR      r1,|L2.28|
00000a  7808              LDRB     r0,[r1,#0]  ; OSIntNestingCtr
00000c  28fa              CMP      r0,#0xfa
00000e  d201              BCS      |L2.20|
;;;273            return;                                             /* Yes                                                    */
;;;274        }
;;;275    
;;;276        OSIntNestingCtr++;                                      /* Increment ISR nesting level                            */
000010  1c40              ADDS     r0,r0,#1
000012  7008              STRB     r0,[r1,#0]
                  |L2.20|
;;;277    }
000014  4770              BX       lr
;;;278    
                          ENDP

000016  0000              DCW      0x0000
                  |L2.24|
                          DCD      OSRunning
                  |L2.28|
                          DCD      OSIntNestingCtr

                          AREA ||i.OSIntExit||, CODE, READONLY, ALIGN=2

                  OSIntExit PROC
;;;299    
;;;300    void  OSIntExit (void)
000000  481a              LDR      r0,|L3.108|
;;;301    {
000002  b510              PUSH     {r4,lr}
;;;302        CPU_SR_ALLOC();
;;;303    
;;;304    
;;;305    
;;;306        if (OSRunning != OS_STATE_OS_RUNNING) {                 /* Has the OS started?                                    */
000004  7800              LDRB     r0,[r0,#0]  ; OSRunning
000006  2801              CMP      r0,#1
000008  d12f              BNE      |L3.106|
;;;307            return;                                             /* No                                                     */
;;;308        }
;;;309    
;;;310        CPU_INT_DIS();
00000a  f7fffffe          BL       CPU_SR_Save
;;;311        if (OSIntNestingCtr == (OS_NESTING_CTR)0) {             /* Prevent OSIntNestingCtr from wrapping                  */
00000e  4a18              LDR      r2,|L3.112|
000010  4604              MOV      r4,r0                 ;310
000012  7811              LDRB     r1,[r2,#0]  ; OSIntNestingCtr
000014  b129              CBZ      r1,|L3.34|
;;;312            CPU_INT_EN();
;;;313            return;
;;;314        }
;;;315        OSIntNestingCtr--;
000016  1e49              SUBS     r1,r1,#1
000018  f01100ff          ANDS     r0,r1,#0xff
00001c  7010              STRB     r0,[r2,#0]
;;;316        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* ISRs still nested?                                     */
00001e  d122              BNE      |L3.102|
000020  e003              B        |L3.42|
                  |L3.34|
000022  e8bd4010          POP      {r4,lr}               ;312
000026  f7ffbffe          B.W      CPU_SR_Restore
                  |L3.42|
;;;317            CPU_INT_EN();                                       /* Yes                                                    */
;;;318            return;
;;;319        }
;;;320    
;;;321        if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {        /* Scheduler still locked?                                */
00002a  4812              LDR      r0,|L3.116|
00002c  7800              LDRB     r0,[r0,#0]  ; OSSchedLockNestingCtr
00002e  b9d0              CBNZ     r0,|L3.102|
;;;322            CPU_INT_EN();                                       /* Yes                                                    */
;;;323            return;
;;;324        }
;;;325    
;;;326        OSPrioHighRdy   = OS_PrioGetHighest();                  /* Find highest priority                                  */
000030  f7fffffe          BL       OS_PrioGetHighest
000034  4910              LDR      r1,|L3.120|
000036  7008              STRB     r0,[r1,#0]
;;;327        OSTCBHighRdyPtr = OSRdyList[OSPrioHighRdy].HeadPtr;     /* Get highest priority task ready-to-run                 */
000038  4910              LDR      r1,|L3.124|
00003a  eb000040          ADD      r0,r0,r0,LSL #1
00003e  f8511020          LDR      r1,[r1,r0,LSL #2]
000042  480f              LDR      r0,|L3.128|
;;;328        if (OSTCBHighRdyPtr == OSTCBCurPtr) {                   /* Current task still the highest priority?               */
000044  6001              STR      r1,[r0,#0]  ; OSTCBHighRdyPtr
000046  480f              LDR      r0,|L3.132|
000048  6800              LDR      r0,[r0,#0]  ; OSTCBCurPtr
00004a  4281              CMP      r1,r0
00004c  d00b              BEQ      |L3.102|
;;;329            CPU_INT_EN();                                       /* Yes                                                    */
;;;330            return;
;;;331        }
;;;332    
;;;333    #if OS_CFG_TASK_PROFILE_EN > 0u
;;;334        OSTCBHighRdyPtr->CtxSwCtr++;                            /* Inc. # of context switches for this new task           */
00004e  f8510f90          LDR      r0,[r1,#0x90]!
000052  1c40              ADDS     r0,r0,#1
;;;335    #endif
;;;336        OSTaskCtxSwCtr++;                                       /* Keep track of the total number of ctx switches         */
000054  6008              STR      r0,[r1,#0]
000056  480c              LDR      r0,|L3.136|
000058  6801              LDR      r1,[r0,#0]  ; OSTaskCtxSwCtr
00005a  1c49              ADDS     r1,r1,#1
;;;337    
;;;338    #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
;;;339        OS_TLS_TaskSw();
;;;340    #endif
;;;341    
;;;342        OSIntCtxSw();                                           /* Perform interrupt level ctx switch                     */
00005c  6001              STR      r1,[r0,#0]  ; OSTaskCtxSwCtr
00005e  490b              LDR      r1,|L3.140|
000060  f04f5080          MOV      r0,#0x10000000
000064  6008              STR      r0,[r1,#0]
                  |L3.102|
000066  4620              MOV      r0,r4                 ;329
000068  e7db              B        |L3.34|
                  |L3.106|
;;;343        CPU_INT_EN();
;;;344    }
00006a  bd10              POP      {r4,pc}
;;;345    
                          ENDP

                  |L3.108|
                          DCD      OSRunning
                  |L3.112|
                          DCD      OSIntNestingCtr
                  |L3.116|
                          DCD      OSSchedLockNestingCtr
                  |L3.120|
                          DCD      OSPrioHighRdy
                  |L3.124|
                          DCD      OSRdyList
                  |L3.128|
                          DCD      OSTCBHighRdyPtr
                  |L3.132|
                          DCD      OSTCBCurPtr
                  |L3.136|
                          DCD      OSTaskCtxSwCtr
                  |L3.140|
                          DCD      0xe000ed04

                          AREA ||i.OSSched||, CODE, READONLY, ALIGN=2

                  OSSched PROC
;;;386    
;;;387    void  OSSched (void)
000000  4816              LDR      r0,|L4.92|
;;;388    {
000002  b510              PUSH     {r4,lr}
;;;389        CPU_SR_ALLOC();
;;;390    
;;;391    
;;;392    
;;;393        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* ISRs still nested?                                     */
000004  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
000006  2800              CMP      r0,#0                 ;388
000008  d126              BNE      |L4.88|
;;;394            return;                                             /* Yes ... only schedule when no nested ISRs              */
;;;395        }
;;;396    
;;;397        if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {        /* Scheduler locked?                                      */
00000a  4815              LDR      r0,|L4.96|
00000c  7800              LDRB     r0,[r0,#0]  ; OSSchedLockNestingCtr
00000e  2800              CMP      r0,#0
000010  d122              BNE      |L4.88|
;;;398            return;                                             /* Yes                                                    */
;;;399        }
;;;400    
;;;401        CPU_INT_DIS();
000012  f7fffffe          BL       CPU_SR_Save
000016  4604              MOV      r4,r0
;;;402        OSPrioHighRdy   = OS_PrioGetHighest();                  /* Find the highest priority ready                        */
000018  f7fffffe          BL       OS_PrioGetHighest
00001c  4911              LDR      r1,|L4.100|
00001e  7008              STRB     r0,[r1,#0]
;;;403        OSTCBHighRdyPtr = OSRdyList[OSPrioHighRdy].HeadPtr;
000020  4911              LDR      r1,|L4.104|
000022  eb000040          ADD      r0,r0,r0,LSL #1
000026  f8510020          LDR      r0,[r1,r0,LSL #2]
00002a  4910              LDR      r1,|L4.108|
;;;404        if (OSTCBHighRdyPtr == OSTCBCurPtr) {                   /* Current task is still highest priority task?           */
00002c  6008              STR      r0,[r1,#0]  ; OSTCBHighRdyPtr
00002e  4910              LDR      r1,|L4.112|
000030  6809              LDR      r1,[r1,#0]  ; OSTCBCurPtr
000032  4288              CMP      r0,r1
000034  d00b              BEQ      |L4.78|
;;;405            CPU_INT_EN();                                       /* Yes ... no need to context switch                      */
;;;406            return;
;;;407        }
;;;408    
;;;409    #if OS_CFG_TASK_PROFILE_EN > 0u
;;;410        OSTCBHighRdyPtr->CtxSwCtr++;                            /* Inc. # of context switches to this task                */
000036  f8501f90          LDR      r1,[r0,#0x90]!
00003a  1c49              ADDS     r1,r1,#1
;;;411    #endif
;;;412        OSTaskCtxSwCtr++;                                       /* Increment context switch counter                       */
00003c  6001              STR      r1,[r0,#0]
00003e  480d              LDR      r0,|L4.116|
000040  6801              LDR      r1,[r0,#0]  ; OSTaskCtxSwCtr
000042  1c49              ADDS     r1,r1,#1
;;;413    
;;;414    #if defined(OS_CFG_TLS_TBL_SIZE) && (OS_CFG_TLS_TBL_SIZE > 0u)
;;;415        OS_TLS_TaskSw();
;;;416    #endif
;;;417    
;;;418        OS_TASK_SW();                                           /* Perform a task level context switch                    */
000044  6001              STR      r1,[r0,#0]  ; OSTaskCtxSwCtr
000046  490c              LDR      r1,|L4.120|
000048  f04f5080          MOV      r0,#0x10000000
00004c  6008              STR      r0,[r1,#0]
                  |L4.78|
00004e  4620              MOV      r0,r4                 ;405
000050  e8bd4010          POP      {r4,lr}               ;405
000054  f7ffbffe          B.W      CPU_SR_Restore
                  |L4.88|
;;;419        CPU_INT_EN();
;;;420    }
000058  bd10              POP      {r4,pc}
;;;421    
                          ENDP

00005a  0000              DCW      0x0000
                  |L4.92|
                          DCD      OSIntNestingCtr
                  |L4.96|
                          DCD      OSSchedLockNestingCtr
                  |L4.100|
                          DCD      OSPrioHighRdy
                  |L4.104|
                          DCD      OSRdyList
                  |L4.108|
                          DCD      OSTCBHighRdyPtr
                  |L4.112|
                          DCD      OSTCBCurPtr
                  |L4.116|
                          DCD      OSTaskCtxSwCtr
                  |L4.120|
                          DCD      0xe000ed04

                          AREA ||i.OSSchedLock||, CODE, READONLY, ALIGN=2

                  OSSchedLock PROC
;;;443    
;;;444    void  OSSchedLock (OS_ERR  *p_err)
000000  b570              PUSH     {r4-r6,lr}
;;;445    {
000002  4604              MOV      r4,r0
;;;446        CPU_SR_ALLOC();
;;;447    
;;;448    
;;;449    
;;;450    #ifdef OS_SAFETY_CRITICAL
;;;451        if (p_err == (OS_ERR *)0) {
;;;452            OS_SAFETY_CRITICAL_EXCEPTION();
;;;453            return;
;;;454        }
;;;455    #endif
;;;456    
;;;457    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;458        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
000004  4810              LDR      r0,|L5.72|
000006  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
000008  b110              CBZ      r0,|L5.16|
;;;459           *p_err = OS_ERR_SCHED_LOCK_ISR;
00000a  f6465062          MOV      r0,#0x6d62
;;;460            return;
00000e  e019              B        |L5.68|
                  |L5.16|
;;;461        }
;;;462    #endif
;;;463    
;;;464        if (OSRunning != OS_STATE_OS_RUNNING) {                 /* Make sure multitasking is running                      */
000010  480e              LDR      r0,|L5.76|
000012  7800              LDRB     r0,[r0,#0]  ; OSRunning
000014  2801              CMP      r0,#1
000016  d002              BEQ      |L5.30|
;;;465           *p_err = OS_ERR_OS_NOT_RUNNING;
000018  f6456089          MOV      r0,#0x5e89
;;;466            return;
00001c  e012              B        |L5.68|
                  |L5.30|
;;;467        }
;;;468    
;;;469        if (OSSchedLockNestingCtr >= (OS_NESTING_CTR)250u) {    /* Prevent OSSchedLockNestingCtr overflowing              */
00001e  4d0c              LDR      r5,|L5.80|
000020  7828              LDRB     r0,[r5,#0]  ; OSSchedLockNestingCtr
000022  28fa              CMP      r0,#0xfa
000024  d302              BCC      |L5.44|
;;;470           *p_err = OS_ERR_LOCK_NESTING_OVF;
000026  f2452009          MOV      r0,#0x5209
;;;471            return;
00002a  e00b              B        |L5.68|
                  |L5.44|
;;;472        }
;;;473    
;;;474        CPU_CRITICAL_ENTER();
00002c  f7fffffe          BL       CPU_SR_Save
000030  4606              MOV      r6,r0
;;;475        OSSchedLockNestingCtr++;                                /* Increment lock nesting level                           */
000032  7828              LDRB     r0,[r5,#0]  ; OSSchedLockNestingCtr
000034  1c40              ADDS     r0,r0,#1
000036  7028              STRB     r0,[r5,#0]
;;;476    #if OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u
;;;477        OS_SchedLockTimeMeasStart();
000038  f7fffffe          BL       OS_SchedLockTimeMeasStart
;;;478    #endif
;;;479        CPU_CRITICAL_EXIT();
00003c  4630              MOV      r0,r6
00003e  f7fffffe          BL       CPU_SR_Restore
;;;480       *p_err = OS_ERR_NONE;
000042  2000              MOVS     r0,#0
                  |L5.68|
000044  8020              STRH     r0,[r4,#0]
;;;481    }
000046  bd70              POP      {r4-r6,pc}
;;;482    
                          ENDP

                  |L5.72|
                          DCD      OSIntNestingCtr
                  |L5.76|
                          DCD      OSRunning
                  |L5.80|
                          DCD      OSSchedLockNestingCtr

                          AREA ||i.OSSchedRoundRobinCfg||, CODE, READONLY, ALIGN=2

                  OSSchedRoundRobinCfg PROC
;;;571    #if OS_CFG_SCHED_ROUND_ROBIN_EN > 0u
;;;572    void  OSSchedRoundRobinCfg (CPU_BOOLEAN   en,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;573                                OS_TICK       dflt_time_quanta,
;;;574                                OS_ERR       *p_err)
;;;575    {
000004  4615              MOV      r5,r2
000006  460c              MOV      r4,r1
000008  4607              MOV      r7,r0
;;;576        CPU_SR_ALLOC();
;;;577    
;;;578    
;;;579    
;;;580    #ifdef OS_SAFETY_CRITICAL
;;;581        if (p_err == (OS_ERR *)0) {
;;;582            OS_SAFETY_CRITICAL_EXCEPTION();
;;;583            return;
;;;584        }
;;;585    #endif
;;;586    
;;;587        CPU_CRITICAL_ENTER();
00000a  f7fffffe          BL       CPU_SR_Save
;;;588        if (en != DEF_ENABLED) {
;;;589            OSSchedRoundRobinEn = DEF_DISABLED;
00000e  490b              LDR      r1,|L6.60|
000010  2600              MOVS     r6,#0
000012  2f01              CMP      r7,#1                 ;588
000014  d001              BEQ      |L6.26|
000016  700e              STRB     r6,[r1,#0]
000018  e001              B        |L6.30|
                  |L6.26|
;;;590        } else {
;;;591            OSSchedRoundRobinEn = DEF_ENABLED;
00001a  2201              MOVS     r2,#1
00001c  700a              STRB     r2,[r1,#0]
                  |L6.30|
;;;592        }
;;;593    
;;;594        if (dflt_time_quanta > (OS_TICK)0) {
;;;595            OSSchedRoundRobinDfltTimeQuanta = dflt_time_quanta;
00001e  4908              LDR      r1,|L6.64|
000020  b10c              CBZ      r4,|L6.38|
000022  600c              STR      r4,[r1,#0]  ; OSSchedRoundRobinDfltTimeQuanta
000024  e005              B        |L6.50|
                  |L6.38|
;;;596        } else {
;;;597            OSSchedRoundRobinDfltTimeQuanta = (OS_TICK)(OSCfg_TickRate_Hz / (OS_RATE_HZ)10);
000026  4a07              LDR      r2,|L6.68|
000028  230a              MOVS     r3,#0xa
00002a  6812              LDR      r2,[r2,#0]  ; OSCfg_TickRate_Hz
00002c  fbb2f2f3          UDIV     r2,r2,r3
000030  600a              STR      r2,[r1,#0]  ; OSSchedRoundRobinDfltTimeQuanta
                  |L6.50|
;;;598        }
;;;599        CPU_CRITICAL_EXIT();
000032  f7fffffe          BL       CPU_SR_Restore
;;;600       *p_err = OS_ERR_NONE;
000036  802e              STRH     r6,[r5,#0]
;;;601    }
000038  e8bd81f0          POP      {r4-r8,pc}
;;;602    #endif
                          ENDP

                  |L6.60|
                          DCD      OSSchedRoundRobinEn
                  |L6.64|
                          DCD      OSSchedRoundRobinDfltTimeQuanta
                  |L6.68|
                          DCD      OSCfg_TickRate_Hz

                          AREA ||i.OSSchedRoundRobinYield||, CODE, READONLY, ALIGN=2

                  OSSchedRoundRobinYield PROC
;;;625    #if OS_CFG_SCHED_ROUND_ROBIN_EN > 0u
;;;626    void  OSSchedRoundRobinYield (OS_ERR  *p_err)
000000  b570              PUSH     {r4-r6,lr}
;;;627    {
000002  4604              MOV      r4,r0
;;;628        OS_RDY_LIST  *p_rdy_list;
;;;629        OS_TCB       *p_tcb;
;;;630        CPU_SR_ALLOC();
;;;631    
;;;632    
;;;633    
;;;634    #ifdef OS_SAFETY_CRITICAL
;;;635        if (p_err == (OS_ERR *)0) {
;;;636            OS_SAFETY_CRITICAL_EXCEPTION();
;;;637            return;
;;;638        }
;;;639    #endif
;;;640    
;;;641    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;642        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Can't call this function from an ISR                   */
000004  481b              LDR      r0,|L7.116|
000006  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
000008  b110              CBZ      r0,|L7.16|
;;;643           *p_err = OS_ERR_YIELD_ISR;
00000a  f24840d1          MOV      r0,#0x84d1
;;;644            return;
00000e  e02e              B        |L7.110|
                  |L7.16|
;;;645        }
;;;646    #endif
;;;647    
;;;648        if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {        /* Can't yield if the scheduler is locked                 */
000010  4819              LDR      r0,|L7.120|
000012  7800              LDRB     r0,[r0,#0]  ; OSSchedLockNestingCtr
000014  b110              CBZ      r0,|L7.28|
;;;649           *p_err = OS_ERR_SCHED_LOCKED;
000016  f6465063          MOV      r0,#0x6d63
;;;650            return;
00001a  e028              B        |L7.110|
                  |L7.28|
;;;651        }
;;;652    
;;;653        if (OSSchedRoundRobinEn != DEF_TRUE) {                  /* Make sure round-robin has been enabled                 */
00001c  4817              LDR      r0,|L7.124|
00001e  7800              LDRB     r0,[r0,#0]  ; OSSchedRoundRobinEn
000020  2801              CMP      r0,#1
000022  d002              BEQ      |L7.42|
;;;654           *p_err = OS_ERR_ROUND_ROBIN_DISABLED;
000024  f646107b          MOV      r0,#0x697b
;;;655            return;
000028  e021              B        |L7.110|
                  |L7.42|
;;;656        }
;;;657    
;;;658        CPU_CRITICAL_ENTER();
00002a  f7fffffe          BL       CPU_SR_Save
00002e  4606              MOV      r6,r0
;;;659        p_rdy_list = &OSRdyList[OSPrioCur];                     /* Can't yield if it's the only task at that priority     */
000030  4813              LDR      r0,|L7.128|
000032  4914              LDR      r1,|L7.132|
000034  7800              LDRB     r0,[r0,#0]  ; OSPrioCur
000036  eb000040          ADD      r0,r0,r0,LSL #1
00003a  eb010580          ADD      r5,r1,r0,LSL #2
;;;660        if (p_rdy_list->NbrEntries < (OS_OBJ_QTY)2) {
00003e  8928              LDRH     r0,[r5,#8]
000040  2802              CMP      r0,#2
000042  d205              BCS      |L7.80|
;;;661            CPU_CRITICAL_EXIT();
000044  4630              MOV      r0,r6
000046  f7fffffe          BL       CPU_SR_Restore
;;;662           *p_err = OS_ERR_ROUND_ROBIN_1;
00004a  f646107a          MOV      r0,#0x697a
;;;663            return;
00004e  e00e              B        |L7.110|
                  |L7.80|
;;;664        }
;;;665    
;;;666        OS_RdyListMoveHeadToTail(p_rdy_list);                   /* Move current OS_TCB to the end of the list             */
000050  4628              MOV      r0,r5
000052  f7fffffe          BL       OS_RdyListMoveHeadToTail
;;;667        p_tcb = p_rdy_list->HeadPtr;                            /* Point to new OS_TCB at head of the list                */
;;;668        if (p_tcb->TimeQuanta == (OS_TICK)0) {                  /* See if we need to use the default time slice           */
000056  6828              LDR      r0,[r5,#0]
000058  6d41              LDR      r1,[r0,#0x54]
00005a  b909              CBNZ     r1,|L7.96|
;;;669            p_tcb->TimeQuantaCtr = OSSchedRoundRobinDfltTimeQuanta;
00005c  490a              LDR      r1,|L7.136|
00005e  6809              LDR      r1,[r1,#0]  ; OSSchedRoundRobinDfltTimeQuanta
                  |L7.96|
;;;670        } else {
;;;671            p_tcb->TimeQuantaCtr = p_tcb->TimeQuanta;           /* Load time slice counter with new time                  */
;;;672        }
;;;673    
;;;674        CPU_CRITICAL_EXIT();
000060  6581              STR      r1,[r0,#0x58]
000062  4630              MOV      r0,r6
000064  f7fffffe          BL       CPU_SR_Restore
;;;675    
;;;676        OSSched();                                              /* Run new task                                           */
000068  f7fffffe          BL       OSSched
;;;677       *p_err = OS_ERR_NONE;
00006c  2000              MOVS     r0,#0
                  |L7.110|
00006e  8020              STRH     r0,[r4,#0]
;;;678    }
000070  bd70              POP      {r4-r6,pc}
;;;679    #endif
                          ENDP

000072  0000              DCW      0x0000
                  |L7.116|
                          DCD      OSIntNestingCtr
                  |L7.120|
                          DCD      OSSchedLockNestingCtr
                  |L7.124|
                          DCD      OSSchedRoundRobinEn
                  |L7.128|
                          DCD      OSPrioCur
                  |L7.132|
                          DCD      OSRdyList
                  |L7.136|
                          DCD      OSSchedRoundRobinDfltTimeQuanta

                          AREA ||i.OSSchedUnlock||, CODE, READONLY, ALIGN=2

                  OSSchedUnlock PROC
;;;504    
;;;505    void  OSSchedUnlock (OS_ERR  *p_err)
000000  b570              PUSH     {r4-r6,lr}
;;;506    {
000002  4604              MOV      r4,r0
;;;507        CPU_SR_ALLOC();
;;;508    
;;;509    
;;;510    
;;;511    #ifdef OS_SAFETY_CRITICAL
;;;512        if (p_err == (OS_ERR *)0) {
;;;513            OS_SAFETY_CRITICAL_EXCEPTION();
;;;514            return;
;;;515        }
;;;516    #endif
;;;517    
;;;518    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;519        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* Not allowed to call from an ISR                        */
000004  4815              LDR      r0,|L8.92|
000006  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
000008  b110              CBZ      r0,|L8.16|
;;;520           *p_err = OS_ERR_SCHED_UNLOCK_ISR;
00000a  f6465065          MOV      r0,#0x6d65
;;;521            return;
00000e  e023              B        |L8.88|
                  |L8.16|
;;;522        }
;;;523    #endif
;;;524    
;;;525        if (OSRunning != OS_STATE_OS_RUNNING) {                 /* Make sure multitasking is running                      */
000010  4813              LDR      r0,|L8.96|
000012  7800              LDRB     r0,[r0,#0]  ; OSRunning
000014  2801              CMP      r0,#1
000016  d002              BEQ      |L8.30|
;;;526           *p_err = OS_ERR_OS_NOT_RUNNING;
000018  f6456089          MOV      r0,#0x5e89
;;;527            return;
00001c  e01c              B        |L8.88|
                  |L8.30|
;;;528        }
;;;529    
;;;530        if (OSSchedLockNestingCtr == (OS_NESTING_CTR)0) {       /* See if the scheduler is locked                         */
00001e  4d11              LDR      r5,|L8.100|
000020  7828              LDRB     r0,[r5,#0]  ; OSSchedLockNestingCtr
000022  b170              CBZ      r0,|L8.66|
;;;531           *p_err = OS_ERR_SCHED_NOT_LOCKED;
;;;532            return;
;;;533        }
;;;534    
;;;535        CPU_CRITICAL_ENTER();
000024  f7fffffe          BL       CPU_SR_Save
000028  4606              MOV      r6,r0
;;;536        OSSchedLockNestingCtr--;                                /* Decrement lock nesting level                           */
00002a  7828              LDRB     r0,[r5,#0]  ; OSSchedLockNestingCtr
00002c  1e40              SUBS     r0,r0,#1
00002e  f01000ff          ANDS     r0,r0,#0xff
000032  7028              STRB     r0,[r5,#0]
;;;537        if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {
000034  d008              BEQ      |L8.72|
;;;538            CPU_CRITICAL_EXIT();                                /* Scheduler is still locked                              */
000036  4630              MOV      r0,r6
000038  f7fffffe          BL       CPU_SR_Restore
;;;539           *p_err = OS_ERR_SCHED_LOCKED;
00003c  f6465063          MOV      r0,#0x6d63
;;;540            return;
000040  e00a              B        |L8.88|
                  |L8.66|
000042  f6465064          MOV      r0,#0x6d64            ;531
000046  e007              B        |L8.88|
                  |L8.72|
;;;541        }
;;;542    
;;;543    #if OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u
;;;544        OS_SchedLockTimeMeasStop();
000048  f7fffffe          BL       OS_SchedLockTimeMeasStop
;;;545    #endif
;;;546    
;;;547        CPU_CRITICAL_EXIT();                                    /* Scheduler should be re-enabled                         */
00004c  4630              MOV      r0,r6
00004e  f7fffffe          BL       CPU_SR_Restore
;;;548        OSSched();                                              /* Run the scheduler                                      */
000052  f7fffffe          BL       OSSched
;;;549       *p_err = OS_ERR_NONE;
000056  2000              MOVS     r0,#0
                  |L8.88|
000058  8020              STRH     r0,[r4,#0]
;;;550    }
00005a  bd70              POP      {r4-r6,pc}
;;;551    
                          ENDP

                  |L8.92|
                          DCD      OSIntNestingCtr
                  |L8.96|
                          DCD      OSRunning
                  |L8.100|
                          DCD      OSSchedLockNestingCtr

                          AREA ||i.OSStart||, CODE, READONLY, ALIGN=2

                  OSStart PROC
;;;705    
;;;706    void  OSStart (OS_ERR  *p_err)
000000  b570              PUSH     {r4-r6,lr}
;;;707    {
;;;708    #ifdef OS_SAFETY_CRITICAL
;;;709        if (p_err == (OS_ERR *)0) {
;;;710            OS_SAFETY_CRITICAL_EXCEPTION();
;;;711            return;
;;;712        }
;;;713    #endif
;;;714    
;;;715        if (OSRunning == OS_STATE_OS_STOPPED) {
000002  4d0f              LDR      r5,|L9.64|
000004  4604              MOV      r4,r0                 ;707
000006  7828              LDRB     r0,[r5,#0]  ; OSRunning
000008  b118              CBZ      r0,|L9.18|
;;;716            OSPrioHighRdy   = OS_PrioGetHighest();              /* Find the highest priority                              */
;;;717            OSPrioCur       = OSPrioHighRdy;
;;;718            OSTCBHighRdyPtr = OSRdyList[OSPrioHighRdy].HeadPtr;
;;;719            OSTCBCurPtr     = OSTCBHighRdyPtr;
;;;720            OSRunning       = OS_STATE_OS_RUNNING;
;;;721            OSStartHighRdy();                                   /* Execute target specific code to start task             */
;;;722           *p_err           = OS_ERR_FATAL_RETURN;              /* OSStart() is not supposed to return                    */
;;;723        } else {
;;;724           *p_err           = OS_ERR_OS_RUNNING;                /* OS is already running                                  */
00000a  f645608a          MOV      r0,#0x5e8a
                  |L9.14|
00000e  8020              STRH     r0,[r4,#0]            ;722
;;;725        }
;;;726    }
000010  bd70              POP      {r4-r6,pc}
                  |L9.18|
000012  f7fffffe          BL       OS_PrioGetHighest
000016  490b              LDR      r1,|L9.68|
000018  7008              STRB     r0,[r1,#0]            ;716
00001a  490b              LDR      r1,|L9.72|
00001c  7008              STRB     r0,[r1,#0]            ;717
00001e  490b              LDR      r1,|L9.76|
000020  eb000040          ADD      r0,r0,r0,LSL #1       ;718
000024  f8510020          LDR      r0,[r1,r0,LSL #2]     ;718
000028  4909              LDR      r1,|L9.80|
00002a  6008              STR      r0,[r1,#0]            ;719  ; OSTCBHighRdyPtr
00002c  4909              LDR      r1,|L9.84|
00002e  6008              STR      r0,[r1,#0]            ;720  ; OSTCBCurPtr
000030  2001              MOVS     r0,#1                 ;720
000032  7028              STRB     r0,[r5,#0]            ;720
000034  f7fffffe          BL       OSStartHighRdy
000038  f6432099          MOV      r0,#0x3a99            ;722
00003c  e7e7              B        |L9.14|
;;;727    
                          ENDP

00003e  0000              DCW      0x0000
                  |L9.64|
                          DCD      OSRunning
                  |L9.68|
                          DCD      OSPrioHighRdy
                  |L9.72|
                          DCD      OSPrioCur
                  |L9.76|
                          DCD      OSRdyList
                  |L9.80|
                          DCD      OSTCBHighRdyPtr
                  |L9.84|
                          DCD      OSTCBCurPtr

                          AREA ||i.OSVersion||, CODE, READONLY, ALIGN=1

                  OSVersion PROC
;;;744    
;;;745    CPU_INT16U  OSVersion (OS_ERR  *p_err)
000000  2100              MOVS     r1,#0
;;;746    {
;;;747    #ifdef OS_SAFETY_CRITICAL
;;;748        if (p_err == (OS_ERR *)0) {
;;;749            OS_SAFETY_CRITICAL_EXCEPTION();
;;;750            return ((CPU_INT16U)0u);
;;;751        }
;;;752    #endif
;;;753    
;;;754       *p_err = OS_ERR_NONE;
000002  8001              STRH     r1,[r0,#0]
;;;755        return (OS_VERSION);
000004  f247605c          MOV      r0,#0x765c
;;;756    }
000008  4770              BX       lr
;;;757    
                          ENDP


                          AREA ||i.OS_IdleTask||, CODE, READONLY, ALIGN=2

                  OS_IdleTask PROC
;;;780    
;;;781    void  OS_IdleTask (void  *p_arg)
000000  4c07              LDR      r4,|L11.32|
;;;782    {
;;;783        CPU_SR_ALLOC();
;;;784    
;;;785    
;;;786    
;;;787        p_arg = p_arg;                                          /* Prevent compiler warning for not using 'p_arg'         */
;;;788    
;;;789        while (DEF_ON) {
;;;790            CPU_CRITICAL_ENTER();
;;;791            OSIdleTaskCtr++;
;;;792    #if OS_CFG_STAT_TASK_EN > 0u
;;;793            OSStatTaskCtr++;
000002  4d08              LDR      r5,|L11.36|
                  |L11.4|
000004  f7fffffe          BL       CPU_SR_Save
000008  6821              LDR      r1,[r4,#0]            ;791  ; OSIdleTaskCtr
00000a  1c49              ADDS     r1,r1,#1              ;791
00000c  6021              STR      r1,[r4,#0]  ; OSIdleTaskCtr
00000e  6829              LDR      r1,[r5,#0]  ; OSStatTaskCtr
000010  1c49              ADDS     r1,r1,#1
;;;794    #endif
;;;795            CPU_CRITICAL_EXIT();
000012  6029              STR      r1,[r5,#0]  ; OSStatTaskCtr
000014  f7fffffe          BL       CPU_SR_Restore
;;;796    
;;;797            OSIdleTaskHook();                                   /* Call user definable HOOK                               */
000018  f7fffffe          BL       OSIdleTaskHook
00001c  e7f2              B        |L11.4|
;;;798        }
;;;799    }
;;;800    
                          ENDP

00001e  0000              DCW      0x0000
                  |L11.32|
                          DCD      OSIdleTaskCtr
                  |L11.36|
                          DCD      OSStatTaskCtr

                          AREA ||i.OS_IdleTaskInit||, CODE, READONLY, ALIGN=2

                  OS_IdleTaskInit PROC
;;;815    
;;;816    void  OS_IdleTaskInit (OS_ERR  *p_err)
000000  b500              PUSH     {lr}
;;;817    {
;;;818    #ifdef OS_SAFETY_CRITICAL
;;;819        if (p_err == (OS_ERR *)0) {
;;;820            OS_SAFETY_CRITICAL_EXCEPTION();
;;;821            return;
;;;822        }
;;;823    #endif
;;;824    
;;;825        OSIdleTaskCtr = (OS_IDLE_CTR)0;
000002  4a0e              LDR      r2,|L12.60|
000004  b089              SUB      sp,sp,#0x24           ;817
000006  2100              MOVS     r1,#0
;;;826                                                                /* ---------------- CREATE THE IDLE TASK ---------------- */
;;;827        OSTaskCreate((OS_TCB     *)&OSIdleTaskTCB,
000008  6011              STR      r1,[r2,#0]  ; OSIdleTaskCtr
00000a  220b              MOVS     r2,#0xb
00000c  9105              STR      r1,[sp,#0x14]
00000e  9106              STR      r1,[sp,#0x18]
000010  e9cd2007          STRD     r2,r0,[sp,#0x1c]
000014  480a              LDR      r0,|L12.64|
000016  4a0b              LDR      r2,|L12.68|
000018  4b0b              LDR      r3,|L12.72|
00001a  6800              LDR      r0,[r0,#0]  ; OSCfg_IdleTaskStkSize
00001c  6812              LDR      r2,[r2,#0]  ; OSCfg_IdleTaskStkLimit
00001e  681b              LDR      r3,[r3,#0]  ; OSCfg_IdleTaskStkBasePtr
000020  9202              STR      r2,[sp,#8]
000022  e9cd0103          STRD     r0,r1,[sp,#0xc]
000026  203f              MOVS     r0,#0x3f
000028  e9cd0300          STRD     r0,r3,[sp,#0]
00002c  2300              MOVS     r3,#0
00002e  4a07              LDR      r2,|L12.76|
000030  a107              ADR      r1,|L12.80|
000032  480c              LDR      r0,|L12.100|
000034  f7fffffe          BL       OSTaskCreate
;;;828                     (CPU_CHAR   *)((void *)"uC/OS-III Idle Task"),
;;;829                     (OS_TASK_PTR)OS_IdleTask,
;;;830                     (void       *)0,
;;;831                     (OS_PRIO     )(OS_CFG_PRIO_MAX - 1u),
;;;832                     (CPU_STK    *)OSCfg_IdleTaskStkBasePtr,
;;;833                     (CPU_STK_SIZE)OSCfg_IdleTaskStkLimit,
;;;834                     (CPU_STK_SIZE)OSCfg_IdleTaskStkSize,
;;;835                     (OS_MSG_QTY  )0u,
;;;836                     (OS_TICK     )0u,
;;;837                     (void       *)0,
;;;838                     (OS_OPT      )(OS_OPT_TASK_STK_CHK | OS_OPT_TASK_STK_CLR | OS_OPT_TASK_NO_TLS),
;;;839                     (OS_ERR     *)p_err);
;;;840    }
000038  b009              ADD      sp,sp,#0x24
00003a  bd00              POP      {pc}
;;;841    
                          ENDP

                  |L12.60|
                          DCD      OSIdleTaskCtr
                  |L12.64|
                          DCD      OSCfg_IdleTaskStkSize
                  |L12.68|
                          DCD      OSCfg_IdleTaskStkLimit
                  |L12.72|
                          DCD      OSCfg_IdleTaskStkBasePtr
                  |L12.76|
                          DCD      OS_IdleTask
                  |L12.80|
000050  75432f4f          DCB      "uC/OS-III Idle Task",0
000054  532d4949
000058  49204964
00005c  6c652054
000060  61736b00
                  |L12.100|
                          DCD      OSIdleTaskTCB

                          AREA ||i.OS_Pend||, CODE, READONLY, ALIGN=2

                  OS_Pend PROC
;;;872    
;;;873    void  OS_Pend (OS_PEND_DATA  *p_pend_data,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;874                   OS_PEND_OBJ   *p_obj,
;;;875                   OS_STATE       pending_on,
;;;876                   OS_TICK        timeout)
;;;877    {
;;;878        OS_PEND_LIST  *p_pend_list;
;;;879    
;;;880    
;;;881    
;;;882        OSTCBCurPtr->PendOn     = pending_on;                    /* Resource not available, wait until it is              */
000004  4d11              LDR      r5,|L13.76|
000006  4607              MOV      r7,r0                 ;877
000008  460c              MOV      r4,r1                 ;877
00000a  6828              LDR      r0,[r5,#0]  ; OSTCBCurPtr
;;;883        OSTCBCurPtr->PendStatus = OS_STATUS_PEND_OK;
00000c  2600              MOVS     r6,#0
;;;884    
;;;885        OS_TaskBlock(OSTCBCurPtr,                                /* Block the task and add it to the tick list if needed  */
00000e  4619              MOV      r1,r3
000010  f8802034          STRB     r2,[r0,#0x34]         ;882
000014  f8806035          STRB     r6,[r0,#0x35]         ;883
000018  f7fffffe          BL       OS_TaskBlock
;;;886                     timeout);
;;;887    
;;;888        if (p_obj != (OS_PEND_OBJ *)0) {                         /* Add the current task to the pend list ...             */
00001c  b164              CBZ      r4,|L13.56|
;;;889            p_pend_list             = &p_obj->PendList;          /* ... if there is an object to pend on                  */
;;;890            p_pend_data->PendObjPtr = p_obj;                     /* Save the pointer to the object pending on             */
;;;891            OS_PendDataInit((OS_TCB       *)OSTCBCurPtr,         /* Initialize the remaining field                        */
00001e  60fc              STR      r4,[r7,#0xc]
000020  f1040608          ADD      r6,r4,#8              ;889
000024  2201              MOVS     r2,#1
000026  4639              MOV      r1,r7
000028  6828              LDR      r0,[r5,#0]  ; OSTCBCurPtr
00002a  f7fffffe          BL       OS_PendDataInit
;;;892                            (OS_PEND_DATA *)p_pend_data,
;;;893                            (OS_OBJ_QTY    )1);
;;;894            OS_PendListInsertPrio(p_pend_list,                   /* Insert in the pend list in priority order             */
00002e  4639              MOV      r1,r7
000030  4630              MOV      r0,r6
000032  f7fffffe          BL       OS_PendListInsertPrio
000036  e002              B        |L13.62|
                  |L13.56|
;;;895                                  p_pend_data);
;;;896        } else {
;;;897            OSTCBCurPtr->PendDataTblEntries = (OS_OBJ_QTY    )0; /* If no object being pended on the clear these fields   */
000038  6828              LDR      r0,[r5,#0]  ; OSTCBCurPtr
00003a  87c6              STRH     r6,[r0,#0x3e]
;;;898            OSTCBCurPtr->PendDataTblPtr     = (OS_PEND_DATA *)0; /* ... in the TCB                                        */
00003c  6306              STR      r6,[r0,#0x30]
                  |L13.62|
;;;899        }
;;;900    #if OS_CFG_DBG_EN > 0u
;;;901        OS_PendDbgNameAdd(p_obj,
00003e  4620              MOV      r0,r4
000040  6829              LDR      r1,[r5,#0]  ; OSTCBCurPtr
000042  e8bd41f0          POP      {r4-r8,lr}
000046  f7ffbffe          B.W      OS_PendDbgNameAdd
;;;902                          OSTCBCurPtr);
;;;903    #endif
;;;904    }
;;;905    
                          ENDP

00004a  0000              DCW      0x0000
                  |L13.76|
                          DCD      OSTCBCurPtr

                          AREA ||i.OS_PendAbort||, CODE, READONLY, ALIGN=1

                  OS_PendAbort PROC
;;;926    
;;;927    void  OS_PendAbort (OS_PEND_OBJ  *p_obj,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;928                        OS_TCB       *p_tcb,
;;;929                        CPU_TS        ts)
;;;930    {
000004  4606              MOV      r6,r0
;;;931        switch (p_tcb->TaskState) {
000006  f8910036          LDRB     r0,[r1,#0x36]
;;;932            case OS_TASK_STATE_RDY:                             /* Cannot Pend Abort a task that is ready                 */
;;;933            case OS_TASK_STATE_DLY:                             /* Cannot Pend Abort a task that is delayed               */
;;;934            case OS_TASK_STATE_SUSPENDED:                       /* Cannot Pend Abort a suspended task                     */
;;;935            case OS_TASK_STATE_DLY_SUSPENDED:                   /* Cannot Pend Abort a suspended task that was also dly'd */
;;;936                 break;
;;;937    
;;;938            case OS_TASK_STATE_PEND:
;;;939            case OS_TASK_STATE_PEND_TIMEOUT:
;;;940                 if (p_tcb->PendOn == OS_TASK_PEND_ON_MULTI) {
;;;941                     OS_PendAbort1(p_obj,                            /* Indicate which object was pend aborted            */
;;;942                                   p_tcb,
;;;943                                   ts);
;;;944                 }
;;;945    #if (OS_MSG_EN > 0u)
;;;946                 p_tcb->MsgPtr     = (void      *)0;
;;;947                 p_tcb->MsgSize    = (OS_MSG_SIZE)0u;
;;;948    #endif
;;;949                 p_tcb->TS         = ts;
;;;950                 if (p_obj != (OS_PEND_OBJ *)0) {
;;;951                     OS_PendListRemove(p_tcb);                       /* Remove task from all pend lists                   */
;;;952                 }
;;;953                 OS_TaskRdy(p_tcb);
;;;954                 p_tcb->TaskState  = OS_TASK_STATE_RDY;              /* Task will be ready                                */
;;;955                 p_tcb->PendStatus = OS_STATUS_PEND_ABORT;           /* Indicate pend was aborted                         */
00000a  2700              MOVS     r7,#0
00000c  4615              MOV      r5,r2                 ;930
00000e  460c              MOV      r4,r1                 ;930
000010  f04f0801          MOV      r8,#1
000014  2808              CMP      r0,#8                 ;931
000016  d232              BCS      |L14.126|
000018  e8dff000          TBB      [pc,r0]               ;931
00001c  31310404          DCB      0x31,0x31,0x04,0x04
000020  31311919          DCB      0x31,0x31,0x19,0x19
000024  f8940034          LDRB     r0,[r4,#0x34]         ;940
000028  2803              CMP      r0,#3                 ;940
00002a  d102              BNE      |L14.50|
00002c  4630              MOV      r0,r6                 ;941
00002e  f7fffffe          BL       OS_PendAbort1
                  |L14.50|
000032  65e7              STR      r7,[r4,#0x5c]         ;947
000034  f8a47060          STRH     r7,[r4,#0x60]         ;947
000038  6425              STR      r5,[r4,#0x40]         ;950
00003a  b116              CBZ      r6,|L14.66|
00003c  4620              MOV      r0,r4                 ;951
00003e  f7fffffe          BL       OS_PendListRemove
                  |L14.66|
000042  4620              MOV      r0,r4                 ;953
000044  f7fffffe          BL       OS_TaskRdy
000048  3434              ADDS     r4,r4,#0x34           ;953
00004a  70a7              STRB     r7,[r4,#2]            ;954
;;;956                 p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;        /* Indicate no longer pending                        */
;;;957                 break;
00004c  e014              B        |L14.120|
;;;958    
;;;959            case OS_TASK_STATE_PEND_SUSPENDED:
;;;960            case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
;;;961                 if (p_tcb->PendOn == OS_TASK_PEND_ON_MULTI) {
00004e  f8940034          LDRB     r0,[r4,#0x34]
000052  2803              CMP      r0,#3
000054  d102              BNE      |L14.92|
;;;962                     OS_PendAbort1(p_obj,                            /* Indicate which object was pend aborted            */
000056  4630              MOV      r0,r6
000058  f7fffffe          BL       OS_PendAbort1
                  |L14.92|
;;;963                                   p_tcb,
;;;964                                   ts);
;;;965                 }
;;;966    #if (OS_MSG_EN > 0u)
;;;967                 p_tcb->MsgPtr     = (void      *)0;
;;;968                 p_tcb->MsgSize    = (OS_MSG_SIZE)0u;
00005c  65e7              STR      r7,[r4,#0x5c]
00005e  f8a47060          STRH     r7,[r4,#0x60]
;;;969    #endif
;;;970                 p_tcb->TS         = ts;
;;;971                 if (p_obj != (OS_PEND_OBJ *)0) {
000062  6425              STR      r5,[r4,#0x40]
000064  b116              CBZ      r6,|L14.108|
;;;972                     OS_PendListRemove(p_tcb);                       /* Remove task from all pend lists                   */
000066  4620              MOV      r0,r4
000068  f7fffffe          BL       OS_PendListRemove
                  |L14.108|
;;;973                 }
;;;974                 OS_TickListRemove(p_tcb);                           /* Cancel the timeout                                */
00006c  4620              MOV      r0,r4
00006e  f7fffffe          BL       OS_TickListRemove
;;;975                 p_tcb->TaskState  = OS_TASK_STATE_SUSPENDED;        /* Pend Aborted task is still suspended              */
000072  2004              MOVS     r0,#4
000074  3434              ADDS     r4,r4,#0x34
000076  70a0              STRB     r0,[r4,#2]
                  |L14.120|
;;;976                 p_tcb->PendStatus = OS_STATUS_PEND_ABORT;           /* Indicate pend was aborted                         */
000078  f8848001          STRB     r8,[r4,#1]
;;;977                 p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;        /* Indicate no longer pending                        */
00007c  7027              STRB     r7,[r4,#0]
                  |L14.126|
;;;978                 break;
;;;979    
;;;980            default:
;;;981                 break;
;;;982        }
;;;983    }
00007e  e8bd81f0          POP      {r4-r8,pc}
;;;984    
                          ENDP


                          AREA ||i.OS_PendAbort1||, CODE, READONLY, ALIGN=1

                  OS_PendAbort1 PROC
;;;1032   
;;;1033   void  OS_PendAbort1 (OS_PEND_OBJ  *p_obj,
000000  b510              PUSH     {r4,lr}
;;;1034                        OS_TCB       *p_tcb,
;;;1035                        CPU_TS        ts)
;;;1036   {
;;;1037       OS_OBJ_QTY      n_pend_list;                                    /* Number of pend lists                           */
;;;1038       OS_PEND_DATA   *p_pend_data;
;;;1039   
;;;1040   
;;;1041   
;;;1042       p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to the first OS_PEND_DATA to remove      */
;;;1043       n_pend_list = p_tcb->PendDataTblEntries;                        /* Get number of entries in the table             */
000002  6b0b              LDR      r3,[r1,#0x30]
000004  8fc9              LDRH     r1,[r1,#0x3e]
000006  e008              B        |L15.26|
                  |L15.8|
;;;1044   
;;;1045       while (n_pend_list > (OS_OBJ_QTY)0) {                           /* Mark posted object in OS_PEND_DATA table       */
;;;1046           if (p_obj == p_pend_data->PendObjPtr) {                     /* Did we find the object pend aborted?           */
000008  68dc              LDR      r4,[r3,#0xc]
00000a  4284              CMP      r4,r0
00000c  d102              BNE      |L15.20|
;;;1047               p_pend_data->RdyObjPtr = p_obj;                         /* Yes, indicate the object in the .RdyObjPtr     */
;;;1048               p_pend_data->RdyTS     = ts;                            /*      save the timestamp of the pend abort      */
;;;1049               break;
00000e  61da              STR      r2,[r3,#0x1c]
000010  6118              STR      r0,[r3,#0x10]
;;;1050           }
;;;1051           p_pend_data++;
;;;1052           n_pend_list--;
;;;1053       }
;;;1054   }
000012  bd10              POP      {r4,pc}
                  |L15.20|
000014  3320              ADDS     r3,r3,#0x20           ;1051
000016  1e49              SUBS     r1,r1,#1              ;1052
000018  b289              UXTH     r1,r1                 ;1052
                  |L15.26|
00001a  2900              CMP      r1,#0                 ;1045
00001c  d1f4              BNE      |L15.8|
00001e  bd10              POP      {r4,pc}
;;;1055   
                          ENDP


                          AREA ||i.OS_PendDataInit||, CODE, READONLY, ALIGN=1

                  OS_PendDataInit PROC
;;;1097   
;;;1098   void  OS_PendDataInit (OS_TCB        *p_tcb,
000000  b510              PUSH     {r4,lr}
;;;1099                          OS_PEND_DATA  *p_pend_data_tbl,
;;;1100                          OS_OBJ_QTY     tbl_size)
;;;1101   {
;;;1102       OS_OBJ_QTY  i;
;;;1103   
;;;1104   
;;;1105   
;;;1106       p_tcb->PendDataTblEntries = tbl_size;                   /* Link the TCB to the beginning of the table             */
000002  87c2              STRH     r2,[r0,#0x3e]
;;;1107       p_tcb->PendDataTblPtr     = p_pend_data_tbl;
;;;1108   
;;;1109       for (i = 0u; i < tbl_size; i++) {
000004  2400              MOVS     r4,#0
000006  4623              MOV      r3,r4
000008  6301              STR      r1,[r0,#0x30]         ;1101
00000a  e009              B        |L16.32|
                  |L16.12|
;;;1110           p_pend_data_tbl->NextPtr    = (OS_PEND_DATA *)0;    /* Initialize all the fields                              */
;;;1111           p_pend_data_tbl->PrevPtr    = (OS_PEND_DATA *)0;
00000c  604b              STR      r3,[r1,#4]
;;;1112           p_pend_data_tbl->RdyObjPtr  = (OS_PEND_OBJ  *)0;
00000e  600b              STR      r3,[r1,#0]
;;;1113           p_pend_data_tbl->RdyMsgPtr  = (void         *)0;
000010  610b              STR      r3,[r1,#0x10]
;;;1114           p_pend_data_tbl->RdyMsgSize = (OS_MSG_SIZE   )0;
000012  614b              STR      r3,[r1,#0x14]
000014  830b              STRH     r3,[r1,#0x18]
;;;1115           p_pend_data_tbl->RdyTS      = (CPU_TS        )0;
;;;1116           p_pend_data_tbl->TCBPtr     = p_tcb;                /* Every entry points back to the TCB of the task         */
;;;1117           p_pend_data_tbl++;
000016  61cb              STR      r3,[r1,#0x1c]
000018  6088              STR      r0,[r1,#8]
00001a  3120              ADDS     r1,r1,#0x20
00001c  1c64              ADDS     r4,r4,#1              ;1109
00001e  b2a4              UXTH     r4,r4                 ;1109
                  |L16.32|
000020  4294              CMP      r4,r2                 ;1109
000022  d3f3              BCC      |L16.12|
;;;1118       }
;;;1119   }
000024  bd10              POP      {r4,pc}
;;;1120   
                          ENDP


                          AREA ||i.OS_PendDbgNameAdd||, CODE, READONLY, ALIGN=2

                  OS_PendDbgNameAdd PROC
;;;1140   #if OS_CFG_DBG_EN > 0u
;;;1141   void  OS_PendDbgNameAdd (OS_PEND_OBJ  *p_obj,
000000  b138              CBZ      r0,|L17.18|
;;;1142                            OS_TCB       *p_tcb)
;;;1143   {
;;;1144       OS_PEND_LIST  *p_pend_list;
;;;1145       OS_PEND_DATA  *p_pend_data;
;;;1146       OS_TCB        *p_tcb1;
;;;1147   
;;;1148   
;;;1149       if (p_obj != (OS_PEND_OBJ *)0) {
;;;1150           p_tcb->DbgNamePtr =  p_obj->NamePtr;                /* Task pending on this object ... save name in TCB       */
000002  6842              LDR      r2,[r0,#4]
;;;1151           p_pend_list       = &p_obj->PendList;               /* Find name of HP task pending on this object ...        */
;;;1152           p_pend_data       =  p_pend_list->HeadPtr;
000004  f8c120c0          STR      r2,[r1,#0xc0]
;;;1153           p_tcb1            =  p_pend_data->TCBPtr;
000008  6881              LDR      r1,[r0,#8]
00000a  6889              LDR      r1,[r1,#8]
;;;1154           p_obj->DbgNamePtr = p_tcb1->NamePtr;                /* ... Save in object                                     */
00000c  6a09              LDR      r1,[r1,#0x20]
00000e  61c1              STR      r1,[r0,#0x1c]
;;;1155       } else {
;;;1156           switch (p_tcb->PendOn) {
;;;1157               case OS_TASK_PEND_ON_TASK_Q:
;;;1158                    p_tcb->DbgNamePtr = (CPU_CHAR *)((void *)"Task Q");
;;;1159                    break;
;;;1160   
;;;1161               case OS_TASK_PEND_ON_TASK_SEM:
;;;1162                    p_tcb->DbgNamePtr = (CPU_CHAR *)((void *)"Task Sem");
;;;1163                    break;
;;;1164   
;;;1165               default:
;;;1166                    p_tcb->DbgNamePtr = (CPU_CHAR *)((void *)" ");
;;;1167                    break;
;;;1168           }
;;;1169       }
;;;1170   }
000010  4770              BX       lr
                  |L17.18|
000012  f8910034          LDRB     r0,[r1,#0x34]         ;1156
000016  2802              CMP      r0,#2                 ;1156
000018  d003              BEQ      |L17.34|
00001a  2807              CMP      r0,#7                 ;1156
00001c  d003              BEQ      |L17.38|
00001e  a004              ADR      r0,|L17.48|
000020  e002              B        |L17.40|
                  |L17.34|
000022  a004              ADR      r0,|L17.52|
000024  e000              B        |L17.40|
                  |L17.38|
000026  a005              ADR      r0,|L17.60|
                  |L17.40|
000028  f8c100c0          STR      r0,[r1,#0xc0]         ;1158
00002c  4770              BX       lr
;;;1171   
                          ENDP

00002e  0000              DCW      0x0000
                  |L17.48|
000030  2000              DCB      " ",0
000032  00                DCB      0
000033  00                DCB      0
                  |L17.52|
000034  5461736b          DCB      "Task Q",0
000038  205100  
00003b  00                DCB      0
                  |L17.60|
00003c  5461736b          DCB      "Task Sem",0
000040  2053656d
000044  00      
000045  00                DCB      0
000046  00                DCB      0
000047  00                DCB      0

                          AREA ||i.OS_PendDbgNameRemove||, CODE, READONLY, ALIGN=2

                  OS_PendDbgNameRemove PROC
;;;1173   
;;;1174   void  OS_PendDbgNameRemove (OS_PEND_OBJ  *p_obj,
000000  4a05              LDR      r2,|L18.24|
;;;1175                               OS_TCB       *p_tcb)
;;;1176   {
;;;1177       OS_PEND_LIST  *p_pend_list;
;;;1178       OS_PEND_DATA  *p_pend_data;
;;;1179       OS_TCB        *p_tcb1;
;;;1180   
;;;1181   
;;;1182       p_tcb->DbgNamePtr = (CPU_CHAR *)((void *)" ");          /* Remove name of object pended on for readied task       */
;;;1183       p_pend_list       = &p_obj->PendList;
;;;1184       p_pend_data       =  p_pend_list->HeadPtr;
000002  f8c120c0          STR      r2,[r1,#0xc0]
000006  6881              LDR      r1,[r0,#8]            ;1176
000008  b119              CBZ      r1,|L18.18|
;;;1185       if (p_pend_data  != (OS_PEND_DATA *)0) {
;;;1186           p_tcb1            = p_pend_data->TCBPtr;
00000a  6889              LDR      r1,[r1,#8]
;;;1187           p_obj->DbgNamePtr = p_tcb1->NamePtr;
00000c  6a09              LDR      r1,[r1,#0x20]
00000e  61c1              STR      r1,[r0,#0x1c]
;;;1188       } else {
;;;1189           p_obj->DbgNamePtr = (CPU_CHAR *)((void *)" ");      /* No other task pending on object                        */
;;;1190       }
;;;1191   }
000010  4770              BX       lr
                  |L18.18|
000012  61c2              STR      r2,[r0,#0x1c]         ;1189
000014  4770              BX       lr
;;;1192   #endif
                          ENDP

000016  0000              DCW      0x0000
                  |L18.24|
                          DCD      ||.constdata||

                          AREA ||i.OS_PendListChangePrio||, CODE, READONLY, ALIGN=1

                  OS_PendListChangePrio PROC
;;;1275   
;;;1276   void  OS_PendListChangePrio (OS_TCB   *p_tcb,
000000  b570              PUSH     {r4-r6,lr}
;;;1277                                OS_PRIO   prio_new)
;;;1278   {
;;;1279       OS_OBJ_QTY      n_pend_list;                                    /* Number of pend lists                           */
;;;1280       OS_PEND_DATA   *p_pend_data;
;;;1281       OS_PEND_LIST   *p_pend_list;
;;;1282       OS_PEND_OBJ    *p_obj;
;;;1283   
;;;1284   
;;;1285       p_tcb->Prio = prio_new;
000002  f8801037          STRB     r1,[r0,#0x37]
;;;1286       p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to first wait list entry                 */
;;;1287       n_pend_list = p_tcb->PendDataTblEntries;                        /* Get the number of pend list task is in         */
000006  8fc6              LDRH     r6,[r0,#0x3e]
000008  6b05              LDR      r5,[r0,#0x30]         ;1278
00000a  e00f              B        |L19.44|
                  |L19.12|
;;;1288   
;;;1289       while (n_pend_list > 0u) {
;;;1290           p_obj       =  p_pend_data->PendObjPtr;                     /* Get pointer to pend list                       */
;;;1291           p_pend_list = &p_obj->PendList;
00000c  68ec              LDR      r4,[r5,#0xc]
00000e  3408              ADDS     r4,r4,#8
;;;1292           if (p_pend_list->NbrEntries > 1u) {                         /* Only move if multiple entries in the list      */
000010  8920              LDRH     r0,[r4,#8]
000012  2801              CMP      r0,#1
000014  d907              BLS      |L19.38|
;;;1293               OS_PendListRemove1(p_pend_list,                         /* Remove entry from current position             */
000016  4629              MOV      r1,r5
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       OS_PendListRemove1
;;;1294                                  p_pend_data);
;;;1295               OS_PendListInsertPrio(p_pend_list,                      /* INSERT it back in the list                     */
00001e  4629              MOV      r1,r5
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       OS_PendListInsertPrio
                  |L19.38|
;;;1296                                     p_pend_data);
;;;1297           }
;;;1298           p_pend_data++;                                              /* Point to next wait list                        */
000026  3520              ADDS     r5,r5,#0x20
;;;1299           n_pend_list--;
000028  1e76              SUBS     r6,r6,#1
00002a  b2b6              UXTH     r6,r6
                  |L19.44|
00002c  2e00              CMP      r6,#0                 ;1289
00002e  d1ed              BNE      |L19.12|
;;;1300       }
;;;1301   }
000030  bd70              POP      {r4-r6,pc}
;;;1302   
                          ENDP


                          AREA ||i.OS_PendListInit||, CODE, READONLY, ALIGN=1

                  OS_PendListInit PROC
;;;1318   
;;;1319   void  OS_PendListInit (OS_PEND_LIST  *p_pend_list)
000000  2100              MOVS     r1,#0
;;;1320   {
;;;1321       p_pend_list->HeadPtr    = (OS_PEND_DATA *)0;
;;;1322       p_pend_list->TailPtr    = (OS_PEND_DATA *)0;
000002  6001              STR      r1,[r0,#0]
;;;1323       p_pend_list->NbrEntries = (OS_OBJ_QTY    )0;
000004  6041              STR      r1,[r0,#4]
000006  8101              STRH     r1,[r0,#8]
;;;1324   }
000008  4770              BX       lr
;;;1325   
                          ENDP


                          AREA ||i.OS_PendListInsertHead||, CODE, READONLY, ALIGN=1

                  OS_PendListInsertHead PROC
;;;1372   
;;;1373   void  OS_PendListInsertHead (OS_PEND_LIST  *p_pend_list,
000000  8902              LDRH     r2,[r0,#8]
;;;1374                                OS_PEND_DATA  *p_pend_data)
;;;1375   {
;;;1376       OS_PEND_DATA  *p_pend_data_next;
;;;1377   
;;;1378   
;;;1379   
;;;1380       p_pend_list->NbrEntries++;                              /* One more entry in the list                             */
000002  1c52              ADDS     r2,r2,#1
000004  8102              STRH     r2,[r0,#8]
;;;1381       p_pend_data->NextPtr  = p_pend_list->HeadPtr;           /* Adjust new entry's links                               */
000006  6802              LDR      r2,[r0,#0]
;;;1382       p_pend_data->PrevPtr  = (OS_PEND_DATA  *)0;
000008  604a              STR      r2,[r1,#4]
00000a  2200              MOVS     r2,#0
;;;1383       p_pend_data_next      = p_pend_list->HeadPtr;           /* Adjust old head of list's links                        */
00000c  600a              STR      r2,[r1,#0]
00000e  6802              LDR      r2,[r0,#0]            ;1375
000010  b102              CBZ      r2,|L21.20|
;;;1384       if (p_pend_data_next != (OS_PEND_DATA *)0) {            /* See if we already have a head to replace               */
;;;1385           p_pend_data_next->PrevPtr = p_pend_data;            /* Yes, point to new entry                                */
000012  6011              STR      r1,[r2,#0]
                  |L21.20|
;;;1386       }
;;;1387       p_pend_list->HeadPtr = p_pend_data;                     /* We have a new list head                                */
;;;1388       if (p_pend_list->NbrEntries == 1u) {
000014  6001              STR      r1,[r0,#0]
000016  8902              LDRH     r2,[r0,#8]
000018  2a01              CMP      r2,#1
00001a  d100              BNE      |L21.30|
;;;1389           p_pend_list->TailPtr = p_pend_data;
00001c  6041              STR      r1,[r0,#4]
                  |L21.30|
;;;1390       }
;;;1391   }
00001e  4770              BX       lr
;;;1392   
                          ENDP


                          AREA ||i.OS_PendListInsertPrio||, CODE, READONLY, ALIGN=1

                  OS_PendListInsertPrio PROC
;;;1460   
;;;1461   void  OS_PendListInsertPrio (OS_PEND_LIST  *p_pend_list,
000000  b530              PUSH     {r4,r5,lr}
;;;1462                                OS_PEND_DATA  *p_pend_data)
;;;1463   {
;;;1464       OS_PRIO        prio;
;;;1465       OS_TCB        *p_tcb;
;;;1466       OS_TCB        *p_tcb_next;
;;;1467       OS_PEND_DATA  *p_pend_data_prev;
;;;1468       OS_PEND_DATA  *p_pend_data_next;
;;;1469   
;;;1470   
;;;1471   
;;;1472       p_tcb = p_pend_data->TCBPtr;                                      /* Obtain the priority of the task to insert    */
;;;1473       prio  = p_tcb->Prio;
000002  688a              LDR      r2,[r1,#8]
;;;1474       if (p_pend_list->NbrEntries == (OS_OBJ_QTY)0) {                   /* CASE 0: Insert when there are no entries     */
000004  2300              MOVS     r3,#0
000006  f8924037          LDRB     r4,[r2,#0x37]         ;1473
00000a  8902              LDRH     r2,[r0,#8]
00000c  b11a              CBZ      r2,|L22.22|
;;;1475           p_pend_list->NbrEntries = (OS_OBJ_QTY)1;                      /*         This is the first entry              */
;;;1476           p_pend_data->NextPtr    = (OS_PEND_DATA *)0;                  /*         No other OS_PEND_DATAs in the list   */
;;;1477           p_pend_data->PrevPtr    = (OS_PEND_DATA *)0;
;;;1478           p_pend_list->HeadPtr    = p_pend_data;                        /*                                              */
;;;1479           p_pend_list->TailPtr    = p_pend_data;
;;;1480       } else {
;;;1481           p_pend_list->NbrEntries++;                                    /* CASE 1: One more OS_PEND_DATA in the list    */
00000e  1c52              ADDS     r2,r2,#1
000010  8102              STRH     r2,[r0,#8]
;;;1482           p_pend_data_next = p_pend_list->HeadPtr;
;;;1483           while (p_pend_data_next != (OS_PEND_DATA *)0) {               /*         Find the position where to insert    */
000012  6802              LDR      r2,[r0,#0]
000014  e00b              B        |L22.46|
                  |L22.22|
000016  2201              MOVS     r2,#1                 ;1475
000018  8102              STRH     r2,[r0,#8]            ;1475
00001a  604b              STR      r3,[r1,#4]            ;1477
00001c  600b              STR      r3,[r1,#0]            ;1478
00001e  6001              STR      r1,[r0,#0]            ;1479
000020  e014              B        |L22.76|
                  |L22.34|
;;;1484               p_tcb_next   = p_pend_data_next->TCBPtr;
;;;1485               if (prio < p_tcb_next->Prio) {
000022  6895              LDR      r5,[r2,#8]
000024  f8955037          LDRB     r5,[r5,#0x37]
000028  42a5              CMP      r5,r4
00002a  d803              BHI      |L22.52|
;;;1486                   break;                                                /*         Found! ... insert BEFORE current     */
;;;1487               } else {
;;;1488                   p_pend_data_next = p_pend_data_next->NextPtr;         /*         Not Found, follow the list           */
00002c  6852              LDR      r2,[r2,#4]
                  |L22.46|
00002e  2a00              CMP      r2,#0                 ;1483
000030  d1f7              BNE      |L22.34|
000032  e007              B        |L22.68|
                  |L22.52|
;;;1489               }
;;;1490           }
;;;1491           if (p_pend_data_next == (OS_PEND_DATA *)0) {                  /*         TCB to insert is lower in prio       */
000034  b132              CBZ      r2,|L22.68|
;;;1492               p_pend_data->NextPtr      = (OS_PEND_DATA *)0;            /*         ... insert at the tail.              */
;;;1493               p_pend_data_prev          = p_pend_list->TailPtr;
;;;1494               p_pend_data->PrevPtr      = p_pend_data_prev;
;;;1495               p_pend_data_prev->NextPtr = p_pend_data;
;;;1496               p_pend_list->TailPtr      = p_pend_data;
;;;1497           } else {
;;;1498               if (p_pend_data_next->PrevPtr == (OS_PEND_DATA *)0) {     /*         Is new TCB highest priority?         */
000036  6814              LDR      r4,[r2,#0]
000038  b154              CBZ      r4,|L22.80|
00003a  e9c14200          STRD     r4,r2,[r1,#0]
;;;1499                   p_pend_data_next->PrevPtr  = p_pend_data;             /*         Yes, insert as new Head of list      */
;;;1500                   p_pend_data->PrevPtr       = (OS_PEND_DATA *)0;
;;;1501                   p_pend_data->NextPtr       = p_pend_data_next;
;;;1502                   p_pend_list->HeadPtr       = p_pend_data;
;;;1503               } else {
;;;1504                   p_pend_data_prev           = p_pend_data_next->PrevPtr;/*        No,  insert in between two entries   */
;;;1505                   p_pend_data->PrevPtr       = p_pend_data_prev;
;;;1506                   p_pend_data->NextPtr       = p_pend_data_next;
;;;1507                   p_pend_data_prev->NextPtr  = p_pend_data;
;;;1508                   p_pend_data_next->PrevPtr  = p_pend_data;
00003e  6061              STR      r1,[r4,#4]
000040  6011              STR      r1,[r2,#0]
;;;1509               }
;;;1510           }
;;;1511       }
;;;1512   }
000042  bd30              POP      {r4,r5,pc}
                  |L22.68|
000044  604b              STR      r3,[r1,#4]            ;1493
000046  6842              LDR      r2,[r0,#4]            ;1494
000048  600a              STR      r2,[r1,#0]            ;1495
00004a  6051              STR      r1,[r2,#4]            ;1495
                  |L22.76|
00004c  6041              STR      r1,[r0,#4]            ;1479
00004e  bd30              POP      {r4,r5,pc}
                  |L22.80|
000050  6011              STR      r1,[r2,#0]            ;1499
000052  e9c13200          STRD     r3,r2,[r1,#0]         ;1499
000056  6001              STR      r1,[r0,#0]            ;1502
000058  bd30              POP      {r4,r5,pc}
;;;1513   
                          ENDP


                          AREA ||i.OS_PendListRemove||, CODE, READONLY, ALIGN=1

                  OS_PendListRemove PROC
;;;1563   
;;;1564   void  OS_PendListRemove (OS_TCB  *p_tcb)
000000  b570              PUSH     {r4-r6,lr}
;;;1565   {
000002  4606              MOV      r6,r0
;;;1566       OS_OBJ_QTY      n_pend_list;                                    /* Number of pend lists                           */
;;;1567       OS_PEND_DATA   *p_pend_data;
;;;1568       OS_PEND_LIST   *p_pend_list;
;;;1569       OS_PEND_OBJ    *p_obj;
;;;1570   
;;;1571   
;;;1572   
;;;1573       p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to the first OS_PEND_DATA to remove      */
;;;1574       n_pend_list = p_tcb->PendDataTblEntries;                        /* Get number of entries in the table             */
000004  8fc4              LDRH     r4,[r0,#0x3e]
000006  6b05              LDR      r5,[r0,#0x30]         ;1565
000008  e007              B        |L23.26|
                  |L23.10|
;;;1575   
;;;1576       while (n_pend_list > (OS_OBJ_QTY)0) {
;;;1577           p_obj       =  p_pend_data->PendObjPtr;                     /* Get pointer to pend list                       */
;;;1578           p_pend_list = &p_obj->PendList;
00000a  68e8              LDR      r0,[r5,#0xc]
;;;1579           OS_PendListRemove1(p_pend_list,
00000c  4629              MOV      r1,r5
00000e  3008              ADDS     r0,r0,#8              ;1578
000010  f7fffffe          BL       OS_PendListRemove1
;;;1580                              p_pend_data);
;;;1581           p_pend_data++;
000014  3520              ADDS     r5,r5,#0x20
;;;1582           n_pend_list--;
000016  1e64              SUBS     r4,r4,#1
000018  b2a4              UXTH     r4,r4
                  |L23.26|
00001a  2c00              CMP      r4,#0                 ;1576
00001c  d1f5              BNE      |L23.10|
;;;1583       }
;;;1584       p_tcb->PendDataTblEntries = (OS_OBJ_QTY    )0;
00001e  2000              MOVS     r0,#0
000020  87f0              STRH     r0,[r6,#0x3e]
;;;1585       p_tcb->PendDataTblPtr     = (OS_PEND_DATA *)0;
000022  6330              STR      r0,[r6,#0x30]
;;;1586   }
000024  bd70              POP      {r4-r6,pc}
;;;1587   
                          ENDP


                          AREA ||i.OS_PendListRemove1||, CODE, READONLY, ALIGN=1

                  OS_PendListRemove1 PROC
;;;1638   
;;;1639   void  OS_PendListRemove1 (OS_PEND_LIST  *p_pend_list,
000000  b510              PUSH     {r4,lr}
;;;1640                             OS_PEND_DATA  *p_pend_data)
;;;1641   {
;;;1642       OS_PEND_DATA  *p_prev;
;;;1643       OS_PEND_DATA  *p_next;
;;;1644   
;;;1645   
;;;1646   
;;;1647       if (p_pend_list->NbrEntries == 1u) {
000002  8902              LDRH     r2,[r0,#8]
000004  2300              MOVS     r3,#0
000006  2a01              CMP      r2,#1
000008  d00b              BEQ      |L24.34|
;;;1648           p_pend_list->HeadPtr = (OS_PEND_DATA *)0;           /* Only one entry in the pend list                        */
;;;1649           p_pend_list->TailPtr = (OS_PEND_DATA *)0;
;;;1650   
;;;1651       } else if (p_pend_data->PrevPtr == (OS_PEND_DATA *)0) { /* See if entry is at the head of the list                */
00000a  680a              LDR      r2,[r1,#0]
00000c  b162              CBZ      r2,|L24.40|
;;;1652           p_next               = p_pend_data->NextPtr;        /* Yes                                                    */
;;;1653           p_next->PrevPtr      = (OS_PEND_DATA *)0;
;;;1654           p_pend_list->HeadPtr = p_next;
;;;1655   
;;;1656       } else if (p_pend_data->NextPtr == (OS_PEND_DATA *)0) { /* See if entry is at the tail of the list                */
00000e  684c              LDR      r4,[r1,#4]
000010  b174              CBZ      r4,|L24.48|
;;;1657           p_prev               = p_pend_data->PrevPtr;        /* Yes                                                    */
;;;1658           p_prev->NextPtr      = (OS_PEND_DATA *)0;
;;;1659           p_pend_list->TailPtr = p_prev;
;;;1660   
;;;1661       } else {
;;;1662           p_prev               = p_pend_data->PrevPtr;        /* Remove from inside the list                            */
;;;1663           p_next               = p_pend_data->NextPtr;
;;;1664           p_prev->NextPtr      = p_next;
;;;1665           p_next->PrevPtr      = p_prev;
000012  6054              STR      r4,[r2,#4]
000014  6022              STR      r2,[r4,#0]
                  |L24.22|
;;;1666       }
;;;1667       p_pend_list->NbrEntries--;                              /* One less entry in the list                             */
000016  8902              LDRH     r2,[r0,#8]
000018  1e52              SUBS     r2,r2,#1
00001a  8102              STRH     r2,[r0,#8]
;;;1668       p_pend_data->NextPtr = (OS_PEND_DATA *)0;
;;;1669       p_pend_data->PrevPtr = (OS_PEND_DATA *)0;
00001c  604b              STR      r3,[r1,#4]
;;;1670   }
00001e  600b              STR      r3,[r1,#0]
000020  bd10              POP      {r4,pc}
                  |L24.34|
000022  6003              STR      r3,[r0,#0]            ;1649
000024  6043              STR      r3,[r0,#4]            ;1649
000026  e7f6              B        |L24.22|
                  |L24.40|
000028  684a              LDR      r2,[r1,#4]            ;1653
00002a  6013              STR      r3,[r2,#0]            ;1654
00002c  6002              STR      r2,[r0,#0]            ;1654
00002e  e7f2              B        |L24.22|
                  |L24.48|
000030  6053              STR      r3,[r2,#4]            ;1659
000032  6042              STR      r2,[r0,#4]            ;1659
000034  e7ef              B        |L24.22|
;;;1671   
                          ENDP


                          AREA ||i.OS_PendObjDel||, CODE, READONLY, ALIGN=1

                  OS_PendObjDel PROC
;;;1692   
;;;1693   void  OS_PendObjDel (OS_PEND_OBJ  *p_obj,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1694                        OS_TCB       *p_tcb,
;;;1695                        CPU_TS        ts)
;;;1696   {
000004  460c              MOV      r4,r1
;;;1697       switch (p_tcb->TaskState) {
000006  f8911036          LDRB     r1,[r1,#0x36]
00000a  2500              MOVS     r5,#0
;;;1698           case OS_TASK_STATE_RDY:                                  /* These states should never occur                   */
;;;1699           case OS_TASK_STATE_DLY:
;;;1700           case OS_TASK_STATE_SUSPENDED:
;;;1701           case OS_TASK_STATE_DLY_SUSPENDED:
;;;1702                break;
;;;1703   
;;;1704           case OS_TASK_STATE_PEND:
;;;1705           case OS_TASK_STATE_PEND_TIMEOUT:
;;;1706                if (p_tcb->PendOn == OS_TASK_PEND_ON_MULTI) {
;;;1707                    OS_PendObjDel1(p_obj,                           /* Indicate which object was pend aborted            */
;;;1708                                   p_tcb,
;;;1709                                   ts);
;;;1710                }
;;;1711   #if (OS_MSG_EN > 0u)
;;;1712                p_tcb->MsgPtr     = (void *)0;
;;;1713                p_tcb->MsgSize    = (OS_MSG_SIZE)0u;
;;;1714   #endif
;;;1715                p_tcb->TS         = ts;
;;;1716                OS_PendListRemove(p_tcb);                           /* Remove task from all wait lists                   */
;;;1717                OS_TaskRdy(p_tcb);
;;;1718                p_tcb->TaskState  = OS_TASK_STATE_RDY;              /* Task is readied because object is deleted         */
;;;1719                p_tcb->PendStatus = OS_STATUS_PEND_DEL;             /* Indicate pend was aborted                         */
00000c  2702              MOVS     r7,#2
00000e  4616              MOV      r6,r2                 ;1696
000010  2908              CMP      r1,#8                 ;1697
000012  d22f              BCS      |L25.116|
000014  e8dff001          TBB      [pc,r1]               ;1697
000018  2e2e0404          DCB      0x2e,0x2e,0x04,0x04
00001c  2e2e1818          DCB      0x2e,0x2e,0x18,0x18
000020  f8941034          LDRB     r1,[r4,#0x34]         ;1706
000024  2903              CMP      r1,#3                 ;1706
000026  d102              BNE      |L25.46|
000028  4621              MOV      r1,r4                 ;1707
00002a  f7fffffe          BL       OS_PendObjDel1
                  |L25.46|
00002e  65e5              STR      r5,[r4,#0x5c]         ;1713
000030  f8a45060          STRH     r5,[r4,#0x60]         ;1713
000034  4620              MOV      r0,r4                 ;1716
000036  6426              STR      r6,[r4,#0x40]         ;1716
000038  f7fffffe          BL       OS_PendListRemove
00003c  4620              MOV      r0,r4                 ;1717
00003e  f7fffffe          BL       OS_TaskRdy
000042  3434              ADDS     r4,r4,#0x34           ;1717
000044  70a5              STRB     r5,[r4,#2]            ;1718
;;;1720                p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;
;;;1721                break;
000046  e013              B        |L25.112|
;;;1722   
;;;1723           case OS_TASK_STATE_PEND_SUSPENDED:
;;;1724           case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
;;;1725                if (p_tcb->PendOn == OS_TASK_PEND_ON_MULTI) {
000048  f8941034          LDRB     r1,[r4,#0x34]
00004c  2903              CMP      r1,#3
00004e  d102              BNE      |L25.86|
;;;1726                    OS_PendObjDel1(p_obj,                           /* Indicate which object was pend aborted            */
000050  4621              MOV      r1,r4
000052  f7fffffe          BL       OS_PendObjDel1
                  |L25.86|
;;;1727                                   p_tcb,
;;;1728                                   ts);
;;;1729                }
;;;1730   #if (OS_MSG_EN > 0u)
;;;1731                p_tcb->MsgPtr     = (void      *)0;
;;;1732                p_tcb->MsgSize    = (OS_MSG_SIZE)0u;
000056  65e5              STR      r5,[r4,#0x5c]
000058  f8a45060          STRH     r5,[r4,#0x60]
;;;1733   #endif
;;;1734                p_tcb->TS         = ts;
;;;1735                OS_TickListRemove(p_tcb);                           /* Cancel the timeout                                */
00005c  4620              MOV      r0,r4
00005e  6426              STR      r6,[r4,#0x40]
000060  f7fffffe          BL       OS_TickListRemove
;;;1736                OS_PendListRemove(p_tcb);                           /* Remove task from all wait lists                   */
000064  4620              MOV      r0,r4
000066  f7fffffe          BL       OS_PendListRemove
;;;1737                p_tcb->TaskState  = OS_TASK_STATE_SUSPENDED;        /* Task needs to remain suspended                    */
00006a  2004              MOVS     r0,#4
00006c  3434              ADDS     r4,r4,#0x34
00006e  70a0              STRB     r0,[r4,#2]
                  |L25.112|
;;;1738                p_tcb->PendStatus = OS_STATUS_PEND_DEL;             /* Indicate pend was aborted                         */
000070  7067              STRB     r7,[r4,#1]
;;;1739                p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;        /* Indicate no longer pending                        */
000072  7025              STRB     r5,[r4,#0]
                  |L25.116|
;;;1740                break;
;;;1741   
;;;1742           default:
;;;1743                break;
;;;1744       }
;;;1745   }
000074  e8bd81f0          POP      {r4-r8,pc}
;;;1746   
                          ENDP


                          AREA ||i.OS_PendObjDel1||, CODE, READONLY, ALIGN=1

                  OS_PendObjDel1 PROC
;;;1794   
;;;1795   void  OS_PendObjDel1 (OS_PEND_OBJ  *p_obj,
000000  b510              PUSH     {r4,lr}
;;;1796                         OS_TCB       *p_tcb,
;;;1797                         CPU_TS        ts)
;;;1798   {
;;;1799       OS_OBJ_QTY      n_pend_list;                                    /* Number of pend lists                           */
;;;1800       OS_PEND_DATA   *p_pend_data;
;;;1801   
;;;1802   
;;;1803   
;;;1804       p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to the first OS_PEND_DATA to remove      */
;;;1805       n_pend_list = p_tcb->PendDataTblEntries;                        /* Get number of entries in the table             */
000002  6b0b              LDR      r3,[r1,#0x30]
000004  8fc9              LDRH     r1,[r1,#0x3e]
000006  e008              B        |L26.26|
                  |L26.8|
;;;1806   
;;;1807       while (n_pend_list > (OS_OBJ_QTY)0) {                           /* Mark posted object in OS_PEND_DATA table       */
;;;1808           if (p_obj == p_pend_data->PendObjPtr) {                     /* Did we find the object deleted?                */
000008  68dc              LDR      r4,[r3,#0xc]
00000a  4284              CMP      r4,r0
00000c  d102              BNE      |L26.20|
;;;1809               p_pend_data->RdyObjPtr = p_obj;                         /* Yes, indicate the object in the .RdyObjPtr     */
;;;1810               p_pend_data->RdyTS     = ts;                            /*      save the timestamp                        */
;;;1811               break;
00000e  61da              STR      r2,[r3,#0x1c]
000010  6118              STR      r0,[r3,#0x10]
;;;1812           }
;;;1813           p_pend_data++;
;;;1814           n_pend_list--;
;;;1815       }
;;;1816   }
000012  bd10              POP      {r4,pc}
                  |L26.20|
000014  3320              ADDS     r3,r3,#0x20           ;1813
000016  1e49              SUBS     r1,r1,#1              ;1814
000018  b289              UXTH     r1,r1                 ;1814
                  |L26.26|
00001a  2900              CMP      r1,#0                 ;1807
00001c  d1f4              BNE      |L26.8|
00001e  bd10              POP      {r4,pc}
;;;1817   
                          ENDP


                          AREA ||i.OS_Post||, CODE, READONLY, ALIGN=1

                  OS_Post PROC
;;;1843   
;;;1844   void  OS_Post (OS_PEND_OBJ  *p_obj,
000000  b5f8              PUSH     {r3-r7,lr}
;;;1845                  OS_TCB       *p_tcb,
;;;1846                  void         *p_void,
;;;1847                  OS_MSG_SIZE   msg_size,
;;;1848                  CPU_TS        ts)
;;;1849   {
000002  460c              MOV      r4,r1
000004  4606              MOV      r6,r0
;;;1850       switch (p_tcb->TaskState) {
000006  f8911036          LDRB     r1,[r1,#0x36]
00000a  2500              MOVS     r5,#0
00000c  9806              LDR      r0,[sp,#0x18]
00000e  461f              MOV      r7,r3                 ;1849
000010  2908              CMP      r1,#8
000012  d23a              BCS      |L27.138|
000014  e8dff001          TBB      [pc,r1]
000018  39390404          DCB      0x39,0x39,0x04,0x04
00001c  39392121          DCB      0x39,0x39,0x21,0x21
;;;1851           case OS_TASK_STATE_RDY:                                  /* Cannot Pend Abort a task that is ready            */
;;;1852           case OS_TASK_STATE_DLY:                                  /* Cannot Pend Abort a task that is delayed          */
;;;1853           case OS_TASK_STATE_SUSPENDED:                            /* Cannot Post a suspended task                      */
;;;1854           case OS_TASK_STATE_DLY_SUSPENDED:                        /* Cannot Post a suspended task that was also dly'd  */
;;;1855                break;
;;;1856   
;;;1857           case OS_TASK_STATE_PEND:
;;;1858           case OS_TASK_STATE_PEND_TIMEOUT:
;;;1859                if (p_tcb->PendOn == OS_TASK_PEND_ON_MULTI) {
000020  f8941034          LDRB     r1,[r4,#0x34]
000024  2903              CMP      r1,#3
000026  d011              BEQ      |L27.76|
;;;1860                    OS_Post1(p_obj,                                 /* Indicate which object was posted to               */
;;;1861                             p_tcb,
;;;1862                             p_void,
;;;1863                             msg_size,
;;;1864                             ts);
;;;1865                } else {
;;;1866   #if (OS_MSG_EN > 0u)
;;;1867                    p_tcb->MsgPtr  = p_void;                        /* Deposit message in OS_TCB of task waiting         */
;;;1868                    p_tcb->MsgSize = msg_size;                      /* ... assuming posting a message                    */
000028  65e2              STR      r2,[r4,#0x5c]
00002a  f8a47060          STRH     r7,[r4,#0x60]
;;;1869   #endif
;;;1870                    p_tcb->TS      = ts;
00002e  6420              STR      r0,[r4,#0x40]
                  |L27.48|
;;;1871                }
;;;1872                if (p_obj != (OS_PEND_OBJ *)0) {
000030  b136              CBZ      r6,|L27.64|
;;;1873                    OS_PendListRemove(p_tcb);                       /* Remove task from wait list(s)                     */
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       OS_PendListRemove
;;;1874   #if OS_CFG_DBG_EN > 0u
;;;1875                    OS_PendDbgNameRemove(p_obj,
000038  4621              MOV      r1,r4
00003a  4630              MOV      r0,r6
00003c  f7fffffe          BL       OS_PendDbgNameRemove
                  |L27.64|
;;;1876                                         p_tcb);
;;;1877   #endif
;;;1878                }
;;;1879                OS_TaskRdy(p_tcb);                                  /* Make task ready to run                            */
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       OS_TaskRdy
000046  3434              ADDS     r4,r4,#0x34
;;;1880                p_tcb->TaskState  = OS_TASK_STATE_RDY;
000048  70a5              STRB     r5,[r4,#2]
;;;1881                p_tcb->PendStatus = OS_STATUS_PEND_OK;              /* Clear pend status                                 */
;;;1882                p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;        /* Indicate no longer pending                        */
;;;1883                break;
00004a  e01c              B        |L27.134|
                  |L27.76|
00004c  9000              STR      r0,[sp,#0]            ;1860
00004e  463b              MOV      r3,r7                 ;1860
000050  4621              MOV      r1,r4                 ;1860
000052  4630              MOV      r0,r6                 ;1860
000054  f7fffffe          BL       OS_Post1
000058  e7ea              B        |L27.48|
;;;1884   
;;;1885           case OS_TASK_STATE_PEND_SUSPENDED:
;;;1886           case OS_TASK_STATE_PEND_TIMEOUT_SUSPENDED:
;;;1887                if (p_tcb->PendOn == OS_TASK_PEND_ON_MULTI) {
00005a  f8941034          LDRB     r1,[r4,#0x34]
00005e  2903              CMP      r1,#3
000060  d014              BEQ      |L27.140|
;;;1888                    OS_Post1(p_obj,                                 /* Indicate which object was posted to               */
;;;1889                             p_tcb,
;;;1890                             p_void,
;;;1891                             msg_size,
;;;1892                             ts);
;;;1893                } else {
;;;1894   #if (OS_MSG_EN > 0u)
;;;1895                    p_tcb->MsgPtr  = p_void;                        /* Deposit message in OS_TCB of task waiting         */
;;;1896                    p_tcb->MsgSize = msg_size;                      /* ... assuming posting a message                    */
000062  65e2              STR      r2,[r4,#0x5c]
000064  f8a47060          STRH     r7,[r4,#0x60]
;;;1897   #endif
;;;1898                    p_tcb->TS      = ts;
000068  6420              STR      r0,[r4,#0x40]
                  |L27.106|
;;;1899                }
;;;1900                OS_TickListRemove(p_tcb);                           /* Cancel any timeout                                */
00006a  4620              MOV      r0,r4
00006c  f7fffffe          BL       OS_TickListRemove
;;;1901                if (p_obj != (OS_PEND_OBJ *)0) {
000070  b136              CBZ      r6,|L27.128|
;;;1902                    OS_PendListRemove(p_tcb);                       /* Remove task from wait list(s)                     */
000072  4620              MOV      r0,r4
000074  f7fffffe          BL       OS_PendListRemove
;;;1903   #if OS_CFG_DBG_EN > 0u
;;;1904                    OS_PendDbgNameRemove(p_obj,
000078  4621              MOV      r1,r4
00007a  4630              MOV      r0,r6
00007c  f7fffffe          BL       OS_PendDbgNameRemove
                  |L27.128|
;;;1905                                         p_tcb);
;;;1906   #endif
;;;1907                }
;;;1908                p_tcb->TaskState  = OS_TASK_STATE_SUSPENDED;
000080  2004              MOVS     r0,#4
000082  3434              ADDS     r4,r4,#0x34
000084  70a0              STRB     r0,[r4,#2]
                  |L27.134|
;;;1909                p_tcb->PendStatus = OS_STATUS_PEND_OK;              /* Clear pend status                                 */
000086  7065              STRB     r5,[r4,#1]
;;;1910                p_tcb->PendOn     = OS_TASK_PEND_ON_NOTHING;        /* Indicate no longer pending                        */
000088  7025              STRB     r5,[r4,#0]
                  |L27.138|
;;;1911                break;
;;;1912   
;;;1913           default:
;;;1914                break;
;;;1915       }
;;;1916   }
00008a  bdf8              POP      {r3-r7,pc}
                  |L27.140|
00008c  9000              STR      r0,[sp,#0]            ;1888
00008e  463b              MOV      r3,r7                 ;1888
000090  4621              MOV      r1,r4                 ;1888
000092  4630              MOV      r0,r6                 ;1888
000094  f7fffffe          BL       OS_Post1
000098  e7e7              B        |L27.106|
;;;1917   
                          ENDP


                          AREA ||i.OS_Post1||, CODE, READONLY, ALIGN=1

                  OS_Post1 PROC
;;;1969   
;;;1970   void  OS_Post1 (OS_PEND_OBJ  *p_obj,
000000  b570              PUSH     {r4-r6,lr}
;;;1971                   OS_TCB       *p_tcb,
;;;1972                   void         *p_void,
;;;1973                   OS_MSG_SIZE   msg_size,
;;;1974                   CPU_TS        ts)
;;;1975   {
;;;1976       OS_OBJ_QTY      n_pend_list;                                    /* Number of pend lists                           */
;;;1977       OS_PEND_DATA   *p_pend_data;
;;;1978   
;;;1979   
;;;1980   
;;;1981       p_pend_data = p_tcb->PendDataTblPtr;                            /* Point to the first OS_PEND_DATA to remove      */
;;;1982       n_pend_list = p_tcb->PendDataTblEntries;                        /* Get number of entries in the table             */
000002  6b0c              LDR      r4,[r1,#0x30]
000004  9d04              LDR      r5,[sp,#0x10]         ;1981
000006  8fc9              LDRH     r1,[r1,#0x3e]
000008  e00a              B        |L28.32|
                  |L28.10|
;;;1983   
;;;1984       while (n_pend_list > (OS_OBJ_QTY)0) {                           /* Mark posted object in OS_PEND_DATA table       */
;;;1985           if (p_obj == p_pend_data->PendObjPtr) {                     /* Did we find the object posted to?              */
00000a  68e6              LDR      r6,[r4,#0xc]
00000c  4286              CMP      r6,r0
00000e  d104              BNE      |L28.26|
000010  e9c40204          STRD     r0,r2,[r4,#0x10]
;;;1986               p_pend_data->RdyObjPtr  = p_obj;                        /* Yes, indicate the object in the .RdyObjPtr     */
;;;1987               p_pend_data->RdyMsgPtr  = p_void;                       /*      store the message posted                  */
;;;1988               p_pend_data->RdyMsgSize = msg_size;                     /*      store the size of the message posted      */
000014  8323              STRH     r3,[r4,#0x18]
;;;1989               p_pend_data->RdyTS      = ts;                           /*      save the timestamp of the post            */
;;;1990               break;
000016  61e5              STR      r5,[r4,#0x1c]
;;;1991           }
;;;1992           p_pend_data++;
;;;1993           n_pend_list--;
;;;1994       }
;;;1995   }
000018  bd70              POP      {r4-r6,pc}
                  |L28.26|
00001a  3420              ADDS     r4,r4,#0x20           ;1992
00001c  1e49              SUBS     r1,r1,#1              ;1993
00001e  b289              UXTH     r1,r1                 ;1993
                  |L28.32|
000020  2900              CMP      r1,#0                 ;1984
000022  d1f2              BNE      |L28.10|
000024  bd70              POP      {r4-r6,pc}
;;;1996   
                          ENDP


                          AREA ||i.OS_RdyListInit||, CODE, READONLY, ALIGN=2

                  OS_RdyListInit PROC
;;;2039   
;;;2040   void  OS_RdyListInit (void)
000000  2000              MOVS     r0,#0
;;;2041   {
;;;2042       OS_PRIO       i;
;;;2043       OS_RDY_LIST  *p_rdy_list;
;;;2044   
;;;2045   
;;;2046   
;;;2047       for (i = 0u; i < OS_CFG_PRIO_MAX; i++) {                /* Initialize the array of OS_RDY_LIST at each priority   */
;;;2048           p_rdy_list = &OSRdyList[i];
000002  4b07              LDR      r3,|L29.32|
000004  4601              MOV      r1,r0                 ;2047
000006  bf00              NOP      
                  |L29.8|
000008  eb000240          ADD      r2,r0,r0,LSL #1
00000c  eb030282          ADD      r2,r3,r2,LSL #2
000010  1c40              ADDS     r0,r0,#1              ;2047
;;;2049           p_rdy_list->NbrEntries = (OS_OBJ_QTY)0;
000012  8111              STRH     r1,[r2,#8]
;;;2050           p_rdy_list->HeadPtr    = (OS_TCB   *)0;
;;;2051           p_rdy_list->TailPtr    = (OS_TCB   *)0;
000014  6011              STR      r1,[r2,#0]
000016  b2c0              UXTB     r0,r0                 ;2047
000018  6051              STR      r1,[r2,#4]            ;2047
00001a  2840              CMP      r0,#0x40              ;2047
00001c  d3f4              BCC      |L29.8|
;;;2052       }
;;;2053   }
00001e  4770              BX       lr
;;;2054   
                          ENDP

                  |L29.32|
                          DCD      OSRdyList

                          AREA ||i.OS_RdyListInsert||, CODE, READONLY, ALIGN=2

                  OS_RdyListInsert PROC
;;;2073   
;;;2074   void  OS_RdyListInsert (OS_TCB  *p_tcb)
000000  b510              PUSH     {r4,lr}
;;;2075   {
000002  4604              MOV      r4,r0
;;;2076       OS_PrioInsert(p_tcb->Prio);
000004  f8900037          LDRB     r0,[r0,#0x37]
000008  f7fffffe          BL       OS_PrioInsert
;;;2077       if (p_tcb->Prio == OSPrioCur) {                         /* Are we readying a task at the same prio?               */
00000c  4907              LDR      r1,|L30.44|
00000e  f8940037          LDRB     r0,[r4,#0x37]
000012  7809              LDRB     r1,[r1,#0]  ; OSPrioCur
000014  4288              CMP      r0,r1
;;;2078           OS_RdyListInsertTail(p_tcb);                        /* Yes, insert readied task at the end of the list        */
;;;2079       } else {
;;;2080           OS_RdyListInsertHead(p_tcb);                        /* No,  insert readied task at the beginning of the list  */
000016  4620              MOV      r0,r4
000018  d103              BNE      |L30.34|
00001a  e8bd4010          POP      {r4,lr}               ;2078
00001e  f7ffbffe          B.W      OS_RdyListInsertTail
                  |L30.34|
000022  e8bd4010          POP      {r4,lr}
000026  f7ffbffe          B.W      OS_RdyListInsertHead
;;;2081       }
;;;2082   }
;;;2083   
                          ENDP

00002a  0000              DCW      0x0000
                  |L30.44|
                          DCD      OSPrioCur

                          AREA ||i.OS_RdyListInsertHead||, CODE, READONLY, ALIGN=2

                  OS_RdyListInsertHead PROC
;;;2140   
;;;2141   void  OS_RdyListInsertHead (OS_TCB  *p_tcb)
000000  f8901037          LDRB     r1,[r0,#0x37]
;;;2142   {
;;;2143       OS_RDY_LIST  *p_rdy_list;
;;;2144       OS_TCB       *p_tcb2;
;;;2145   
;;;2146   
;;;2147   
;;;2148       p_rdy_list = &OSRdyList[p_tcb->Prio];
000004  4a0b              LDR      r2,|L31.52|
000006  eb010141          ADD      r1,r1,r1,LSL #1
00000a  eb020181          ADD      r1,r2,r1,LSL #2
;;;2149       if (p_rdy_list->NbrEntries == (OS_OBJ_QTY)0) {          /* CASE 0: Insert when there are no entries               */
00000e  2200              MOVS     r2,#0
000010  890b              LDRH     r3,[r1,#8]
000012  b143              CBZ      r3,|L31.38|
;;;2150           p_rdy_list->NbrEntries =  (OS_OBJ_QTY)1;            /*         This is the first entry                        */
;;;2151           p_tcb->NextPtr         =  (OS_TCB   *)0;            /*         No other OS_TCBs in the list                   */
;;;2152           p_tcb->PrevPtr         =  (OS_TCB   *)0;
;;;2153           p_rdy_list->HeadPtr    =  p_tcb;                    /*         Both list pointers point to this OS_TCB        */
;;;2154           p_rdy_list->TailPtr    =  p_tcb;
;;;2155       } else {                                                /* CASE 1: Insert BEFORE the current head of list         */
;;;2156           p_rdy_list->NbrEntries++;                           /*         One more OS_TCB in the list                    */
000014  1c5b              ADDS     r3,r3,#1
000016  810b              STRH     r3,[r1,#8]
;;;2157           p_tcb->NextPtr         = p_rdy_list->HeadPtr;       /*         Adjust new OS_TCBs links                       */
000018  680b              LDR      r3,[r1,#0]
00001a  e9c03203          STRD     r3,r2,[r0,#0xc]
;;;2158           p_tcb->PrevPtr         = (OS_TCB    *)0;
;;;2159           p_tcb2                 = p_rdy_list->HeadPtr;       /*         Adjust old head of list's links                */
;;;2160           p_tcb2->PrevPtr        = p_tcb;
00001e  680a              LDR      r2,[r1,#0]
;;;2161           p_rdy_list->HeadPtr    = p_tcb;
000020  6110              STR      r0,[r2,#0x10]
000022  6008              STR      r0,[r1,#0]
;;;2162       }
;;;2163   }
000024  4770              BX       lr
                  |L31.38|
000026  2301              MOVS     r3,#1                 ;2150
000028  810b              STRH     r3,[r1,#8]            ;2150
00002a  60c2              STR      r2,[r0,#0xc]          ;2152
00002c  6102              STR      r2,[r0,#0x10]         ;2153
00002e  6008              STR      r0,[r1,#0]            ;2154
000030  6048              STR      r0,[r1,#4]            ;2154
000032  4770              BX       lr
;;;2164   
                          ENDP

                  |L31.52|
                          DCD      OSRdyList

                          AREA ||i.OS_RdyListInsertTail||, CODE, READONLY, ALIGN=2

                  OS_RdyListInsertTail PROC
;;;2221   
;;;2222   void  OS_RdyListInsertTail (OS_TCB  *p_tcb)
000000  f8901037          LDRB     r1,[r0,#0x37]
;;;2223   {
;;;2224       OS_RDY_LIST  *p_rdy_list;
;;;2225       OS_TCB       *p_tcb2;
;;;2226   
;;;2227   
;;;2228   
;;;2229       p_rdy_list = &OSRdyList[p_tcb->Prio];
000004  4a0a              LDR      r2,|L32.48|
000006  eb010141          ADD      r1,r1,r1,LSL #1
00000a  eb020181          ADD      r1,r2,r1,LSL #2
;;;2230       if (p_rdy_list->NbrEntries == (OS_OBJ_QTY)0) {          /* CASE 0: Insert when there are no entries               */
00000e  2200              MOVS     r2,#0
000010  890b              LDRH     r3,[r1,#8]
000012  b13b              CBZ      r3,|L32.36|
;;;2231           p_rdy_list->NbrEntries  = (OS_OBJ_QTY)1;            /*         This is the first entry                        */
;;;2232           p_tcb->NextPtr          = (OS_TCB   *)0;            /*         No other OS_TCBs in the list                   */
;;;2233           p_tcb->PrevPtr          = (OS_TCB   *)0;
;;;2234           p_rdy_list->HeadPtr     = p_tcb;                    /*         Both list pointers point to this OS_TCB        */
;;;2235           p_rdy_list->TailPtr     = p_tcb;
;;;2236       } else {                                                /* CASE 1: Insert AFTER the current tail of list          */
;;;2237           p_rdy_list->NbrEntries++;                           /*         One more OS_TCB in the list                    */
000014  1c5b              ADDS     r3,r3,#1
000016  810b              STRH     r3,[r1,#8]
;;;2238           p_tcb->NextPtr          = (OS_TCB   *)0;            /*         Adjust new OS_TCBs links                       */
;;;2239           p_tcb2                  = p_rdy_list->TailPtr;
000018  60c2              STR      r2,[r0,#0xc]
;;;2240           p_tcb->PrevPtr          = p_tcb2;
00001a  684a              LDR      r2,[r1,#4]
;;;2241           p_tcb2->NextPtr         = p_tcb;                    /*         Adjust old tail of list's links                */
00001c  6102              STR      r2,[r0,#0x10]
00001e  60d0              STR      r0,[r2,#0xc]
                  |L32.32|
000020  6048              STR      r0,[r1,#4]            ;2235
;;;2242           p_rdy_list->TailPtr     = p_tcb;
;;;2243       }
;;;2244   }
000022  4770              BX       lr
                  |L32.36|
000024  2301              MOVS     r3,#1                 ;2231
000026  810b              STRH     r3,[r1,#8]            ;2231
000028  60c2              STR      r2,[r0,#0xc]          ;2233
00002a  6102              STR      r2,[r0,#0x10]         ;2234
00002c  6008              STR      r0,[r1,#0]            ;2235
00002e  e7f7              B        |L32.32|
;;;2245   
                          ENDP

                  |L32.48|
                          DCD      OSRdyList

                          AREA ||i.OS_RdyListMoveHeadToTail||, CODE, READONLY, ALIGN=1

                  OS_RdyListMoveHeadToTail PROC
;;;2298   
;;;2299   void  OS_RdyListMoveHeadToTail (OS_RDY_LIST  *p_rdy_list)
000000  b510              PUSH     {r4,lr}
;;;2300   {
;;;2301       OS_TCB  *p_tcb1;
;;;2302       OS_TCB  *p_tcb2;
;;;2303       OS_TCB  *p_tcb3;
;;;2304   
;;;2305   
;;;2306   
;;;2307       switch (p_rdy_list->NbrEntries) {
000002  8902              LDRH     r2,[r0,#8]
000004  2a00              CMP      r2,#0                 ;2300
000006  d014              BEQ      |L33.50|
000008  2a01              CMP      r2,#1
00000a  d012              BEQ      |L33.50|
00000c  2100              MOVS     r1,#0
00000e  2a02              CMP      r2,#2
000010  d007              BEQ      |L33.34|
000012  e9d02400          LDRD     r2,r4,[r0,#0]
;;;2308           case 0:
;;;2309           case 1:
;;;2310                break;
;;;2311   
;;;2312           case 2:                                             /* SWAP the TCBs                                          */
;;;2313                p_tcb1              = p_rdy_list->HeadPtr;     /* Point to current head                                  */
;;;2314                p_tcb2              = p_rdy_list->TailPtr;     /* Point to current tail                                  */
;;;2315                p_tcb1->PrevPtr     = p_tcb2;
;;;2316                p_tcb1->NextPtr     = (OS_TCB *)0;
;;;2317                p_tcb2->PrevPtr     = (OS_TCB *)0;
;;;2318                p_tcb2->NextPtr     = p_tcb1;
;;;2319                p_rdy_list->HeadPtr = p_tcb2;
;;;2320                p_rdy_list->TailPtr = p_tcb1;
;;;2321                break;
;;;2322   
;;;2323           default:                                            /* Move only if there are more than 2 OS_TCBs in the list */
;;;2324                p_tcb1              = p_rdy_list->HeadPtr;     /* Point to current head                                  */
;;;2325                p_tcb2              = p_rdy_list->TailPtr;     /* Point to current tail                                  */
;;;2326                p_tcb3              = p_tcb1->NextPtr;         /* Point to new list head                                 */
;;;2327                p_tcb3->PrevPtr     = (OS_TCB *)0;             /* Adjust back    link of new list head                   */
000016  68d3              LDR      r3,[r2,#0xc]
000018  6119              STR      r1,[r3,#0x10]
00001a  e9c21403          STRD     r1,r4,[r2,#0xc]
;;;2328                p_tcb1->NextPtr     = (OS_TCB *)0;             /* Adjust forward link of new list tail                   */
;;;2329                p_tcb1->PrevPtr     = p_tcb2;                  /* Adjust back    link of new list tail                   */
;;;2330                p_tcb2->NextPtr     = p_tcb1;                  /* Adjust forward link of old list tail                   */
;;;2331                p_rdy_list->HeadPtr = p_tcb3;                  /* Adjust new list head and tail pointers                 */
;;;2332                p_rdy_list->TailPtr = p_tcb1;
;;;2333                break;
00001e  60e2              STR      r2,[r4,#0xc]
000020  e005              B        |L33.46|
                  |L33.34|
000022  e9d02300          LDRD     r2,r3,[r0,#0]
000026  e9c21303          STRD     r1,r3,[r2,#0xc]
00002a  e9c32103          STRD     r2,r1,[r3,#0xc]
                  |L33.46|
00002e  e9c03200          STRD     r3,r2,[r0,#0]
                  |L33.50|
;;;2334       }
;;;2335   }
000032  bd10              POP      {r4,pc}
;;;2336   
                          ENDP


                          AREA ||i.OS_RdyListRemove||, CODE, READONLY, ALIGN=2

                  OS_RdyListRemove PROC
;;;2385   
;;;2386   void  OS_RdyListRemove (OS_TCB  *p_tcb)
000000  b570              PUSH     {r4-r6,lr}
;;;2387   {
000002  4605              MOV      r5,r0
;;;2388       OS_RDY_LIST  *p_rdy_list;
;;;2389       OS_TCB       *p_tcb1;
;;;2390       OS_TCB       *p_tcb2;
;;;2391   
;;;2392   
;;;2393   
;;;2394       p_rdy_list = &OSRdyList[p_tcb->Prio];
000004  f8900037          LDRB     r0,[r0,#0x37]
000008  4911              LDR      r1,|L34.80|
00000a  eb000040          ADD      r0,r0,r0,LSL #1
00000e  eb010180          ADD      r1,r1,r0,LSL #2
000012  e9d50203          LDRD     r0,r2,[r5,#0xc]
000016  2400              MOVS     r4,#0
000018  b142              CBZ      r2,|L34.44|
;;;2395       p_tcb1     = p_tcb->PrevPtr;                            /* Point to next and previous OS_TCB in the list          */
;;;2396       p_tcb2     = p_tcb->NextPtr;
;;;2397       if (p_tcb1 == (OS_TCB *)0) {                            /* Was the OS_TCB to remove was at the head?              */
;;;2398           if (p_tcb2 == (OS_TCB *)0) {                        /* Yes, was it the only OS_TCB?                           */
;;;2399               p_rdy_list->NbrEntries = (OS_OBJ_QTY)0;         /*      Yes, no more entries                              */
;;;2400               p_rdy_list->HeadPtr    = (OS_TCB   *)0;
;;;2401               p_rdy_list->TailPtr    = (OS_TCB   *)0;
;;;2402               OS_PrioRemove(p_tcb->Prio);
;;;2403           } else {
;;;2404               p_rdy_list->NbrEntries--;                       /*      No,  one less entry                               */
;;;2405               p_tcb2->PrevPtr        = (OS_TCB   *)0;         /*           adjust back link of new list head            */
;;;2406               p_rdy_list->HeadPtr    = p_tcb2;                /*           adjust OS_RDY_LIST's new head                */
;;;2407           }
;;;2408       } else {
;;;2409           p_rdy_list->NbrEntries--;                           /* No,  one less entry                                    */
00001a  890b              LDRH     r3,[r1,#8]
00001c  1e5b              SUBS     r3,r3,#1
00001e  810b              STRH     r3,[r1,#8]
;;;2410           p_tcb1->NextPtr = p_tcb2;
;;;2411           if (p_tcb2 == (OS_TCB *)0) {
000020  60d0              STR      r0,[r2,#0xc]
000022  b190              CBZ      r0,|L34.74|
;;;2412               p_rdy_list->TailPtr = p_tcb1;                   /*      Removing the TCB at the tail, adj the tail ptr    */
;;;2413           } else {
;;;2414               p_tcb2->PrevPtr     = p_tcb1;
000024  6102              STR      r2,[r0,#0x10]
                  |L34.38|
;;;2415           }
;;;2416       }
;;;2417       p_tcb->PrevPtr = (OS_TCB *)0;
;;;2418       p_tcb->NextPtr = (OS_TCB *)0;
000026  612c              STR      r4,[r5,#0x10]
;;;2419   }
000028  60ec              STR      r4,[r5,#0xc]
00002a  bd70              POP      {r4-r6,pc}
                  |L34.44|
00002c  b128              CBZ      r0,|L34.58|
00002e  890a              LDRH     r2,[r1,#8]            ;2404
000030  1e52              SUBS     r2,r2,#1              ;2404
000032  810a              STRH     r2,[r1,#8]            ;2404
000034  6104              STR      r4,[r0,#0x10]         ;2406
000036  6008              STR      r0,[r1,#0]            ;2406
000038  e7f5              B        |L34.38|
                  |L34.58|
00003a  810c              STRH     r4,[r1,#8]            ;2399
00003c  600c              STR      r4,[r1,#0]            ;2401
00003e  604c              STR      r4,[r1,#4]            ;2402
000040  f8950037          LDRB     r0,[r5,#0x37]         ;2402
000044  f7fffffe          BL       OS_PrioRemove
000048  e7ed              B        |L34.38|
                  |L34.74|
00004a  604a              STR      r2,[r1,#4]            ;2412
00004c  e7eb              B        |L34.38|
;;;2420   
                          ENDP

00004e  0000              DCW      0x0000
                  |L34.80|
                          DCD      OSRdyList

                          AREA ||i.OS_Sched0||, CODE, READONLY, ALIGN=2

                  OS_Sched0 PROC
;;;2437   #if OS_CFG_ISR_POST_DEFERRED_EN > 0u
;;;2438   void  OS_Sched0 (void)
000000  b510              PUSH     {r4,lr}
;;;2439   {
;;;2440       CPU_SR_ALLOC();
;;;2441   
;;;2442   
;;;2443   
;;;2444       CPU_INT_DIS();
000002  f7fffffe          BL       CPU_SR_Save
;;;2445       OSPrioHighRdy   = (OS_PRIO)0;                           /* Force the priority to 0                                */
000006  4a0b              LDR      r2,|L35.52|
000008  2100              MOVS     r1,#0
00000a  7011              STRB     r1,[r2,#0]
;;;2446       OSTCBHighRdyPtr = &OSIntQTaskTCB;                       /* Always schedule the ISR handler task                   */
00000c  4a0b              LDR      r2,|L35.60|
00000e  490a              LDR      r1,|L35.56|
;;;2447   #if OS_CFG_TASK_PROFILE_EN > 0u
;;;2448       OSTCBHighRdyPtr->CtxSwCtr++;                            /* Inc. # of context switches to this task                */
000010  6011              STR      r1,[r2,#0]  ; OSTCBHighRdyPtr
000012  f8512f90          LDR      r2,[r1,#0x90]!
000016  1c52              ADDS     r2,r2,#1
;;;2449   #endif
;;;2450       OSTaskCtxSwCtr++;                                       /* Increment context switch counter                       */
000018  600a              STR      r2,[r1,#0]
00001a  4909              LDR      r1,|L35.64|
00001c  680a              LDR      r2,[r1,#0]  ; OSTaskCtxSwCtr
00001e  1c52              ADDS     r2,r2,#1
;;;2451       OS_TASK_SW();                                           /* Perform a task level context switch                    */
000020  600a              STR      r2,[r1,#0]  ; OSTaskCtxSwCtr
000022  4a08              LDR      r2,|L35.68|
000024  f04f5180          MOV      r1,#0x10000000
000028  6011              STR      r1,[r2,#0]
;;;2452       CPU_INT_EN();
00002a  e8bd4010          POP      {r4,lr}
00002e  f7ffbffe          B.W      CPU_SR_Restore
;;;2453   }
;;;2454   #endif
                          ENDP

000032  0000              DCW      0x0000
                  |L35.52|
                          DCD      OSPrioHighRdy
                  |L35.56|
                          DCD      OSIntQTaskTCB
                  |L35.60|
                          DCD      OSTCBHighRdyPtr
                  |L35.64|
                          DCD      OSTaskCtxSwCtr
                  |L35.68|
                          DCD      0xe000ed04

                          AREA ||i.OS_SchedLockTimeMeasStart||, CODE, READONLY, ALIGN=2

                  OS_SchedLockTimeMeasStart PROC
;;;2478   #if OS_CFG_SCHED_LOCK_TIME_MEAS_EN > 0u
;;;2479   void  OS_SchedLockTimeMeasStart (void)
000000  4804              LDR      r0,|L36.20|
;;;2480   {
000002  b510              PUSH     {r4,lr}
;;;2481       if (OSSchedLockNestingCtr == 1u) {
000004  7800              LDRB     r0,[r0,#0]  ; OSSchedLockNestingCtr
000006  2801              CMP      r0,#1
000008  d103              BNE      |L36.18|
;;;2482           OSSchedLockTimeBegin = CPU_TS_TmrRd();
00000a  f7fffffe          BL       CPU_TS_TmrRd
00000e  4902              LDR      r1,|L36.24|
000010  6008              STR      r0,[r1,#0]  ; OSSchedLockTimeBegin
                  |L36.18|
;;;2483       }
;;;2484   }
000012  bd10              POP      {r4,pc}
;;;2485   
                          ENDP

                  |L36.20|
                          DCD      OSSchedLockNestingCtr
                  |L36.24|
                          DCD      OSSchedLockTimeBegin

                          AREA ||i.OS_SchedLockTimeMeasStop||, CODE, READONLY, ALIGN=2

                  OS_SchedLockTimeMeasStop PROC
;;;2488   
;;;2489   void  OS_SchedLockTimeMeasStop (void)
000000  480a              LDR      r0,|L37.44|
;;;2490   {
000002  b510              PUSH     {r4,lr}
;;;2491       CPU_TS_TMR  delta;
;;;2492   
;;;2493   
;;;2494       if (OSSchedLockNestingCtr == (OS_NESTING_CTR)0) {       /* Make sure we fully un-nested scheduler lock            */
000004  7800              LDRB     r0,[r0,#0]  ; OSSchedLockNestingCtr
000006  2800              CMP      r0,#0                 ;2490
000008  d10e              BNE      |L37.40|
;;;2495           delta = CPU_TS_TmrRd()                              /* Compute the delta time between begin and end           */
00000a  f7fffffe          BL       CPU_TS_TmrRd
00000e  4908              LDR      r1,|L37.48|
000010  6809              LDR      r1,[r1,#0]  ; OSSchedLockTimeBegin
000012  1a40              SUBS     r0,r0,r1
;;;2496                 - OSSchedLockTimeBegin;
;;;2497           if (OSSchedLockTimeMax    < delta) {                /* Detect peak value                                      */
000014  4907              LDR      r1,|L37.52|
000016  680a              LDR      r2,[r1,#0]  ; OSSchedLockTimeMax
000018  4282              CMP      r2,r0
00001a  d200              BCS      |L37.30|
;;;2498               OSSchedLockTimeMax    = delta;
00001c  6008              STR      r0,[r1,#0]  ; OSSchedLockTimeMax
                  |L37.30|
;;;2499           }
;;;2500           if (OSSchedLockTimeMaxCur < delta) {                /* Detect peak value (for resettable value)               */
00001e  4906              LDR      r1,|L37.56|
000020  680a              LDR      r2,[r1,#0]  ; OSSchedLockTimeMaxCur
000022  4282              CMP      r2,r0
000024  d200              BCS      |L37.40|
;;;2501               OSSchedLockTimeMaxCur = delta;
000026  6008              STR      r0,[r1,#0]  ; OSSchedLockTimeMaxCur
                  |L37.40|
;;;2502           }
;;;2503       }
;;;2504   }
000028  bd10              POP      {r4,pc}
;;;2505   #endif
                          ENDP

00002a  0000              DCW      0x0000
                  |L37.44|
                          DCD      OSSchedLockNestingCtr
                  |L37.48|
                          DCD      OSSchedLockTimeBegin
                  |L37.52|
                          DCD      OSSchedLockTimeMax
                  |L37.56|
                          DCD      OSSchedLockTimeMaxCur

                          AREA ||i.OS_SchedRoundRobin||, CODE, READONLY, ALIGN=2

                  OS_SchedRoundRobin PROC
;;;2524   #if OS_CFG_SCHED_ROUND_ROBIN_EN > 0u
;;;2525   void  OS_SchedRoundRobin (OS_RDY_LIST  *p_rdy_list)
000000  b570              PUSH     {r4-r6,lr}
;;;2526   {
000002  4604              MOV      r4,r0
;;;2527       OS_TCB   *p_tcb;
;;;2528       CPU_SR_ALLOC();
;;;2529   
;;;2530   
;;;2531   
;;;2532       if (OSSchedRoundRobinEn != DEF_TRUE) {                  /* Make sure round-robin has been enabled                 */
000004  4813              LDR      r0,|L38.84|
000006  7800              LDRB     r0,[r0,#0]  ; OSSchedRoundRobinEn
000008  2801              CMP      r0,#1
00000a  d122              BNE      |L38.82|
;;;2533           return;
;;;2534       }
;;;2535   
;;;2536       CPU_CRITICAL_ENTER();
00000c  f7fffffe          BL       CPU_SR_Save
;;;2537       p_tcb = p_rdy_list->HeadPtr;                            /* Decrement time quanta counter                          */
;;;2538   
;;;2539       if (p_tcb == (OS_TCB *)0) {
000010  6821              LDR      r1,[r4,#0]
000012  4605              MOV      r5,r0                 ;2536
000014  b141              CBZ      r1,|L38.40|
;;;2540           CPU_CRITICAL_EXIT();
;;;2541           return;
;;;2542       }
;;;2543   
;;;2544       if (p_tcb == &OSIdleTaskTCB) {
000016  4810              LDR      r0,|L38.88|
000018  4281              CMP      r1,r0
00001a  d018              BEQ      |L38.78|
;;;2545           CPU_CRITICAL_EXIT();
;;;2546           return;
;;;2547       }
;;;2548   
;;;2549       if (p_tcb->TimeQuantaCtr > (OS_TICK)0) {
00001c  6d8a              LDR      r2,[r1,#0x58]
00001e  b13a              CBZ      r2,|L38.48|
;;;2550           p_tcb->TimeQuantaCtr--;
000020  1e52              SUBS     r2,r2,#1
000022  658a              STR      r2,[r1,#0x58]
000024  d113              BNE      |L38.78|
000026  e003              B        |L38.48|
                  |L38.40|
000028  e8bd4070          POP      {r4-r6,lr}            ;2540
00002c  f7ffbffe          B.W      CPU_SR_Restore
                  |L38.48|
;;;2551       }
;;;2552   
;;;2553       if (p_tcb->TimeQuantaCtr > (OS_TICK)0) {                /* Task not done with its time quanta                     */
;;;2554           CPU_CRITICAL_EXIT();
;;;2555           return;
;;;2556       }
;;;2557   
;;;2558       if (p_rdy_list->NbrEntries < (OS_OBJ_QTY)2) {           /* See if it's time to time slice current task            */
000030  8920              LDRH     r0,[r4,#8]
000032  2802              CMP      r0,#2
000034  d30b              BCC      |L38.78|
;;;2559           CPU_CRITICAL_EXIT();                                /* ... only if multiple tasks at same priority            */
;;;2560           return;
;;;2561       }
;;;2562   
;;;2563       if (OSSchedLockNestingCtr > (OS_NESTING_CTR)0) {        /* Can't round-robin if the scheduler is locked           */
000036  4809              LDR      r0,|L38.92|
000038  7800              LDRB     r0,[r0,#0]  ; OSSchedLockNestingCtr
00003a  b940              CBNZ     r0,|L38.78|
;;;2564           CPU_CRITICAL_EXIT();
;;;2565           return;
;;;2566       }
;;;2567   
;;;2568       OS_RdyListMoveHeadToTail(p_rdy_list);                   /* Move current OS_TCB to the end of the list             */
00003c  4620              MOV      r0,r4
00003e  f7fffffe          BL       OS_RdyListMoveHeadToTail
;;;2569       p_tcb = p_rdy_list->HeadPtr;                            /* Point to new OS_TCB at head of the list                */
;;;2570       if (p_tcb->TimeQuanta == (OS_TICK)0) {                  /* See if we need to use the default time slice           */
000042  6820              LDR      r0,[r4,#0]
000044  6d41              LDR      r1,[r0,#0x54]
000046  b909              CBNZ     r1,|L38.76|
;;;2571           p_tcb->TimeQuantaCtr = OSSchedRoundRobinDfltTimeQuanta;
000048  4905              LDR      r1,|L38.96|
00004a  6809              LDR      r1,[r1,#0]  ; OSSchedRoundRobinDfltTimeQuanta
                  |L38.76|
;;;2572       } else {
;;;2573           p_tcb->TimeQuantaCtr = p_tcb->TimeQuanta;           /* Load time slice counter with new time                  */
00004c  6581              STR      r1,[r0,#0x58]
                  |L38.78|
;;;2574       }
;;;2575       CPU_CRITICAL_EXIT();
00004e  4628              MOV      r0,r5
;;;2576   }
000050  e7ea              B        |L38.40|
                  |L38.82|
000052  bd70              POP      {r4-r6,pc}
;;;2577   #endif
                          ENDP

                  |L38.84|
                          DCD      OSSchedRoundRobinEn
                  |L38.88|
                          DCD      OSIdleTaskTCB
                  |L38.92|
                          DCD      OSSchedLockNestingCtr
                  |L38.96|
                          DCD      OSSchedRoundRobinDfltTimeQuanta

                          AREA ||i.OS_TaskBlock||, CODE, READONLY, ALIGN=1

                  OS_TaskBlock PROC
;;;2597   
;;;2598   void  OS_TaskBlock (OS_TCB   *p_tcb,
000000  b538              PUSH     {r3-r5,lr}
;;;2599                       OS_TICK   timeout)
;;;2600   {
000002  4604              MOV      r4,r0
;;;2601       OS_ERR  err;
;;;2602   
;;;2603   
;;;2604       if (timeout > (OS_TICK)0) {                             /* Add task to tick list if timeout non zero               */
;;;2605           OS_TickListInsert(p_tcb,
000004  2502              MOVS     r5,#2
000006  b131              CBZ      r1,|L39.22|
000008  466b              MOV      r3,sp
00000a  2202              MOVS     r2,#2
00000c  f7fffffe          BL       OS_TickListInsert
;;;2606                             timeout,
;;;2607                             OS_OPT_TIME_TIMEOUT,
;;;2608                            &err);
;;;2609           if (err == OS_ERR_NONE) {
000010  f8bd0000          LDRH     r0,[sp,#0]
000014  b128              CBZ      r0,|L39.34|
                  |L39.22|
;;;2610               p_tcb->TaskState = OS_TASK_STATE_PEND_TIMEOUT;
;;;2611           } else {
;;;2612               p_tcb->TaskState = OS_TASK_STATE_PEND;
000016  f8845036          STRB     r5,[r4,#0x36]
                  |L39.26|
;;;2613           }
;;;2614       } else {
;;;2615           p_tcb->TaskState = OS_TASK_STATE_PEND;
;;;2616       }
;;;2617       OS_RdyListRemove(p_tcb);
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       OS_RdyListRemove
;;;2618   }
000020  bd38              POP      {r3-r5,pc}
                  |L39.34|
000022  2003              MOVS     r0,#3                 ;2610
000024  f8840036          STRB     r0,[r4,#0x36]         ;2610
000028  e7f7              B        |L39.26|
;;;2619   
                          ENDP


                          AREA ||i.OS_TaskRdy||, CODE, READONLY, ALIGN=1

                  OS_TaskRdy PROC
;;;2635   
;;;2636   void  OS_TaskRdy (OS_TCB  *p_tcb)
000000  b510              PUSH     {r4,lr}
;;;2637   {
000002  4604              MOV      r4,r0
;;;2638       OS_TickListRemove(p_tcb);                               /* Remove from tick list                                  */
000004  f7fffffe          BL       OS_TickListRemove
;;;2639       if ((p_tcb->TaskState & OS_TASK_STATE_BIT_SUSPENDED) == (OS_STATE)0) {
000008  f8940036          LDRB     r0,[r4,#0x36]
00000c  0740              LSLS     r0,r0,#29
00000e  d404              BMI      |L40.26|
;;;2640           OS_RdyListInsert(p_tcb);                            /* Insert the task in the ready list                      */
000010  4620              MOV      r0,r4
000012  e8bd4010          POP      {r4,lr}
000016  f7ffbffe          B.W      OS_RdyListInsert
                  |L40.26|
;;;2641       }
;;;2642   }
00001a  bd10              POP      {r4,pc}
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

000000  2000              DCB      0x20,0x00
