; generated by ARM C/C++ Compiler, 5.02 [Build 28]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\OBJ\delay.o --asm_dir=.\List\ --list_dir=.\List\ --depend=..\OBJ\delay.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\BSP -I..\CORE -I..\STM32F10x_FWLib\inc -I..\USER -I..\UCOSIII\uC-CPU -I..\UCOSIII\uC-CPU\ARM-Cortex-M3\RealView -I..\UCOSIII\uC-LIB -I..\UCOSIII\uC-LIB\Ports\ARM-Cortex-M3\RealView -I..\UCOSIII\uCOS-III -I..\UCOSIII\uCOS-III\Ports -I..\UCOSIII\uCOS-III\Ports\ARM-Cortex-M3\Generic\RealView -I..\UCOSIII\uCOS-III\Source -I..\UCOSIII\UCOS_BSP -I..\UCOSIII\uCOS_CONFIG -I..\UCOSIII-Task -I..\SYSTEM -I..\BSP\inc -I..\PAL -I..\PAL\vehicles -ID:\Keil_v4\ARM\RV31\INC -ID:\Keil_v4\ARM\CMSIS\Include -ID:\Keil_v4\ARM\Inc\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=..\OBJ\delay.crf ..\SYSTEM\delay.c]
                          THUMB

                          AREA ||i.SysTick_Handler||, CODE, READONLY, ALIGN=2

                  SysTick_Handler PROC
;;;48     //systick中断服务函数,使用ucos时用到
;;;49     void SysTick_Handler(void)
000000  4806              LDR      r0,|L1.28|
;;;50     {	
000002  b510              PUSH     {r4,lr}
;;;51     	if(delay_osrunning==1)						//OS开始跑了,才执行正常的调度处理
000004  7800              LDRB     r0,[r0,#0]  ; OSRunning
000006  2801              CMP      r0,#1
000008  d107              BNE      |L1.26|
;;;52     	{
;;;53     		OSIntEnter();							//进入中断
00000a  f7fffffe          BL       OSIntEnter
;;;54     		OSTimeTick();       					//调用ucos的时钟服务程序               
00000e  f7fffffe          BL       OSTimeTick
;;;55     		OSIntExit();       	 					//触发任务切换软中断
000012  e8bd4010          POP      {r4,lr}
000016  f7ffbffe          B.W      OSIntExit
                  |L1.26|
;;;56     	}
;;;57     }
00001a  bd10              POP      {r4,pc}
;;;58     
                          ENDP

                  |L1.28|
                          DCD      OSRunning

                          AREA ||i.delay_init||, CODE, READONLY, ALIGN=2

                  delay_init PROC
;;;63     //SYSCLK:系统时钟
;;;64     void delay_init()
000000  b510              PUSH     {r4,lr}
;;;65     {
;;;66     	u32 reload;
;;;67     	SysTick_CLKSourceConfig(SysTick_CLKSource_HCLK_Div8);	//选择外部时钟  HCLK/8
000002  f06f0004          MVN      r0,#4
000006  f7fffffe          BL       SysTick_CLKSourceConfig
;;;68     	fac_us=SystemCoreClock/8000000;				//为系统时钟的1/8  
00000a  480f              LDR      r0,|L2.72|
00000c  4a10              LDR      r2,|L2.80|
;;;69     	reload=SystemCoreClock/8000000;				//每秒钟的计数次数 单位为K	   
;;;70     	reload*=1000000/delay_ostickspersec;		//根据delay_ostickspersec设定溢出时间
00000e  4b11              LDR      r3,|L2.84|
000010  6801              LDR      r1,[r0,#0]            ;68  ; SystemCoreClock
000012  480e              LDR      r0,|L2.76|
000014  4c10              LDR      r4,|L2.88|
000016  fbb1f0f0          UDIV     r0,r1,r0              ;68
00001a  7010              STRB     r0,[r2,#0]            ;68
00001c  6819              LDR      r1,[r3,#0]  ; OSCfg_TickRate_Hz
00001e  fbb4f1f1          UDIV     r1,r4,r1
000022  4341              MULS     r1,r0,r1
;;;71     												//reload为24位寄存器,最大值:16777216,在72M下,约合1.86s左右	
;;;72     	fac_ms=1000/delay_ostickspersec;			//代表OS可以延时的最少单位	   
000024  6818              LDR      r0,[r3,#0]  ; OSCfg_TickRate_Hz
000026  f44f737a          MOV      r3,#0x3e8
00002a  fbb3f0f0          UDIV     r0,r3,r0
00002e  8050              STRH     r0,[r2,#2]
;;;73     
;;;74     	SysTick->CTRL|=SysTick_CTRL_TICKINT_Msk;   	//开启SYSTICK中断
000030  f04f20e0          MOV      r0,#0xe000e000
000034  6902              LDR      r2,[r0,#0x10]
000036  f0420202          ORR      r2,r2,#2
00003a  6102              STR      r2,[r0,#0x10]
;;;75     	SysTick->LOAD=reload; 						//每1/delay_ostickspersec秒中断一次	
00003c  6141              STR      r1,[r0,#0x14]
;;;76     	SysTick->CTRL|=SysTick_CTRL_ENABLE_Msk;   	//开启SYSTICK    
00003e  6901              LDR      r1,[r0,#0x10]
000040  f0410101          ORR      r1,r1,#1
000044  6101              STR      r1,[r0,#0x10]
;;;77     }								    
000046  bd10              POP      {r4,pc}
;;;78     
                          ENDP

                  |L2.72|
                          DCD      SystemCoreClock
                  |L2.76|
                          DCD      0x007a1200
                  |L2.80|
                          DCD      ||.data||
                  |L2.84|
                          DCD      OSCfg_TickRate_Hz
                  |L2.88|
                          DCD      0x000f4240

                          AREA ||i.delay_ms||, CODE, READONLY, ALIGN=2

                  delay_ms PROC
;;;106    //nms:要延时的ms数
;;;107    void delay_ms(u16 nms)
000000  b570              PUSH     {r4-r6,lr}
;;;108    {	
000002  4604              MOV      r4,r0
;;;109    	if(delay_osrunning&&delay_osintnesting==0)	//如果OS已经在跑了,并且不是在中断里面(中断里面不能任务调度)	    
000004  480c              LDR      r0,|L3.56|
000006  7800              LDRB     r0,[r0,#0]  ; OSRunning
000008  b178              CBZ      r0,|L3.42|
00000a  480c              LDR      r0,|L3.60|
00000c  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
00000e  b960              CBNZ     r0,|L3.42|
;;;110    	{		 
;;;111    		if(nms>=fac_ms)							//延时的时间大于OS的最少时间周期 
000010  4d0b              LDR      r5,|L3.64|
000012  8868              LDRH     r0,[r5,#2]  ; fac_ms
000014  4284              CMP      r4,r0
000016  d303              BCC      |L3.32|
;;;112    		{ 
;;;113       			delay_ostimedly(nms/fac_ms);		//OS延时
000018  fbb4f0f0          UDIV     r0,r4,r0
00001c  f7fffffe          BL       delay_ostimedly
                  |L3.32|
;;;114    		}
;;;115    		nms%=fac_ms;							//OS已经无法提供这么小的延时了,采用普通方式延时    
000020  8868              LDRH     r0,[r5,#2]  ; fac_ms
000022  fbb4f1f0          UDIV     r1,r4,r0
000026  fb004411          MLS      r4,r0,r1,r4
                  |L3.42|
;;;116    	}
;;;117    	delay_us((u32)(nms*1000));					//普通方式延时  
00002a  f44f707a          MOV      r0,#0x3e8
00002e  4360              MULS     r0,r4,r0
000030  e8bd4070          POP      {r4-r6,lr}
000034  f7ffbffe          B.W      delay_us
;;;118    }
;;;119    
                          ENDP

                  |L3.56|
                          DCD      OSRunning
                  |L3.60|
                          DCD      OSIntNestingCtr
                  |L3.64|
                          DCD      ||.data||

                          AREA ||i.delay_osschedlock||, CODE, READONLY, ALIGN=1

                  delay_osschedlock PROC
;;;25     //us级延时时,关闭任务调度(防止打断us级延迟)
;;;26     void delay_osschedlock(void)
000000  b508              PUSH     {r3,lr}
;;;27     {
;;;28     	OS_ERR err; 
;;;29     	OSSchedLock(&err);							//UCOSIII的方式,禁止调度，防止打断us延时
000002  4668              MOV      r0,sp
000004  f7fffffe          BL       OSSchedLock
;;;30     }
000008  bd08              POP      {r3,pc}
;;;31     
                          ENDP


                          AREA ||i.delay_osschedunlock||, CODE, READONLY, ALIGN=1

                  delay_osschedunlock PROC
;;;32     //us级延时时,恢复任务调度
;;;33     void delay_osschedunlock(void)
000000  b508              PUSH     {r3,lr}
;;;34     {	
;;;35     	OS_ERR err; 
;;;36     	OSSchedUnlock(&err);						//UCOSIII的方式,恢复调度
000002  4668              MOV      r0,sp
000004  f7fffffe          BL       OSSchedUnlock
;;;37     }
000008  bd08              POP      {r3,pc}
;;;38     
                          ENDP


                          AREA ||i.delay_ostimedly||, CODE, READONLY, ALIGN=1

                  delay_ostimedly PROC
;;;40     //ticks:延时的节拍数
;;;41     void delay_ostimedly(u32 ticks)
000000  b508              PUSH     {r3,lr}
;;;42     {
;;;43     	OS_ERR err; 
;;;44     	OSTimeDly(ticks,OS_OPT_TIME_PERIODIC,&err);	//UCOSIII延时采用周期模式
000002  466a              MOV      r2,sp
000004  2108              MOVS     r1,#8
000006  f7fffffe          BL       OSTimeDly
;;;45     
;;;46     }
00000a  bd08              POP      {r3,pc}
;;;47      
                          ENDP


                          AREA ||i.delay_us||, CODE, READONLY, ALIGN=2

                  delay_us PROC
;;;81     //nus为要延时的us数.		    								   
;;;82     void delay_us(u32 nus)
000000  b5f8              PUSH     {r3-r7,lr}
;;;83     {		
;;;84     	u32 ticks;
;;;85     	u32 told,tnow,tcnt=0;
;;;86     	u32 reload=SysTick->LOAD;					//LOAD的值	    	 
000002  f04f26e0          MOV      r6,#0xe000e000
000006  2400              MOVS     r4,#0                 ;85
000008  6977              LDR      r7,[r6,#0x14]
;;;87     	ticks=nus*fac_us; 							//需要的节拍数	  		 
00000a  490d              LDR      r1,|L7.64|
00000c  7809              LDRB     r1,[r1,#0]  ; fac_us
00000e  fb00f501          MUL      r5,r0,r1
000012  4668              MOV      r0,sp
000014  f7fffffe          BL       OSSchedLock
;;;88     	tcnt=0;
;;;89     	delay_osschedlock();						//阻止OS调度，防止打断us延时
;;;90     	told=SysTick->VAL;        					//刚进入时的计数器值
000018  69b0              LDR      r0,[r6,#0x18]
                  |L7.26|
;;;91     	while(1)
;;;92     	{
;;;93     		tnow=SysTick->VAL;	
00001a  69b1              LDR      r1,[r6,#0x18]
;;;94     		if(tnow!=told)
00001c  4281              CMP      r1,r0
00001e  d0fc              BEQ      |L7.26|
;;;95     		{	    
;;;96     			if(tnow<told)tcnt+=told-tnow;		//这里注意一下SYSTICK是一个递减的计数器就可以了.
000020  d202              BCS      |L7.40|
000022  eba00001          SUB      r0,r0,r1
000026  e002              B        |L7.46|
                  |L7.40|
;;;97     			else tcnt+=reload-tnow+told;	    
000028  eba70201          SUB      r2,r7,r1
00002c  4410              ADD      r0,r0,r2
                  |L7.46|
00002e  4404              ADD      r4,r4,r0
;;;98     			told=tnow;
000030  4608              MOV      r0,r1
;;;99     			if(tcnt>=ticks)break;				//时间超过/等于要延迟的时间,则退出.
000032  42ac              CMP      r4,r5
000034  d3f1              BCC      |L7.26|
000036  4668              MOV      r0,sp
000038  f7fffffe          BL       OSSchedUnlock
;;;100    		}  
;;;101    	}
;;;102    	delay_osschedunlock();						//恢复OS调度									    
;;;103    }
00003c  bdf8              POP      {r3-r7,pc}
;;;104    
                          ENDP

00003e  0000              DCW      0x0000
                  |L7.64|
                          DCD      ||.data||

                          AREA ||.data||, DATA, ALIGN=1

                  fac_us
000000  0000              DCB      0x00,0x00
                  fac_ms
000002  0000              DCW      0x0000
