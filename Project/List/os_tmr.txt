; generated by ARM C/C++ Compiler, 5.02 [Build 28]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\OBJ\os_tmr.o --asm_dir=.\List\ --list_dir=.\List\ --depend=..\OBJ\os_tmr.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\BSP -I..\CORE -I..\STM32F10x_FWLib\inc -I..\USER -I..\UCOSIII\uC-CPU -I..\UCOSIII\uC-CPU\ARM-Cortex-M3\RealView -I..\UCOSIII\uC-LIB -I..\UCOSIII\uC-LIB\Ports\ARM-Cortex-M3\RealView -I..\UCOSIII\uCOS-III -I..\UCOSIII\uCOS-III\Ports -I..\UCOSIII\uCOS-III\Ports\ARM-Cortex-M3\Generic\RealView -I..\UCOSIII\uCOS-III\Source -I..\UCOSIII\UCOS_BSP -I..\UCOSIII\uCOS_CONFIG -I..\UCOSIII-Task -I..\SYSTEM -I..\BSP\inc -I..\PAL -I..\PAL\vehicles -ID:\Keil_v4\ARM\RV31\INC -ID:\Keil_v4\ARM\CMSIS\Include -ID:\Keil_v4\ARM\Inc\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=..\OBJ\os_tmr.crf ..\UCOSIII\uCOS-III\Source\os_tmr.c]
                          THUMB

                          AREA ||i.OSTmrCreate||, CODE, READONLY, ALIGN=2

                  OSTmrCreate PROC
;;;103    
;;;104    void  OSTmrCreate (OS_TMR               *p_tmr,
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;105                       CPU_CHAR             *p_name,
;;;106                       OS_TICK               dly,
;;;107                       OS_TICK               period,
;;;108                       OS_OPT                opt,
;;;109                       OS_TMR_CALLBACK_PTR   p_callback,
;;;110                       void                 *p_callback_arg,
;;;111                       OS_ERR               *p_err)
;;;112    {
000004  4604              MOV      r4,r0
;;;113        CPU_SR_ALLOC();
;;;114    
;;;115    
;;;116    
;;;117    #ifdef OS_SAFETY_CRITICAL
;;;118        if (p_err == (OS_ERR *)0) {
;;;119            OS_SAFETY_CRITICAL_EXCEPTION();
;;;120            return;
;;;121        }
;;;122    #endif
;;;123    
;;;124    #ifdef OS_SAFETY_CRITICAL_IEC61508
;;;125        if (OSSafetyCriticalStartFlag == DEF_TRUE) {
;;;126           *p_err = OS_ERR_ILLEGAL_CREATE_RUN_TIME;
;;;127            return;
;;;128        }
;;;129    #endif
;;;130    
;;;131    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;132        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if trying to call from an ISR                      */
000006  4828              LDR      r0,|L1.168|
000008  e9dd9b0a          LDRD     r9,r11,[sp,#0x28]     ;112
00000c  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
00000e  9d0d              LDR      r5,[sp,#0x34]         ;112
000010  4698              MOV      r8,r3                 ;112
000012  4616              MOV      r6,r2                 ;112
000014  468a              MOV      r10,r1                ;112
000016  b110              CBZ      r0,|L1.30|
;;;133           *p_err = OS_ERR_TMR_ISR;
000018  f2473043          MOV      r0,#0x7343
;;;134            return;
00001c  e042              B        |L1.164|
                  |L1.30|
;;;135        }
;;;136    #endif
;;;137    
;;;138    #if OS_CFG_ARG_CHK_EN > 0u
;;;139        if (p_tmr == (OS_TMR *)0) {                             /* Validate 'p_tmr'                                       */
00001e  b144              CBZ      r4,|L1.50|
;;;140           *p_err = OS_ERR_OBJ_PTR_NULL;
;;;141            return;
;;;142        }
;;;143    
;;;144        switch (opt) {
000020  f1b90f01          CMP      r9,#1
000024  d00e              BEQ      |L1.68|
000026  f1b90f02          CMP      r9,#2
00002a  d005              BEQ      |L1.56|
;;;145            case OS_OPT_TMR_PERIODIC:
;;;146                 if (period == (OS_TICK)0) {
;;;147                    *p_err = OS_ERR_TMR_INVALID_PERIOD;
;;;148                     return;
;;;149                 }
;;;150                 break;
;;;151    
;;;152            case OS_OPT_TMR_ONE_SHOT:
;;;153                 if (dly == (OS_TICK)0) {
;;;154                    *p_err = OS_ERR_TMR_INVALID_DLY;
;;;155                     return;
;;;156                 }
;;;157                 break;
;;;158    
;;;159            default:
;;;160                *p_err = OS_ERR_OPT_INVALID;
00002c  f6456025          MOV      r0,#0x5e25
;;;161                 return;
000030  e038              B        |L1.164|
                  |L1.50|
000032  f64550c3          MOV      r0,#0x5dc3            ;140
000036  e035              B        |L1.164|
                  |L1.56|
000038  f1b80f00          CMP      r8,#0                 ;146
00003c  d103              BNE      |L1.70|
00003e  f2473040          MOV      r0,#0x7340            ;147
000042  e02f              B        |L1.164|
                  |L1.68|
000044  b366              CBZ      r6,|L1.160|
                  |L1.70|
;;;162        }
;;;163    #endif
;;;164    
;;;165        OS_CRITICAL_ENTER();
000046  f7fffffe          BL       CPU_SR_Save
00004a  4f18              LDR      r7,|L1.172|
00004c  7839              LDRB     r1,[r7,#0]  ; OSSchedLockNestingCtr
00004e  1c49              ADDS     r1,r1,#1
000050  7039              STRB     r1,[r7,#0]
000052  f7fffffe          BL       CPU_SR_Restore
;;;166        p_tmr->State          = (OS_STATE           )OS_TMR_STATE_STOPPED;     /* Initialize the timer fields             */
000056  2001              MOVS     r0,#1
000058  f884002a          STRB     r0,[r4,#0x2a]
;;;167        p_tmr->Type           = (OS_OBJ_TYPE        )OS_OBJ_TYPE_TMR;
;;;168        p_tmr->NamePtr        = (CPU_CHAR          *)p_name;
;;;169        p_tmr->Dly            = (OS_TICK            )dly;
;;;170        p_tmr->Match          = (OS_TICK            )0;
00005c  6226              STR      r6,[r4,#0x20]
00005e  2600              MOVS     r6,#0
;;;171        p_tmr->Remain         = (OS_TICK            )0;
000060  61a6              STR      r6,[r4,#0x18]
;;;172        p_tmr->Period         = (OS_TICK            )period;
000062  f8c48024          STR      r8,[r4,#0x24]
000066  4812              LDR      r0,|L1.176|
000068  61e6              STR      r6,[r4,#0x1c]
00006a  e9c40a00          STRD     r0,r10,[r4,#0]
;;;173        p_tmr->Opt            = (OS_OPT             )opt;
00006e  f8a49028          STRH     r9,[r4,#0x28]
;;;174        p_tmr->CallbackPtr    = (OS_TMR_CALLBACK_PTR)p_callback;
;;;175        p_tmr->CallbackPtrArg = (void              *)p_callback_arg;
000072  f8c4b008          STR      r11,[r4,#8]
000076  980c              LDR      r0,[sp,#0x30]
000078  e9c40603          STRD     r0,r6,[r4,#0xc]
;;;176        p_tmr->NextPtr        = (OS_TMR            *)0;
;;;177        p_tmr->PrevPtr        = (OS_TMR            *)0;
;;;178    
;;;179    #if OS_CFG_DBG_EN > 0u
;;;180        OS_TmrDbgListAdd(p_tmr);
00007c  4620              MOV      r0,r4
00007e  6166              STR      r6,[r4,#0x14]
000080  f7fffffe          BL       OS_TmrDbgListAdd
;;;181    #endif
;;;182        OSTmrQty++;                                             /* Keep track of the number of timers created             */
000084  490b              LDR      r1,|L1.180|
000086  8808              LDRH     r0,[r1,#0]  ; OSTmrQty
000088  1c40              ADDS     r0,r0,#1
00008a  8008              STRH     r0,[r1,#0]
;;;183    
;;;184        OS_CRITICAL_EXIT_NO_SCHED();
00008c  f7fffffe          BL       CPU_SR_Save
000090  7839              LDRB     r1,[r7,#0]  ; OSSchedLockNestingCtr
000092  1e49              SUBS     r1,r1,#1
000094  7039              STRB     r1,[r7,#0]
000096  f7fffffe          BL       CPU_SR_Restore
;;;185       *p_err = OS_ERR_NONE;
00009a  802e              STRH     r6,[r5,#0]
                  |L1.156|
;;;186    }
00009c  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.160|
0000a0  f247303f          MOV      r0,#0x733f            ;154
                  |L1.164|
0000a4  8028              STRH     r0,[r5,#0]            ;160
0000a6  e7f9              B        |L1.156|
;;;187    
                          ENDP

                  |L1.168|
                          DCD      OSIntNestingCtr
                  |L1.172|
                          DCD      OSSchedLockNestingCtr
                  |L1.176|
                          DCD      0x20524d54
                  |L1.180|
                          DCD      OSTmrQty

                          AREA ||i.OSTmrDel||, CODE, READONLY, ALIGN=2

                  OSTmrDel PROC
;;;211    #if OS_CFG_TMR_DEL_EN > 0u
;;;212    CPU_BOOLEAN  OSTmrDel (OS_TMR  *p_tmr,
000000  b5f8              PUSH     {r3-r7,lr}
;;;213                           OS_ERR  *p_err)
;;;214    {
000002  4605              MOV      r5,r0
;;;215        OS_ERR  err;
;;;216    
;;;217    
;;;218    
;;;219    #ifdef OS_SAFETY_CRITICAL
;;;220        if (p_err == (OS_ERR *)0) {
;;;221            OS_SAFETY_CRITICAL_EXCEPTION();
;;;222            return (DEF_FALSE);
;;;223        }
;;;224    #endif
;;;225    
;;;226    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;227        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if trying to call from an ISR                      */
000004  4820              LDR      r0,|L2.136|
000006  460c              MOV      r4,r1                 ;214
000008  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
00000a  b110              CBZ      r0,|L2.18|
;;;228           *p_err  = OS_ERR_TMR_ISR;
00000c  f2473043          MOV      r0,#0x7343
;;;229            return (DEF_FALSE);
000010  e009              B        |L2.38|
                  |L2.18|
;;;230        }
;;;231    #endif
;;;232    
;;;233    #if OS_CFG_ARG_CHK_EN > 0u
;;;234        if (p_tmr == (OS_TMR *)0) {
000012  b135              CBZ      r5,|L2.34|
;;;235           *p_err = OS_ERR_TMR_INVALID;
;;;236            return (DEF_FALSE);
;;;237        }
;;;238    #endif
;;;239    
;;;240    #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
;;;241        if (p_tmr->Type != OS_OBJ_TYPE_TMR) {                   /* Make sure timer was created                            */
000014  491d              LDR      r1,|L2.140|
000016  6828              LDR      r0,[r5,#0]
000018  4288              CMP      r0,r1
00001a  d006              BEQ      |L2.42|
;;;242           *p_err = OS_ERR_OBJ_TYPE;
00001c  f64550c4          MOV      r0,#0x5dc4
;;;243            return (DEF_FALSE);
000020  e02e              B        |L2.128|
                  |L2.34|
000022  f2473042          MOV      r0,#0x7342            ;235
                  |L2.38|
000026  8008              STRH     r0,[r1,#0]            ;228
000028  e02b              B        |L2.130|
                  |L2.42|
;;;244        }
;;;245    #endif
;;;246    
;;;247        OSSchedLock(&err);
00002a  4668              MOV      r0,sp
00002c  f7fffffe          BL       OSSchedLock
;;;248    #if OS_CFG_DBG_EN > 0u
;;;249        OS_TmrDbgListRemove(p_tmr);
000030  4628              MOV      r0,r5
000032  f7fffffe          BL       OS_TmrDbgListRemove
;;;250    #endif
;;;251        OSTmrQty--;                                             /* One less timer                                         */
000036  4816              LDR      r0,|L2.144|
000038  8801              LDRH     r1,[r0,#0]  ; OSTmrQty
00003a  1e49              SUBS     r1,r1,#1
00003c  8001              STRH     r1,[r0,#0]
;;;252    
;;;253        switch (p_tmr->State) {
00003e  f895002a          LDRB     r0,[r5,#0x2a]
000042  b1c0              CBZ      r0,|L2.118|
000044  2600              MOVS     r6,#0
000046  2801              CMP      r0,#1
000048  d00c              BEQ      |L2.100|
00004a  2802              CMP      r0,#2
00004c  d007              BEQ      |L2.94|
00004e  2803              CMP      r0,#3
000050  d008              BEQ      |L2.100|
;;;254            case OS_TMR_STATE_RUNNING:
;;;255                 OS_TmrUnlink(p_tmr);                           /* Remove from current wheel spoke                        */
;;;256                 OS_TmrClr(p_tmr);
;;;257                 OSSchedUnlock(&err);
;;;258                *p_err = OS_ERR_NONE;
;;;259                 return (DEF_TRUE);
;;;260    
;;;261            case OS_TMR_STATE_STOPPED:                          /* Timer has not started or ...                           */
;;;262            case OS_TMR_STATE_COMPLETED:                        /* ... timer has completed the ONE-SHOT time              */
;;;263                 OS_TmrClr(p_tmr);                              /* Clear timer fields                                     */
;;;264                 OSSchedUnlock(&err);
;;;265                *p_err = OS_ERR_NONE;
;;;266                 return (DEF_TRUE);
;;;267    
;;;268            case OS_TMR_STATE_UNUSED:                           /* Already deleted                                        */
;;;269                 OSSchedUnlock(&err);
;;;270                *p_err = OS_ERR_TMR_INACTIVE;
;;;271                 return (DEF_FALSE);
;;;272    
;;;273            default:
;;;274                 OSSchedUnlock(&err);
000052  4668              MOV      r0,sp
000054  f7fffffe          BL       OSSchedUnlock
;;;275                *p_err = OS_ERR_TMR_INVALID_STATE;
000058  f2473041          MOV      r0,#0x7341
;;;276                 return (DEF_FALSE);
00005c  e010              B        |L2.128|
                  |L2.94|
00005e  4628              MOV      r0,r5                 ;255
000060  f7fffffe          BL       OS_TmrUnlink
                  |L2.100|
000064  4628              MOV      r0,r5                 ;263
000066  f7fffffe          BL       OS_TmrClr
00006a  4668              MOV      r0,sp                 ;264
00006c  f7fffffe          BL       OSSchedUnlock
000070  8026              STRH     r6,[r4,#0]            ;265
000072  2001              MOVS     r0,#1                 ;266
;;;277        }
;;;278    }
000074  bdf8              POP      {r3-r7,pc}
                  |L2.118|
000076  4668              MOV      r0,sp                 ;269
000078  f7fffffe          BL       OSSchedUnlock
00007c  f247303d          MOV      r0,#0x733d            ;270
                  |L2.128|
000080  8020              STRH     r0,[r4,#0]            ;275
                  |L2.130|
000082  2000              MOVS     r0,#0                 ;276
000084  bdf8              POP      {r3-r7,pc}
;;;279    #endif
                          ENDP

000086  0000              DCW      0x0000
                  |L2.136|
                          DCD      OSIntNestingCtr
                  |L2.140|
                          DCD      0x20524d54
                  |L2.144|
                          DCD      OSTmrQty

                          AREA ||i.OSTmrRemainGet||, CODE, READONLY, ALIGN=2

                  OSTmrRemainGet PROC
;;;304    
;;;305    OS_TICK  OSTmrRemainGet (OS_TMR  *p_tmr,
000000  b5f8              PUSH     {r3-r7,lr}
;;;306                             OS_ERR  *p_err)
;;;307    {
000002  4604              MOV      r4,r0
;;;308        OS_TICK  remain;
;;;309        OS_ERR   err;
;;;310    
;;;311    
;;;312    
;;;313    #ifdef OS_SAFETY_CRITICAL
;;;314        if (p_err == (OS_ERR *)0) {
;;;315            OS_SAFETY_CRITICAL_EXCEPTION();
;;;316            return ((OS_TICK)0);
;;;317        }
;;;318    #endif
;;;319    
;;;320    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;321        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if trying to call from an ISR                      */
000004  4821              LDR      r0,|L3.140|
000006  460d              MOV      r5,r1                 ;307
000008  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
00000a  b110              CBZ      r0,|L3.18|
;;;322           *p_err = OS_ERR_TMR_ISR;
00000c  f2473043          MOV      r0,#0x7343
;;;323            return ((OS_TICK)0);
000010  e009              B        |L3.38|
                  |L3.18|
;;;324        }
;;;325    #endif
;;;326    
;;;327    #if OS_CFG_ARG_CHK_EN > 0u
;;;328        if (p_tmr == (OS_TMR *)0) {
000012  b134              CBZ      r4,|L3.34|
;;;329           *p_err = OS_ERR_TMR_INVALID;
;;;330            return ((OS_TICK)0);
;;;331        }
;;;332    #endif
;;;333    
;;;334    #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
;;;335        if (p_tmr->Type != OS_OBJ_TYPE_TMR) {                   /* Make sure timer was created                            */
000014  491e              LDR      r1,|L3.144|
000016  6820              LDR      r0,[r4,#0]
000018  4288              CMP      r0,r1
00001a  d006              BEQ      |L3.42|
;;;336           *p_err = OS_ERR_OBJ_TYPE;
00001c  f64550c4          MOV      r0,#0x5dc4
;;;337            return ((OS_TICK)0);
000020  e031              B        |L3.134|
                  |L3.34|
000022  f2473042          MOV      r0,#0x7342            ;329
                  |L3.38|
000026  8008              STRH     r0,[r1,#0]            ;322
000028  e02e              B        |L3.136|
                  |L3.42|
;;;338        }
;;;339    #endif
;;;340    
;;;341        OSSchedLock(&err);
00002a  4668              MOV      r0,sp
00002c  f7fffffe          BL       OSSchedLock
;;;342        switch (p_tmr->State) {
000030  f894002a          LDRB     r0,[r4,#0x2a]
000034  b310              CBZ      r0,|L3.124|
000036  2700              MOVS     r7,#0
000038  2801              CMP      r0,#1
00003a  d00e              BEQ      |L3.90|
00003c  2802              CMP      r0,#2
00003e  d007              BEQ      |L3.80|
000040  2803              CMP      r0,#3
;;;343            case OS_TMR_STATE_RUNNING:
;;;344                 remain        = p_tmr->Match                   /* Determine how much time is left to timeout             */
;;;345                               - OSTmrTickCtr;
;;;346                 p_tmr->Remain = remain;
;;;347                 OSSchedUnlock(&err);
;;;348                *p_err         = OS_ERR_NONE;
;;;349                 return (remain);
;;;350    
;;;351            case OS_TMR_STATE_STOPPED:                          /* It's assumed that the timer has not started yet        */
;;;352                 if (p_tmr->Opt == OS_OPT_TMR_PERIODIC) {
;;;353                     if (p_tmr->Dly == 0u) {
;;;354                         remain = p_tmr->Period;
;;;355                     } else {
;;;356                         remain = p_tmr->Dly;
;;;357                     }
;;;358                 } else {
;;;359                     remain = p_tmr->Dly;
;;;360                 }
;;;361                 p_tmr->Remain = remain;
;;;362                 OSSchedUnlock(&err);
;;;363                *p_err         = OS_ERR_NONE;
;;;364                 return (remain);
;;;365    
;;;366            case OS_TMR_STATE_COMPLETED:                        /* Only ONE-SHOT that timed out can be in this state      */
;;;367                 OSSchedUnlock(&err);
000042  4668              MOV      r0,sp
000044  d016              BEQ      |L3.116|
;;;368                *p_err = OS_ERR_NONE;
;;;369                 return ((OS_TICK)0);
;;;370    
;;;371            case OS_TMR_STATE_UNUSED:
;;;372                 OSSchedUnlock(&err);
;;;373                *p_err = OS_ERR_TMR_INACTIVE;
;;;374                 return ((OS_TICK)0);
;;;375    
;;;376            default:
;;;377                 OSSchedUnlock(&err);
000046  f7fffffe          BL       OSSchedUnlock
;;;378                *p_err = OS_ERR_TMR_INVALID_STATE;
00004a  f2473041          MOV      r0,#0x7341
;;;379                 return ((OS_TICK)0);
00004e  e01a              B        |L3.134|
                  |L3.80|
000050  4910              LDR      r1,|L3.148|
000052  69a0              LDR      r0,[r4,#0x18]         ;344
000054  6809              LDR      r1,[r1,#0]            ;344  ; OSTmrTickCtr
000056  1a46              SUBS     r6,r0,r1              ;344
000058  e005              B        |L3.102|
                  |L3.90|
00005a  8d20              LDRH     r0,[r4,#0x28]         ;352
00005c  6a26              LDR      r6,[r4,#0x20]         ;352
00005e  2802              CMP      r0,#2                 ;352
000060  d101              BNE      |L3.102|
000062  b906              CBNZ     r6,|L3.102|
000064  6a66              LDR      r6,[r4,#0x24]         ;354
                  |L3.102|
000066  4668              MOV      r0,sp                 ;362
000068  61e6              STR      r6,[r4,#0x1c]         ;362
00006a  f7fffffe          BL       OSSchedUnlock
00006e  802f              STRH     r7,[r5,#0]            ;363
000070  4630              MOV      r0,r6                 ;364
;;;380        }
;;;381    }
000072  bdf8              POP      {r3-r7,pc}
                  |L3.116|
000074  f7fffffe          BL       OSSchedUnlock
000078  802f              STRH     r7,[r5,#0]            ;368
00007a  e005              B        |L3.136|
                  |L3.124|
00007c  4668              MOV      r0,sp                 ;372
00007e  f7fffffe          BL       OSSchedUnlock
000082  f247303d          MOV      r0,#0x733d            ;373
                  |L3.134|
000086  8028              STRH     r0,[r5,#0]            ;378
                  |L3.136|
000088  2000              MOVS     r0,#0                 ;379
00008a  bdf8              POP      {r3-r7,pc}
;;;382    
                          ENDP

                  |L3.140|
                          DCD      OSIntNestingCtr
                  |L3.144|
                          DCD      0x20524d54
                  |L3.148|
                          DCD      OSTmrTickCtr

                          AREA ||i.OSTmrStart||, CODE, READONLY, ALIGN=2

                  OSTmrStart PROC
;;;410    
;;;411    CPU_BOOLEAN  OSTmrStart (OS_TMR  *p_tmr,
000000  b5f8              PUSH     {r3-r7,lr}
;;;412                             OS_ERR  *p_err)
;;;413    {
000002  4605              MOV      r5,r0
;;;414        OS_ERR  err;
;;;415    
;;;416    
;;;417    
;;;418    #ifdef OS_SAFETY_CRITICAL
;;;419        if (p_err == (OS_ERR *)0) {
;;;420            OS_SAFETY_CRITICAL_EXCEPTION();
;;;421            return (DEF_FALSE);
;;;422        }
;;;423    #endif
;;;424    
;;;425    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;426        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if trying to call from an ISR                      */
000004  481d              LDR      r0,|L4.124|
000006  460c              MOV      r4,r1                 ;413
000008  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
00000a  b110              CBZ      r0,|L4.18|
;;;427           *p_err = OS_ERR_TMR_ISR;
00000c  f2473043          MOV      r0,#0x7343
;;;428            return (DEF_FALSE);
000010  e009              B        |L4.38|
                  |L4.18|
;;;429        }
;;;430    #endif
;;;431    
;;;432    #if OS_CFG_ARG_CHK_EN > 0u
;;;433        if (p_tmr == (OS_TMR *)0) {
000012  b135              CBZ      r5,|L4.34|
;;;434           *p_err = OS_ERR_TMR_INVALID;
;;;435            return (DEF_FALSE);
;;;436        }
;;;437    #endif
;;;438    
;;;439    #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
;;;440        if (p_tmr->Type != OS_OBJ_TYPE_TMR) {                   /* Make sure timer was created                            */
000014  491a              LDR      r1,|L4.128|
000016  6828              LDR      r0,[r5,#0]
000018  4288              CMP      r0,r1
00001a  d006              BEQ      |L4.42|
;;;441           *p_err = OS_ERR_OBJ_TYPE;
00001c  f64550c4          MOV      r0,#0x5dc4
;;;442            return (DEF_FALSE);
000020  e028              B        |L4.116|
                  |L4.34|
000022  f2473042          MOV      r0,#0x7342            ;434
                  |L4.38|
000026  8008              STRH     r0,[r1,#0]            ;427
000028  e025              B        |L4.118|
                  |L4.42|
;;;443        }
;;;444    #endif
;;;445    
;;;446        OSSchedLock(&err);
00002a  4668              MOV      r0,sp
00002c  f7fffffe          BL       OSSchedLock
;;;447        switch (p_tmr->State) {
000030  f895002a          LDRB     r0,[r5,#0x2a]
000034  b1c8              CBZ      r0,|L4.106|
000036  2600              MOVS     r6,#0
000038  2801              CMP      r0,#1
00003a  d00c              BEQ      |L4.86|
00003c  2802              CMP      r0,#2
00003e  d007              BEQ      |L4.80|
000040  2803              CMP      r0,#3
000042  d008              BEQ      |L4.86|
;;;448            case OS_TMR_STATE_RUNNING:                          /* Restart the timer                                      */
;;;449                 OS_TmrUnlink(p_tmr);                           /* ... Stop the timer                                     */
;;;450                 OS_TmrLink(p_tmr, OS_OPT_LINK_DLY);            /* ... Link timer to timer wheel (see Note #1).           */
;;;451                 OSSchedUnlock(&err);
;;;452                *p_err = OS_ERR_NONE;
;;;453                 return (DEF_TRUE);
;;;454    
;;;455            case OS_TMR_STATE_STOPPED:                          /* Start the timer                                        */
;;;456            case OS_TMR_STATE_COMPLETED:
;;;457                 OS_TmrLink(p_tmr, OS_OPT_LINK_DLY);            /* ... Link timer to timer wheel (see Note #1).           */
;;;458                 OSSchedUnlock(&err);
;;;459                *p_err = OS_ERR_NONE;
;;;460                 return (DEF_TRUE);
;;;461    
;;;462            case OS_TMR_STATE_UNUSED:                           /* Timer not created                                      */
;;;463                 OSSchedUnlock(&err);
;;;464                *p_err = OS_ERR_TMR_INACTIVE;
;;;465                 return (DEF_FALSE);
;;;466    
;;;467            default:
;;;468                 OSSchedUnlock(&err);
000044  4668              MOV      r0,sp
000046  f7fffffe          BL       OSSchedUnlock
;;;469                *p_err = OS_ERR_TMR_INVALID_STATE;
00004a  f2473041          MOV      r0,#0x7341
;;;470                 return (DEF_FALSE);
00004e  e011              B        |L4.116|
                  |L4.80|
000050  4628              MOV      r0,r5                 ;449
000052  f7fffffe          BL       OS_TmrUnlink
                  |L4.86|
000056  2100              MOVS     r1,#0                 ;457
000058  4628              MOV      r0,r5                 ;457
00005a  f7fffffe          BL       OS_TmrLink
00005e  4668              MOV      r0,sp                 ;458
000060  f7fffffe          BL       OSSchedUnlock
000064  8026              STRH     r6,[r4,#0]            ;459
000066  2001              MOVS     r0,#1                 ;460
;;;471        }
;;;472    }
000068  bdf8              POP      {r3-r7,pc}
                  |L4.106|
00006a  4668              MOV      r0,sp                 ;463
00006c  f7fffffe          BL       OSSchedUnlock
000070  f247303d          MOV      r0,#0x733d            ;464
                  |L4.116|
000074  8020              STRH     r0,[r4,#0]            ;469
                  |L4.118|
000076  2000              MOVS     r0,#0                 ;470
000078  bdf8              POP      {r3-r7,pc}
;;;473    
                          ENDP

00007a  0000              DCW      0x0000
                  |L4.124|
                          DCD      OSIntNestingCtr
                  |L4.128|
                          DCD      0x20524d54

                          AREA ||i.OSTmrStateGet||, CODE, READONLY, ALIGN=2

                  OSTmrStateGet PROC
;;;499    
;;;500    OS_STATE  OSTmrStateGet (OS_TMR  *p_tmr,
000000  b570              PUSH     {r4-r6,lr}
;;;501                             OS_ERR  *p_err)
;;;502    {
000002  4605              MOV      r5,r0
;;;503        OS_STATE  state;
;;;504        CPU_SR_ALLOC();
;;;505    
;;;506    
;;;507    
;;;508    #ifdef OS_SAFETY_CRITICAL
;;;509        if (p_err == (OS_ERR *)0) {
;;;510            OS_SAFETY_CRITICAL_EXCEPTION();
;;;511            return (OS_TMR_STATE_UNUSED);
;;;512        }
;;;513    #endif
;;;514    
;;;515    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;516        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {              /* See if trying to call from an ISR                      */
000004  4814              LDR      r0,|L5.88|
000006  460c              MOV      r4,r1                 ;502
000008  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
00000a  b110              CBZ      r0,|L5.18|
;;;517           *p_err = OS_ERR_TMR_ISR;
00000c  f2473043          MOV      r0,#0x7343
;;;518            return (OS_TMR_STATE_UNUSED);
000010  e00b              B        |L5.42|
                  |L5.18|
;;;519        }
;;;520    #endif
;;;521    
;;;522    #if OS_CFG_ARG_CHK_EN > 0u
;;;523        if (p_tmr == (OS_TMR *)0) {
000012  b145              CBZ      r5,|L5.38|
;;;524           *p_err = OS_ERR_TMR_INVALID;
;;;525            return (OS_TMR_STATE_UNUSED);
;;;526        }
;;;527    #endif
;;;528    
;;;529    #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
;;;530        if (p_tmr->Type != OS_OBJ_TYPE_TMR) {                   /* Make sure timer was created                            */
000014  4911              LDR      r1,|L5.92|
000016  6828              LDR      r0,[r5,#0]
000018  4288              CMP      r0,r1
00001a  d008              BEQ      |L5.46|
;;;531           *p_err = OS_ERR_OBJ_TYPE;
00001c  f64550c4          MOV      r0,#0x5dc4
000020  8020              STRH     r0,[r4,#0]
                  |L5.34|
;;;532            return (OS_TMR_STATE_UNUSED);
000022  2000              MOVS     r0,#0
;;;533        }
;;;534    #endif
;;;535    
;;;536        CPU_CRITICAL_ENTER();
;;;537        state = p_tmr->State;
;;;538        switch (state) {
;;;539            case OS_TMR_STATE_UNUSED:
;;;540            case OS_TMR_STATE_STOPPED:
;;;541            case OS_TMR_STATE_COMPLETED:
;;;542            case OS_TMR_STATE_RUNNING:
;;;543                *p_err = OS_ERR_NONE;
;;;544                 break;
;;;545    
;;;546            default:
;;;547                *p_err = OS_ERR_TMR_INVALID_STATE;
;;;548                 break;
;;;549        }
;;;550        CPU_CRITICAL_EXIT();
;;;551        return (state);
;;;552    }
000024  bd70              POP      {r4-r6,pc}
                  |L5.38|
000026  f2473042          MOV      r0,#0x7342            ;524
                  |L5.42|
00002a  8008              STRH     r0,[r1,#0]            ;517
00002c  e7f9              B        |L5.34|
                  |L5.46|
00002e  f7fffffe          BL       CPU_SR_Save
000032  f895502a          LDRB     r5,[r5,#0x2a]         ;537
000036  b145              CBZ      r5,|L5.74|
000038  2d01              CMP      r5,#1                 ;538
00003a  d006              BEQ      |L5.74|
00003c  2d02              CMP      r5,#2                 ;538
00003e  d004              BEQ      |L5.74|
000040  2d03              CMP      r5,#3                 ;538
000042  d002              BEQ      |L5.74|
000044  f2473141          MOV      r1,#0x7341            ;547
000048  e000              B        |L5.76|
                  |L5.74|
00004a  2100              MOVS     r1,#0                 ;543
                  |L5.76|
00004c  8021              STRH     r1,[r4,#0]            ;543
00004e  f7fffffe          BL       CPU_SR_Restore
000052  4628              MOV      r0,r5                 ;551
000054  bd70              POP      {r4-r6,pc}
;;;553    
                          ENDP

000056  0000              DCW      0x0000
                  |L5.88|
                          DCD      OSIntNestingCtr
                  |L5.92|
                          DCD      0x20524d54

                          AREA ||i.OSTmrStop||, CODE, READONLY, ALIGN=2

                  OSTmrStop PROC
;;;590    
;;;591    CPU_BOOLEAN  OSTmrStop (OS_TMR  *p_tmr,
000000  b5f8              PUSH     {r3-r7,lr}
;;;592                            OS_OPT   opt,
;;;593                            void    *p_callback_arg,
;;;594                            OS_ERR  *p_err)
;;;595    {
000002  4605              MOV      r5,r0
;;;596        OS_TMR_CALLBACK_PTR  p_fnct;
;;;597        OS_ERR               err;
;;;598    
;;;599    
;;;600    
;;;601    #ifdef OS_SAFETY_CRITICAL
;;;602        if (p_err == (OS_ERR *)0) {
;;;603            OS_SAFETY_CRITICAL_EXCEPTION();
;;;604            return (DEF_FALSE);
;;;605        }
;;;606    #endif
;;;607    
;;;608    #if OS_CFG_CALLED_FROM_ISR_CHK_EN > 0u
;;;609        if (OSIntNestingCtr > (OS_NESTING_CTR)0) {                        /* See if trying to call from an ISR            */
000004  482d              LDR      r0,|L6.188|
000006  4616              MOV      r6,r2                 ;595
000008  460f              MOV      r7,r1                 ;595
00000a  7800              LDRB     r0,[r0,#0]  ; OSIntNestingCtr
00000c  461c              MOV      r4,r3                 ;595
00000e  b110              CBZ      r0,|L6.22|
;;;610           *p_err = OS_ERR_TMR_ISR;
000010  f2473043          MOV      r0,#0x7343
;;;611            return (DEF_FALSE);
000014  e009              B        |L6.42|
                  |L6.22|
;;;612        }
;;;613    #endif
;;;614    
;;;615    #if OS_CFG_ARG_CHK_EN > 0u
;;;616        if (p_tmr == (OS_TMR *)0) {
000016  b135              CBZ      r5,|L6.38|
;;;617           *p_err = OS_ERR_TMR_INVALID;
;;;618            return (DEF_FALSE);
;;;619        }
;;;620    #endif
;;;621    
;;;622    #if OS_CFG_OBJ_TYPE_CHK_EN > 0u
;;;623        if (p_tmr->Type != OS_OBJ_TYPE_TMR) {                             /* Make sure timer was created                  */
000018  4929              LDR      r1,|L6.192|
00001a  6828              LDR      r0,[r5,#0]
00001c  4288              CMP      r0,r1
00001e  d006              BEQ      |L6.46|
;;;624           *p_err = OS_ERR_OBJ_TYPE;
000020  f64550c4          MOV      r0,#0x5dc4
;;;625            return (DEF_FALSE);
000024  e001              B        |L6.42|
                  |L6.38|
000026  f2473042          MOV      r0,#0x7342            ;617
                  |L6.42|
00002a  8018              STRH     r0,[r3,#0]            ;610
00002c  e043              B        |L6.182|
                  |L6.46|
;;;626        }
;;;627    #endif
;;;628    
;;;629        OSSchedLock(&err);
00002e  4668              MOV      r0,sp
000030  f7fffffe          BL       OSSchedLock
;;;630        switch (p_tmr->State) {
000034  f895002a          LDRB     r0,[r5,#0x2a]
000038  b378              CBZ      r0,|L6.154|
00003a  2801              CMP      r0,#1
00003c  d02e              BEQ      |L6.156|
00003e  2802              CMP      r0,#2
000040  d007              BEQ      |L6.82|
000042  2803              CMP      r0,#3
000044  d02a              BEQ      |L6.156|
;;;631            case OS_TMR_STATE_RUNNING:
;;;632                 OS_TmrUnlink(p_tmr);                                     /* Remove from current wheel spoke              */
;;;633                *p_err = OS_ERR_NONE;
;;;634                 switch (opt) {
;;;635                     case OS_OPT_TMR_CALLBACK:
;;;636                          p_fnct = p_tmr->CallbackPtr;                         /* Execute callback function ...           */
;;;637                          if (p_fnct != (OS_TMR_CALLBACK_PTR)0) {              /* ... if available                        */
;;;638                            (*p_fnct)((void *)p_tmr, p_tmr->CallbackPtrArg);   /* Use callback arg when timer was created */
;;;639                          } else {
;;;640                             *p_err = OS_ERR_TMR_NO_CALLBACK;
;;;641                          }
;;;642                          break;
;;;643    
;;;644                     case OS_OPT_TMR_CALLBACK_ARG:
;;;645                          p_fnct = p_tmr->CallbackPtr;                    /* Execute callback function if available ...   */
;;;646                          if (p_fnct != (OS_TMR_CALLBACK_PTR)0) {
;;;647                            (*p_fnct)((void *)p_tmr, p_callback_arg);     /* .. using the 'callback_arg' provided in call */
;;;648                          } else {
;;;649                             *p_err = OS_ERR_TMR_NO_CALLBACK;
;;;650                          }
;;;651                          break;
;;;652    
;;;653                     case OS_OPT_TMR_NONE:
;;;654                          break;
;;;655    
;;;656                     default:
;;;657                         OSSchedUnlock(&err);
;;;658                        *p_err = OS_ERR_OPT_INVALID;
;;;659                         return (DEF_FALSE);
;;;660                 }
;;;661                 OSSchedUnlock(&err);
;;;662                 return (DEF_TRUE);
;;;663    
;;;664            case OS_TMR_STATE_COMPLETED:                                  /* Timer has already completed the ONE-SHOT or  */
;;;665            case OS_TMR_STATE_STOPPED:                                    /* ... timer has not started yet.               */
;;;666                 OSSchedUnlock(&err);
;;;667                *p_err = OS_ERR_TMR_STOPPED;
;;;668                 return (DEF_TRUE);
;;;669    
;;;670            case OS_TMR_STATE_UNUSED:                                     /* Timer was not created                        */
;;;671                 OSSchedUnlock(&err);
;;;672                *p_err = OS_ERR_TMR_INACTIVE;
;;;673                 return (DEF_FALSE);
;;;674    
;;;675            default:
;;;676                 OSSchedUnlock(&err);
000046  4668              MOV      r0,sp
000048  f7fffffe          BL       OSSchedUnlock
;;;677                *p_err = OS_ERR_TMR_INVALID_STATE;
00004c  f2473041          MOV      r0,#0x7341
;;;678                 return (DEF_FALSE);
000050  e030              B        |L6.180|
                  |L6.82|
000052  4628              MOV      r0,r5                 ;632
000054  f7fffffe          BL       OS_TmrUnlink
000058  2000              MOVS     r0,#0                 ;633
00005a  8020              STRH     r0,[r4,#0]            ;633
00005c  b1c7              CBZ      r7,|L6.144|
00005e  f2473044          MOV      r0,#0x7344            ;640
000062  2f03              CMP      r7,#3                 ;634
000064  d007              BEQ      |L6.118|
000066  2f04              CMP      r7,#4                 ;634
000068  d00b              BEQ      |L6.130|
00006a  4668              MOV      r0,sp                 ;657
00006c  f7fffffe          BL       OSSchedUnlock
000070  f6456025          MOV      r0,#0x5e25            ;658
000074  e01e              B        |L6.180|
                  |L6.118|
000076  68aa              LDR      r2,[r5,#8]            ;637
000078  b14a              CBZ      r2,|L6.142|
00007a  4628              MOV      r0,r5                 ;638
00007c  68e9              LDR      r1,[r5,#0xc]          ;638
00007e  4790              BLX      r2                    ;638
000080  e006              B        |L6.144|
                  |L6.130|
000082  68ab              LDR      r3,[r5,#8]            ;646
000084  b11b              CBZ      r3,|L6.142|
000086  4631              MOV      r1,r6                 ;647
000088  4628              MOV      r0,r5                 ;647
00008a  4798              BLX      r3                    ;647
00008c  e000              B        |L6.144|
                  |L6.142|
00008e  8020              STRH     r0,[r4,#0]            ;649
                  |L6.144|
000090  4668              MOV      r0,sp                 ;661
000092  f7fffffe          BL       OSSchedUnlock
                  |L6.150|
000096  2001              MOVS     r0,#1                 ;668
                  |L6.152|
;;;679        }
;;;680    }
000098  bdf8              POP      {r3-r7,pc}
                  |L6.154|
00009a  e006              B        |L6.170|
                  |L6.156|
00009c  4668              MOV      r0,sp                 ;666
00009e  f7fffffe          BL       OSSchedUnlock
0000a2  f2473049          MOV      r0,#0x7349            ;667
0000a6  8020              STRH     r0,[r4,#0]            ;667
0000a8  e7f5              B        |L6.150|
                  |L6.170|
0000aa  4668              MOV      r0,sp                 ;671
0000ac  f7fffffe          BL       OSSchedUnlock
0000b0  f247303d          MOV      r0,#0x733d            ;672
                  |L6.180|
0000b4  8020              STRH     r0,[r4,#0]            ;677
                  |L6.182|
0000b6  2000              MOVS     r0,#0                 ;678
0000b8  e7ee              B        |L6.152|
;;;681    
                          ENDP

0000ba  0000              DCW      0x0000
                  |L6.188|
                          DCD      OSIntNestingCtr
                  |L6.192|
                          DCD      0x20524d54

                          AREA ||i.OS_TmrClr||, CODE, READONLY, ALIGN=2

                  OS_TmrClr PROC
;;;697    
;;;698    void  OS_TmrClr (OS_TMR  *p_tmr)
000000  2100              MOVS     r1,#0
;;;699    {
;;;700        p_tmr->State          = OS_TMR_STATE_UNUSED;            /* Clear timer fields                                     */
000002  f880102a          STRB     r1,[r0,#0x2a]
;;;701        p_tmr->Type           = OS_OBJ_TYPE_NONE;
000006  4a07              LDR      r2,|L7.36|
;;;702        p_tmr->NamePtr        = (CPU_CHAR          *)((void *)"?TMR");
000008  6002              STR      r2,[r0,#0]
;;;703        p_tmr->Dly            = (OS_TICK            )0;
;;;704        p_tmr->Match          = (OS_TICK            )0;
00000a  6201              STR      r1,[r0,#0x20]
;;;705        p_tmr->Remain         = (OS_TICK            )0;
00000c  6181              STR      r1,[r0,#0x18]
00000e  a206              ADR      r2,|L7.40|
;;;706        p_tmr->Period         = (OS_TICK            )0;
000010  61c1              STR      r1,[r0,#0x1c]
;;;707        p_tmr->Opt            = (OS_OPT             )0;
000012  6042              STR      r2,[r0,#4]
000014  6241              STR      r1,[r0,#0x24]
000016  8501              STRH     r1,[r0,#0x28]
;;;708        p_tmr->CallbackPtr    = (OS_TMR_CALLBACK_PTR)0;
;;;709        p_tmr->CallbackPtrArg = (void              *)0;
000018  6081              STR      r1,[r0,#8]
;;;710        p_tmr->NextPtr        = (OS_TMR            *)0;
00001a  60c1              STR      r1,[r0,#0xc]
;;;711        p_tmr->PrevPtr        = (OS_TMR            *)0;
00001c  6101              STR      r1,[r0,#0x10]
00001e  6141              STR      r1,[r0,#0x14]
;;;712    }
000020  4770              BX       lr
;;;713    
                          ENDP

000022  0000              DCW      0x0000
                  |L7.36|
                          DCD      0x454e4f4e
                  |L7.40|
000028  3f544d52          DCB      "?TMR",0
00002c  00      
00002d  00                DCB      0
00002e  00                DCB      0
00002f  00                DCB      0

                          AREA ||i.OS_TmrDbgListAdd||, CODE, READONLY, ALIGN=2

                  OS_TmrDbgListAdd PROC
;;;730    #if OS_CFG_DBG_EN > 0u
;;;731    void  OS_TmrDbgListAdd (OS_TMR  *p_tmr)
000000  4b05              LDR      r3,|L8.24|
;;;732    {
;;;733        p_tmr->DbgPrevPtr               = (OS_TMR *)0;
000002  2200              MOVS     r2,#0
;;;734        if (OSTmrDbgListPtr == (OS_TMR *)0) {
000004  62c2              STR      r2,[r0,#0x2c]
000006  6819              LDR      r1,[r3,#0]            ;732  ; OSTmrDbgListPtr
000008  b119              CBZ      r1,|L8.18|
;;;735            p_tmr->DbgNextPtr           = (OS_TMR *)0;
;;;736        } else {
;;;737            p_tmr->DbgNextPtr           =  OSTmrDbgListPtr;
;;;738            OSTmrDbgListPtr->DbgPrevPtr =  p_tmr;
00000a  6301              STR      r1,[r0,#0x30]
00000c  62c8              STR      r0,[r1,#0x2c]
                  |L8.14|
;;;739        }
;;;740        OSTmrDbgListPtr                 =  p_tmr;
;;;741    }
00000e  6018              STR      r0,[r3,#0]  ; OSTmrDbgListPtr
000010  4770              BX       lr
                  |L8.18|
000012  6302              STR      r2,[r0,#0x30]         ;735
000014  e7fb              B        |L8.14|
;;;742    
                          ENDP

000016  0000              DCW      0x0000
                  |L8.24|
                          DCD      OSTmrDbgListPtr

                          AREA ||i.OS_TmrDbgListRemove||, CODE, READONLY, ALIGN=2

                  OS_TmrDbgListRemove PROC
;;;744    
;;;745    void  OS_TmrDbgListRemove (OS_TMR  *p_tmr)
000000  e9d0210b          LDRD     r2,r1,[r0,#0x2c]
;;;746    {
000004  2300              MOVS     r3,#0
000006  b12a              CBZ      r2,|L9.20|
;;;747        OS_TMR  *p_tmr_next;
;;;748        OS_TMR  *p_tmr_prev;
;;;749    
;;;750    
;;;751        p_tmr_prev = p_tmr->DbgPrevPtr;
;;;752        p_tmr_next = p_tmr->DbgNextPtr;
;;;753    
;;;754        if (p_tmr_prev == (OS_TMR *)0) {
;;;755            OSTmrDbgListPtr = p_tmr_next;
;;;756            if (p_tmr_next != (OS_TMR *)0) {
;;;757                p_tmr_next->DbgPrevPtr = (OS_TMR *)0;
;;;758            }
;;;759            p_tmr->DbgNextPtr = (OS_TMR *)0;
;;;760    
;;;761        } else if (p_tmr_next == (OS_TMR *)0) {
000008  b151              CBZ      r1,|L9.32|
;;;762            p_tmr_prev->DbgNextPtr = (OS_TMR *)0;
;;;763            p_tmr->DbgPrevPtr      = (OS_TMR *)0;
;;;764    
;;;765        } else {
;;;766            p_tmr_prev->DbgNextPtr =  p_tmr_next;
;;;767            p_tmr_next->DbgPrevPtr =  p_tmr_prev;
00000a  6311              STR      r1,[r2,#0x30]
;;;768            p_tmr->DbgNextPtr      = (OS_TMR *)0;
00000c  62ca              STR      r2,[r1,#0x2c]
00000e  6303              STR      r3,[r0,#0x30]
                  |L9.16|
;;;769            p_tmr->DbgPrevPtr      = (OS_TMR *)0;
000010  62c3              STR      r3,[r0,#0x2c]
;;;770        }
;;;771    }
000012  4770              BX       lr
                  |L9.20|
000014  4a03              LDR      r2,|L9.36|
000016  6011              STR      r1,[r2,#0]            ;756  ; OSTmrDbgListPtr
000018  b101              CBZ      r1,|L9.28|
00001a  62cb              STR      r3,[r1,#0x2c]         ;757
                  |L9.28|
00001c  6303              STR      r3,[r0,#0x30]         ;759
00001e  4770              BX       lr
                  |L9.32|
000020  6313              STR      r3,[r2,#0x30]         ;763
000022  e7f5              B        |L9.16|
;;;772    #endif
                          ENDP

                  |L9.36|
                          DCD      OSTmrDbgListPtr

                          AREA ||i.OS_TmrInit||, CODE, READONLY, ALIGN=2

                  OS_TmrInit PROC
;;;794    
;;;795    void  OS_TmrInit (OS_ERR  *p_err)
000000  b530              PUSH     {r4,r5,lr}
;;;796    {
;;;797        OS_TMR_SPOKE_IX   i;
;;;798        OS_TMR_SPOKE     *p_spoke;
;;;799    
;;;800    
;;;801    
;;;802    #ifdef OS_SAFETY_CRITICAL
;;;803        if (p_err == (OS_ERR *)0) {
;;;804            OS_SAFETY_CRITICAL_EXCEPTION();
;;;805            return;
;;;806        }
;;;807    #endif
;;;808    
;;;809    #if OS_CFG_DBG_EN > 0u
;;;810        OSTmrDbgListPtr = (OS_TMR *)0;
000002  4a2a              LDR      r2,|L10.172|
000004  b089              SUB      sp,sp,#0x24           ;796
000006  2100              MOVS     r1,#0
;;;811    #endif
;;;812    
;;;813        if (OSCfg_TmrTaskRate_Hz > (OS_RATE_HZ)0) {
000008  4b29              LDR      r3,|L10.176|
00000a  6011              STR      r1,[r2,#0]  ; OSTmrDbgListPtr
;;;814            OSTmrUpdateCnt = OSCfg_TickRate_Hz / OSCfg_TmrTaskRate_Hz;
00000c  4c29              LDR      r4,|L10.180|
00000e  4a2a              LDR      r2,|L10.184|
000010  681d              LDR      r5,[r3,#0]            ;796  ; OSCfg_TmrTaskRate_Hz
000012  b11d              CBZ      r5,|L10.28|
000014  6824              LDR      r4,[r4,#0]  ; OSCfg_TickRate_Hz
000016  fbb4f3f5          UDIV     r3,r4,r5
00001a  e003              B        |L10.36|
                  |L10.28|
;;;815        } else {
;;;816            OSTmrUpdateCnt = OSCfg_TickRate_Hz / (OS_RATE_HZ)10;
00001c  6823              LDR      r3,[r4,#0]  ; OSCfg_TickRate_Hz
00001e  240a              MOVS     r4,#0xa
000020  fbb3f3f4          UDIV     r3,r3,r4
                  |L10.36|
;;;817        }
;;;818        OSTmrUpdateCtr   = OSTmrUpdateCnt;
000024  6013              STR      r3,[r2,#0]  ; OSTmrUpdateCnt
000026  461a              MOV      r2,r3
000028  4b24              LDR      r3,|L10.188|
;;;819    
;;;820        OSTmrTickCtr     = (OS_TICK)0;
;;;821    
;;;822        OSTmrTaskTimeMax = (CPU_TS)0;
;;;823    
;;;824        for (i = 0u; i < OSCfg_TmrWheelSize; i++) {
;;;825            p_spoke                = &OSCfg_TmrWheel[i];
00002a  4d27              LDR      r5,|L10.200|
00002c  4c27              LDR      r4,|L10.204|
00002e  601a              STR      r2,[r3,#0]            ;820  ; OSTmrUpdateCtr
000030  4a23              LDR      r2,|L10.192|
000032  6011              STR      r1,[r2,#0]            ;822  ; OSTmrTickCtr
000034  4a23              LDR      r2,|L10.196|
000036  6011              STR      r1,[r2,#0]            ;824  ; OSTmrTaskTimeMax
000038  2200              MOVS     r2,#0                 ;824
00003a  e006              B        |L10.74|
                  |L10.60|
00003c  eb0503c2          ADD      r3,r5,r2,LSL #3
000040  1c52              ADDS     r2,r2,#1              ;824
;;;826            p_spoke->NbrEntries    = (OS_OBJ_QTY)0;
000042  8099              STRH     r1,[r3,#4]
;;;827            p_spoke->NbrEntriesMax = (OS_OBJ_QTY)0;
000044  80d9              STRH     r1,[r3,#6]
000046  b292              UXTH     r2,r2                 ;824
000048  6019              STR      r1,[r3,#0]            ;824
                  |L10.74|
00004a  8823              LDRH     r3,[r4,#0]            ;824  ; OSCfg_TmrWheelSize
00004c  429a              CMP      r2,r3                 ;824
00004e  d3f5              BCC      |L10.60|
;;;828            p_spoke->FirstPtr      = (OS_TMR   *)0;
;;;829        }
;;;830    
;;;831                                                                /* ---------------- CREATE THE TIMER TASK --------------- */
;;;832        if (OSCfg_TmrTaskStkBasePtr == (CPU_STK*)0) {
000050  4b1f              LDR      r3,|L10.208|
000052  681a              LDR      r2,[r3,#0]  ; OSCfg_TmrTaskStkBasePtr
000054  b142              CBZ      r2,|L10.104|
;;;833           *p_err = OS_ERR_TMR_STK_INVALID;
;;;834            return;
;;;835        }
;;;836    
;;;837        if (OSCfg_TmrTaskStkSize < OSCfg_StkSizeMin) {
000056  4a1f              LDR      r2,|L10.212|
000058  4d1f              LDR      r5,|L10.216|
00005a  6814              LDR      r4,[r2,#0]  ; OSCfg_TmrTaskStkSize
00005c  682d              LDR      r5,[r5,#0]  ; OSCfg_StkSizeMin
00005e  42ac              CMP      r4,r5
000060  d205              BCS      |L10.110|
;;;838           *p_err = OS_ERR_TMR_STK_SIZE_INVALID;
000062  f2473148          MOV      r1,#0x7348
;;;839            return;
000066  e008              B        |L10.122|
                  |L10.104|
000068  f2473147          MOV      r1,#0x7347            ;833
00006c  e005              B        |L10.122|
                  |L10.110|
;;;840        }
;;;841    
;;;842        if (OSCfg_TmrTaskPrio >= (OS_CFG_PRIO_MAX - 1u)) {
00006e  4c1b              LDR      r4,|L10.220|
000070  7825              LDRB     r5,[r4,#0]  ; OSCfg_TmrTaskPrio
000072  2d3f              CMP      r5,#0x3f
000074  d304              BCC      |L10.128|
;;;843           *p_err = OS_ERR_TMR_PRIO_INVALID;
000076  f2473146          MOV      r1,#0x7346
                  |L10.122|
00007a  8001              STRH     r1,[r0,#0]
                  |L10.124|
;;;844            return;
;;;845        }
;;;846    
;;;847        OSTaskCreate((OS_TCB     *)&OSTmrTaskTCB,
;;;848                     (CPU_CHAR   *)((void *)"uC/OS-III Timer Task"),
;;;849                     (OS_TASK_PTR )OS_TmrTask,
;;;850                     (void       *)0,
;;;851                     (OS_PRIO     )OSCfg_TmrTaskPrio,
;;;852                     (CPU_STK    *)OSCfg_TmrTaskStkBasePtr,
;;;853                     (CPU_STK_SIZE)OSCfg_TmrTaskStkLimit,
;;;854                     (CPU_STK_SIZE)OSCfg_TmrTaskStkSize,
;;;855                     (OS_MSG_QTY  )0,
;;;856                     (OS_TICK     )0,
;;;857                     (void       *)0,
;;;858                     (OS_OPT      )(OS_OPT_TASK_STK_CHK | OS_OPT_TASK_STK_CLR | OS_OPT_TASK_NO_TLS),
;;;859                     (OS_ERR     *)p_err);
;;;860    }
00007c  b009              ADD      sp,sp,#0x24
00007e  bd30              POP      {r4,r5,pc}
                  |L10.128|
000080  250b              MOVS     r5,#0xb               ;847
000082  9105              STR      r1,[sp,#0x14]         ;847
000084  9106              STR      r1,[sp,#0x18]         ;847
000086  e9cd5007          STRD     r5,r0,[sp,#0x1c]      ;847
00008a  6810              LDR      r0,[r2,#0]            ;847  ; OSCfg_TmrTaskStkSize
00008c  4a14              LDR      r2,|L10.224|
00008e  681b              LDR      r3,[r3,#0]            ;847  ; OSCfg_TmrTaskStkBasePtr
000090  6812              LDR      r2,[r2,#0]            ;847  ; OSCfg_TmrTaskStkLimit
000092  e9cd0103          STRD     r0,r1,[sp,#0xc]       ;847
000096  e9cd3201          STRD     r3,r2,[sp,#4]         ;847
00009a  7820              LDRB     r0,[r4,#0]            ;847  ; OSCfg_TmrTaskPrio
00009c  9000              STR      r0,[sp,#0]            ;847
00009e  2300              MOVS     r3,#0                 ;847
0000a0  4a10              LDR      r2,|L10.228|
0000a2  a111              ADR      r1,|L10.232|
0000a4  4816              LDR      r0,|L10.256|
0000a6  f7fffffe          BL       OSTaskCreate
0000aa  e7e7              B        |L10.124|
;;;861    
                          ENDP

                  |L10.172|
                          DCD      OSTmrDbgListPtr
                  |L10.176|
                          DCD      OSCfg_TmrTaskRate_Hz
                  |L10.180|
                          DCD      OSCfg_TickRate_Hz
                  |L10.184|
                          DCD      OSTmrUpdateCnt
                  |L10.188|
                          DCD      OSTmrUpdateCtr
                  |L10.192|
                          DCD      OSTmrTickCtr
                  |L10.196|
                          DCD      OSTmrTaskTimeMax
                  |L10.200|
                          DCD      OSCfg_TmrWheel
                  |L10.204|
                          DCD      OSCfg_TmrWheelSize
                  |L10.208|
                          DCD      OSCfg_TmrTaskStkBasePtr
                  |L10.212|
                          DCD      OSCfg_TmrTaskStkSize
                  |L10.216|
                          DCD      OSCfg_StkSizeMin
                  |L10.220|
                          DCD      OSCfg_TmrTaskPrio
                  |L10.224|
                          DCD      OSCfg_TmrTaskStkLimit
                  |L10.228|
                          DCD      OS_TmrTask
                  |L10.232|
0000e8  75432f4f          DCB      "uC/OS-III Timer Task",0
0000ec  532d4949
0000f0  49205469
0000f4  6d657220
0000f8  5461736b
0000fc  00      
0000fd  00                DCB      0
0000fe  00                DCB      0
0000ff  00                DCB      0
                  |L10.256|
                          DCD      OSTmrTaskTCB

                          AREA ||i.OS_TmrLink||, CODE, READONLY, ALIGN=2

                  OS_TmrLink PROC
;;;883    
;;;884    void  OS_TmrLink (OS_TMR  *p_tmr,
000000  b570              PUSH     {r4-r6,lr}
;;;885                      OS_OPT   opt)
;;;886    {
;;;887        OS_TMR_SPOKE     *p_spoke;
;;;888        OS_TMR           *p_tmr0;
;;;889        OS_TMR           *p_tmr1;
;;;890        OS_TMR_SPOKE_IX   spoke;
;;;891    
;;;892    
;;;893    
;;;894        p_tmr->State = OS_TMR_STATE_RUNNING;
000002  2202              MOVS     r2,#2
000004  f880202a          STRB     r2,[r0,#0x2a]
;;;895        if (opt == OS_OPT_LINK_PERIODIC) {                      /* Determine when timer will expire                      */
;;;896            p_tmr->Match = p_tmr->Period + OSTmrTickCtr;
000008  4a20              LDR      r2,|L11.140|
00000a  2901              CMP      r1,#1                 ;895
00000c  6814              LDR      r4,[r2,#0]            ;895
00000e  d01e              BEQ      |L11.78|
;;;897        } else {
;;;898            if (p_tmr->Dly == (OS_TICK)0) {
000010  6a01              LDR      r1,[r0,#0x20]
000012  b1e1              CBZ      r1,|L11.78|
                  |L11.20|
;;;899                p_tmr->Match = p_tmr->Period + OSTmrTickCtr;
;;;900            } else {
;;;901                p_tmr->Match = p_tmr->Dly    + OSTmrTickCtr;
;;;902            }
;;;903        }
;;;904        spoke  = (OS_TMR_SPOKE_IX)(p_tmr->Match % OSCfg_TmrWheelSize);
000014  4a1e              LDR      r2,|L11.144|
000016  4421              ADD      r1,r1,r4              ;901
000018  6181              STR      r1,[r0,#0x18]
00001a  8812              LDRH     r2,[r2,#0]  ; OSCfg_TmrWheelSize
00001c  fbb1f3f2          UDIV     r3,r1,r2
000020  fb021213          MLS      r2,r2,r3,r1
;;;905        p_spoke = &OSCfg_TmrWheel[spoke];
000024  4b1b              LDR      r3,|L11.148|
000026  b292              UXTH     r2,r2                 ;904
000028  eb0302c2          ADD      r2,r3,r2,LSL #3
;;;906    
;;;907        if (p_spoke->FirstPtr ==  (OS_TMR *)0) {                /* Link into timer wheel                                  */
00002c  2300              MOVS     r3,#0
00002e  6815              LDR      r5,[r2,#0]            ;901
000030  b17d              CBZ      r5,|L11.82|
;;;908            p_tmr->NextPtr      = (OS_TMR *)0;
;;;909            p_tmr->PrevPtr      = (OS_TMR *)0;
;;;910            p_spoke->FirstPtr   = p_tmr;
;;;911            p_spoke->NbrEntries = 1u;
;;;912        } else {
;;;913            p_tmr->Remain  = p_tmr->Match                       /* Compute remaining time for timer                       */
000032  1b09              SUBS     r1,r1,r4
;;;914                           - OSTmrTickCtr;
;;;915            p_tmr1         = p_spoke->FirstPtr;                 /* Point to current first timer in the list               */
000034  61c1              STR      r1,[r0,#0x1c]
;;;916            while (p_tmr1 != (OS_TMR *)0) {
000036  6811              LDR      r1,[r2,#0]
000038  b1d1              CBZ      r1,|L11.112|
                  |L11.58|
;;;917                p_tmr1->Remain = p_tmr1->Match                  /* Compute time remaining of current timer in list        */
00003a  698d              LDR      r5,[r1,#0x18]
00003c  1b2d              SUBS     r5,r5,r4
;;;918                               - OSTmrTickCtr;
;;;919                if (p_tmr->Remain > p_tmr1->Remain) {           /* Do we need to insert AFTER current timer in list?      */
00003e  61cd              STR      r5,[r1,#0x1c]
000040  69c6              LDR      r6,[r0,#0x1c]
000042  42ae              CMP      r6,r5
000044  d90e              BLS      |L11.100|
;;;920                    if (p_tmr1->NextPtr  != (OS_TMR *)0) {      /* Yes, are we pointing at the last timer in the list?    */
000046  690d              LDR      r5,[r1,#0x10]
000048  b145              CBZ      r5,|L11.92|
00004a  4629              MOV      r1,r5
;;;921                        p_tmr1            = p_tmr1->NextPtr;    /* No,  Point to next timer in the list                   */
00004c  e7f5              B        |L11.58|
                  |L11.78|
00004e  6a41              LDR      r1,[r0,#0x24]         ;896
000050  e7e0              B        |L11.20|
                  |L11.82|
000052  6103              STR      r3,[r0,#0x10]         ;909
000054  6143              STR      r3,[r0,#0x14]         ;910
000056  6010              STR      r0,[r2,#0]            ;911
000058  2001              MOVS     r0,#1                 ;911
00005a  e00b              B        |L11.116|
                  |L11.92|
00005c  e9c03104          STRD     r3,r1,[r0,#0x10]      ;911
;;;922                    } else {
;;;923                        p_tmr->NextPtr    = (OS_TMR *)0;
;;;924                        p_tmr->PrevPtr    =  p_tmr1;
;;;925                        p_tmr1->NextPtr   =  p_tmr;             /* Yes, timer to insert is now new last entry in the list */
;;;926                        p_tmr1            = (OS_TMR *)0;        /* Break loop                                             */
000060  6108              STR      r0,[r1,#0x10]
000062  e005              B        |L11.112|
                  |L11.100|
;;;927                    }
;;;928                } else {                                        /* Insert before the current timer                        */
;;;929                    if (p_tmr1->PrevPtr == (OS_TMR *)0) {       /* Are we inserting before the first timer?               */
000064  694c              LDR      r4,[r1,#0x14]
000066  b164              CBZ      r4,|L11.130|
000068  e9c01404          STRD     r1,r4,[r0,#0x10]
;;;930                        p_tmr->PrevPtr    = (OS_TMR *)0;
;;;931                        p_tmr->NextPtr    = p_tmr1;
;;;932                        p_tmr1->PrevPtr   = p_tmr;
;;;933                        p_spoke->FirstPtr = p_tmr;
;;;934                    } else {                                    /* Insert in between 2 timers already in the list         */
;;;935                        p_tmr0            = p_tmr1->PrevPtr;
;;;936                        p_tmr->PrevPtr    = p_tmr0;
;;;937                        p_tmr->NextPtr    = p_tmr1;
;;;938                        p_tmr0->NextPtr   = p_tmr;
;;;939                        p_tmr1->PrevPtr   = p_tmr;
00006c  6120              STR      r0,[r4,#0x10]
00006e  6148              STR      r0,[r1,#0x14]
                  |L11.112|
;;;940                    }
;;;941                    p_tmr1 = (OS_TMR *)0;                       /* Break loop                                             */
;;;942                }
;;;943            }
;;;944            p_spoke->NbrEntries++;
000070  8890              LDRH     r0,[r2,#4]
000072  1c40              ADDS     r0,r0,#1
                  |L11.116|
000074  8090              STRH     r0,[r2,#4]
;;;945        }
;;;946        if (p_spoke->NbrEntriesMax < p_spoke->NbrEntries) {     /* Keep track of maximum number of entries in each spoke  */
000076  88d1              LDRH     r1,[r2,#6]
000078  b280              UXTH     r0,r0
00007a  4281              CMP      r1,r0
00007c  d200              BCS      |L11.128|
;;;947            p_spoke->NbrEntriesMax = p_spoke->NbrEntries;
00007e  80d0              STRH     r0,[r2,#6]
                  |L11.128|
;;;948        }
;;;949    }
000080  bd70              POP      {r4-r6,pc}
                  |L11.130|
000082  e9c01304          STRD     r1,r3,[r0,#0x10]
000086  6148              STR      r0,[r1,#0x14]         ;933
000088  6010              STR      r0,[r2,#0]            ;933
00008a  e7f1              B        |L11.112|
;;;950    
                          ENDP

                  |L11.140|
                          DCD      OSTmrTickCtr
                  |L11.144|
                          DCD      OSCfg_TmrWheelSize
                  |L11.148|
                          DCD      OSCfg_TmrWheel

                          AREA ||i.OS_TmrResetPeak||, CODE, READONLY, ALIGN=2

                  OS_TmrResetPeak PROC
;;;965    
;;;966    void  OS_TmrResetPeak (void)
000000  b510              PUSH     {r4,lr}
;;;967    {
;;;968        OS_TMR_SPOKE     *p_spoke;
;;;969        OS_TMR_SPOKE_IX   i;
;;;970    
;;;971    
;;;972    
;;;973        for (i = 0u; i < OSCfg_TmrWheelSize; i++) {
000002  2000              MOVS     r0,#0
000004  4604              MOV      r4,r0
;;;974            p_spoke                = (OS_TMR_SPOKE *)&OSCfg_TmrWheel[i];
000006  4b06              LDR      r3,|L12.32|
000008  4a06              LDR      r2,|L12.36|
00000a  e004              B        |L12.22|
                  |L12.12|
00000c  eb0301c0          ADD      r1,r3,r0,LSL #3
000010  1c40              ADDS     r0,r0,#1              ;973
;;;975            p_spoke->NbrEntriesMax = (OS_OBJ_QTY    )0u;
000012  80cc              STRH     r4,[r1,#6]
000014  b280              UXTH     r0,r0                 ;973
                  |L12.22|
000016  8811              LDRH     r1,[r2,#0]            ;973  ; OSCfg_TmrWheelSize
000018  4288              CMP      r0,r1                 ;973
00001a  d3f7              BCC      |L12.12|
;;;976        }
;;;977    }
00001c  bd10              POP      {r4,pc}
;;;978    
                          ENDP

00001e  0000              DCW      0x0000
                  |L12.32|
                          DCD      OSCfg_TmrWheel
                  |L12.36|
                          DCD      OSCfg_TmrWheelSize

                          AREA ||i.OS_TmrTask||, CODE, READONLY, ALIGN=2

                  OS_TmrTask PROC
;;;1041   
;;;1042   void  OS_TmrTask (void  *p_arg)
000000  b51c              PUSH     {r2-r4,lr}
;;;1043   {
;;;1044       CPU_BOOLEAN          done;
;;;1045       OS_ERR               err;
;;;1046       OS_TMR_CALLBACK_PTR  p_fnct;
;;;1047       OS_TMR_SPOKE        *p_spoke;
;;;1048       OS_TMR              *p_tmr;
;;;1049       OS_TMR              *p_tmr_next;
;;;1050       OS_TMR_SPOKE_IX      spoke;
;;;1051       CPU_TS               ts;
;;;1052       CPU_TS               ts_start;
;;;1053       CPU_TS               ts_end;
;;;1054   
;;;1055   
;;;1056   
;;;1057       p_arg = p_arg;                                               /* Not using 'p_arg', prevent compiler warning       */
;;;1058       while (DEF_ON) {
;;;1059           (void)OSTaskSemPend((OS_TICK )0,                         /* Wait for signal indicating time to update tmrs    */
;;;1060                               (OS_OPT  )OS_OPT_PEND_BLOCKING,
;;;1061                               (CPU_TS *)&ts,
;;;1062                               (OS_ERR *)&err);
;;;1063   
;;;1064           OSSchedLock(&err);
;;;1065           ts_start = OS_TS_GET();
;;;1066           OSTmrTickCtr++;                                          /* Increment the current time                        */
;;;1067           spoke    = (OS_TMR_SPOKE_IX)(OSTmrTickCtr % OSCfg_TmrWheelSize);
000002  f8df9090          LDR      r9,|L13.148|
;;;1068           p_spoke  = &OSCfg_TmrWheel[spoke];
000006  f8dfa090          LDR      r10,|L13.152|
00000a  4d24              LDR      r5,|L13.156|
;;;1069           p_tmr    = p_spoke->FirstPtr;
;;;1070           done     = DEF_FALSE;
;;;1071           while (done == DEF_FALSE) {
;;;1072               if (p_tmr != (OS_TMR *)0) {
;;;1073                   p_tmr_next = (OS_TMR *)p_tmr->NextPtr;           /* Point to next tmr to update because current ...   */
;;;1074                                                                    /* ... timer could get unlinked from the wheel.      */
;;;1075                   if (OSTmrTickCtr == p_tmr->Match) {              /* Process each timer that expires                   */
;;;1076                       OS_TmrUnlink(p_tmr);                         /* Remove from current wheel spoke                   */
;;;1077                       if (p_tmr->Opt == OS_OPT_TMR_PERIODIC) {
;;;1078                           OS_TmrLink(p_tmr,
;;;1079                                      OS_OPT_LINK_PERIODIC);        /* Recalculate new position of timer in wheel        */
;;;1080                       } else {
;;;1081                           p_tmr->State = OS_TMR_STATE_COMPLETED;   /* Indicate that the timer has completed             */
;;;1082                       }
;;;1083                       p_fnct = p_tmr->CallbackPtr;                 /* Execute callback function if available            */
;;;1084                       if (p_fnct != (OS_TMR_CALLBACK_PTR)0) {
;;;1085                           (*p_fnct)((void *)p_tmr,
;;;1086                                     p_tmr->CallbackPtrArg);
;;;1087                       }
;;;1088                       p_tmr = p_tmr_next;                          /* See if next timer matches                         */
;;;1089                   } else {
;;;1090                       done  = DEF_TRUE;
;;;1091                   }
;;;1092               } else {
;;;1093                   done = DEF_TRUE;
;;;1094               }
;;;1095           }
;;;1096           ts_end = OS_TS_GET() - ts_start;                         /* Measure execution time of timer task              */
;;;1097           OSSchedUnlock(&err);
;;;1098           if (OSTmrTaskTimeMax < ts_end) {
00000c  f8dfb090          LDR      r11,|L13.160|
                  |L13.16|
000010  2100              MOVS     r1,#0                 ;1059
000012  466b              MOV      r3,sp                 ;1059
000014  aa01              ADD      r2,sp,#4              ;1059
000016  4608              MOV      r0,r1                 ;1059
000018  f7fffffe          BL       OSTaskSemPend
00001c  4668              MOV      r0,sp                 ;1064
00001e  f7fffffe          BL       OSSchedLock
000022  f7fffffe          BL       CPU_TS_TmrRd
000026  4606              MOV      r6,r0                 ;1065
000028  6828              LDR      r0,[r5,#0]            ;1066  ; OSTmrTickCtr
00002a  f04f0803          MOV      r8,#3                 ;1081
00002e  1c40              ADDS     r0,r0,#1              ;1066
000030  6028              STR      r0,[r5,#0]            ;1067  ; OSTmrTickCtr
000032  f8b91000          LDRH     r1,[r9,#0]            ;1067  ; OSCfg_TmrWheelSize
000036  fbb0f2f1          UDIV     r2,r0,r1              ;1067
00003a  fb010012          MLS      r0,r1,r2,r0           ;1067
00003e  b280              UXTH     r0,r0                 ;1067
000040  f85a4030          LDR      r4,[r10,r0,LSL #3]    ;1069
                  |L13.68|
000044  b1c4              CBZ      r4,|L13.120|
000046  69a1              LDR      r1,[r4,#0x18]         ;1075
000048  6828              LDR      r0,[r5,#0]            ;1075  ; OSTmrTickCtr
00004a  6927              LDR      r7,[r4,#0x10]         ;1075
00004c  4281              CMP      r1,r0                 ;1075
00004e  d113              BNE      |L13.120|
000050  4620              MOV      r0,r4                 ;1076
000052  f7fffffe          BL       OS_TmrUnlink
000056  8d20              LDRH     r0,[r4,#0x28]         ;1077
000058  2802              CMP      r0,#2                 ;1077
00005a  d008              BEQ      |L13.110|
00005c  f884802a          STRB     r8,[r4,#0x2a]         ;1081
                  |L13.96|
000060  68a2              LDR      r2,[r4,#8]            ;1084
000062  b112              CBZ      r2,|L13.106|
000064  4620              MOV      r0,r4                 ;1085
000066  68e1              LDR      r1,[r4,#0xc]          ;1085
000068  4790              BLX      r2                    ;1085
                  |L13.106|
00006a  463c              MOV      r4,r7                 ;1088
00006c  e7ea              B        |L13.68|
                  |L13.110|
00006e  2101              MOVS     r1,#1                 ;1078
000070  4620              MOV      r0,r4                 ;1078
000072  f7fffffe          BL       OS_TmrLink
000076  e7f3              B        |L13.96|
                  |L13.120|
000078  f7fffffe          BL       CPU_TS_TmrRd
00007c  1b84              SUBS     r4,r0,r6              ;1096
00007e  4668              MOV      r0,sp                 ;1097
000080  f7fffffe          BL       OSSchedUnlock
000084  f8db1000          LDR      r1,[r11,#0]  ; OSTmrTaskTimeMax
000088  42a1              CMP      r1,r4
00008a  d2c1              BCS      |L13.16|
;;;1099               OSTmrTaskTimeMax = ts_end;
00008c  f8cb4000          STR      r4,[r11,#0]  ; OSTmrTaskTimeMax
000090  e7be              B        |L13.16|
;;;1100           }
;;;1101       }
;;;1102   }
;;;1103   
                          ENDP

000092  0000              DCW      0x0000
                  |L13.148|
                          DCD      OSCfg_TmrWheelSize
                  |L13.152|
                          DCD      OSCfg_TmrWheel
                  |L13.156|
                          DCD      OSTmrTickCtr
                  |L13.160|
                          DCD      OSTmrTaskTimeMax

                          AREA ||i.OS_TmrUnlink||, CODE, READONLY, ALIGN=2

                  OS_TmrUnlink PROC
;;;994    
;;;995    void  OS_TmrUnlink (OS_TMR  *p_tmr)
000000  b510              PUSH     {r4,lr}
;;;996    {
;;;997        OS_TMR_SPOKE    *p_spoke;
;;;998        OS_TMR          *p_tmr1;
;;;999        OS_TMR          *p_tmr2;
;;;1000       OS_TMR_SPOKE_IX  spoke;
;;;1001   
;;;1002   
;;;1003   
;;;1004       spoke   = (OS_TMR_SPOKE_IX)(p_tmr->Match % OSCfg_TmrWheelSize);
000002  4a10              LDR      r2,|L14.68|
000004  6981              LDR      r1,[r0,#0x18]
000006  8812              LDRH     r2,[r2,#0]  ; OSCfg_TmrWheelSize
000008  fbb1f3f2          UDIV     r3,r1,r2
00000c  fb021113          MLS      r1,r2,r3,r1
;;;1005       p_spoke = &OSCfg_TmrWheel[spoke];
000010  4a0d              LDR      r2,|L14.72|
000012  b289              UXTH     r1,r1                 ;1004
000014  eb0202c1          ADD      r2,r2,r1,LSL #3
;;;1006   
;;;1007       if (p_spoke->FirstPtr == p_tmr) {                       /* See if timer to remove is at the beginning of list     */
;;;1008           p_tmr1            = (OS_TMR *)p_tmr->NextPtr;
000018  2300              MOVS     r3,#0
00001a  6814              LDR      r4,[r2,#0]
00001c  6901              LDR      r1,[r0,#0x10]         ;1007
00001e  4284              CMP      r4,r0                 ;1007
000020  d103              BNE      |L14.42|
;;;1009           p_spoke->FirstPtr = (OS_TMR *)p_tmr1;
;;;1010           if (p_tmr1 != (OS_TMR *)0) {
000022  6011              STR      r1,[r2,#0]
000024  b129              CBZ      r1,|L14.50|
;;;1011               p_tmr1->PrevPtr = (OS_TMR *)0;
000026  614b              STR      r3,[r1,#0x14]
000028  e003              B        |L14.50|
                  |L14.42|
;;;1012           }
;;;1013       } else {
;;;1014           p_tmr1          = (OS_TMR *)p_tmr->PrevPtr;         /* Remove timer from somewhere in the list                */
;;;1015           p_tmr2          = (OS_TMR *)p_tmr->NextPtr;
;;;1016           p_tmr1->NextPtr = p_tmr2;
00002a  6944              LDR      r4,[r0,#0x14]
;;;1017           if (p_tmr2 != (OS_TMR *)0) {
00002c  6121              STR      r1,[r4,#0x10]
00002e  b101              CBZ      r1,|L14.50|
;;;1018               p_tmr2->PrevPtr = (OS_TMR *)p_tmr1;
000030  614c              STR      r4,[r1,#0x14]
                  |L14.50|
;;;1019           }
;;;1020       }
;;;1021       p_tmr->State   = OS_TMR_STATE_STOPPED;
000032  2101              MOVS     r1,#1
000034  f880102a          STRB     r1,[r0,#0x2a]
;;;1022       p_tmr->NextPtr = (OS_TMR *)0;
;;;1023       p_tmr->PrevPtr = (OS_TMR *)0;
000038  6103              STR      r3,[r0,#0x10]
;;;1024       p_spoke->NbrEntries--;
00003a  6143              STR      r3,[r0,#0x14]
00003c  8890              LDRH     r0,[r2,#4]
00003e  1e40              SUBS     r0,r0,#1
000040  8090              STRH     r0,[r2,#4]
;;;1025   }
000042  bd10              POP      {r4,pc}
;;;1026   
                          ENDP

                  |L14.68|
                          DCD      OSCfg_TmrWheelSize
                  |L14.72|
                          DCD      OSCfg_TmrWheel
