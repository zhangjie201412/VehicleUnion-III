; generated by ARM C/C++ Compiler, 5.02 [Build 28]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\OBJ\flexcan.o --asm_dir=.\List\ --list_dir=.\List\ --depend=..\OBJ\flexcan.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\BSP -I..\CORE -I..\STM32F10x_FWLib\inc -I..\USER -I..\UCOSIII\uC-CPU -I..\UCOSIII\uC-CPU\ARM-Cortex-M3\RealView -I..\UCOSIII\uC-LIB -I..\UCOSIII\uC-LIB\Ports\ARM-Cortex-M3\RealView -I..\UCOSIII\uCOS-III -I..\UCOSIII\uCOS-III\Ports -I..\UCOSIII\uCOS-III\Ports\ARM-Cortex-M3\Generic\RealView -I..\UCOSIII\uCOS-III\Source -I..\UCOSIII\UCOS_BSP -I..\UCOSIII\uCOS_CONFIG -I..\UCOSIII-Task -I..\SYSTEM -I..\BSP\inc -I..\PAL -I..\PAL\vehicles -ID:\Keil_v4\ARM\RV31\INC -ID:\Keil_v4\ARM\CMSIS\Include -ID:\Keil_v4\ARM\Inc\ST\STM32F10x -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=..\OBJ\flexcan.crf ..\BSP\src\flexcan.c]
                          THUMB

                          AREA ||i.USB_LP_CAN1_RX0_IRQHandler||, CODE, READONLY, ALIGN=2

                  USB_LP_CAN1_RX0_IRQHandler PROC
;;;291    
;;;292    void flexcan_rx_callack(void)
000000  4806              LDR      r0,|L1.28|
;;;293    {
000002  b510              PUSH     {r4,lr}
;;;294        if(0 == OSRunning)
000004  7800              LDRB     r0,[r0,#0]  ; OSRunning
000006  2800              CMP      r0,#0                 ;293
000008  d007              BEQ      |L1.26|
;;;295            return;
;;;296        OSIntEnter();
00000a  f7fffffe          BL       OSIntEnter
;;;297        BSP_IntHandlerCAN1_RX0();
00000e  f7fffffe          BL       BSP_IntHandlerCAN1_RX0
;;;298        OSIntExit();
000012  e8bd4010          POP      {r4,lr}
000016  f7ffbffe          B.W      OSIntExit
                  |L1.26|
;;;299    }
00001a  bd10              POP      {r4,pc}
;;;300    
                          ENDP

                  |L1.28|
                          DCD      OSRunning

                          AREA ||i.flexcan_can_enable||, CODE, READONLY, ALIGN=2

                  flexcan_can_enable PROC
;;;121    
;;;122    void flexcan_can_enable(void)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;123    {
;;;124        GPIO_InitTypeDef GPIO_InitStructure;
;;;125    
;;;126        RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
000004  2101              MOVS     r1,#1
000006  2004              MOVS     r0,#4
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;127        RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);
00000c  2101              MOVS     r1,#1
00000e  2010              MOVS     r0,#0x10
000010  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;128    
;;;129        GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;
000014  f44f7480          MOV      r4,#0x100
000018  f8ad4000          STRH     r4,[sp,#0]
;;;130        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
00001c  2510              MOVS     r5,#0x10
;;;131        GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;132        GPIO_Init(GPIOA, &GPIO_InitStructure);
00001e  f8df8040          LDR      r8,|L2.96|
000022  f88d5003          STRB     r5,[sp,#3]            ;130
000026  2603              MOVS     r6,#3                 ;131
000028  f88d6002          STRB     r6,[sp,#2]            ;131
00002c  4669              MOV      r1,sp
00002e  4640              MOV      r0,r8
000030  f7fffffe          BL       GPIO_Init
;;;133    
;;;134        GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
000034  0067              LSLS     r7,r4,#1
000036  f8ad7000          STRH     r7,[sp,#0]
;;;135        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
00003a  f88d5003          STRB     r5,[sp,#3]
;;;136        GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;137        GPIO_Init(GPIOC, &GPIO_InitStructure);
00003e  4d09              LDR      r5,|L2.100|
000040  f88d6002          STRB     r6,[sp,#2]            ;136
000044  4669              MOV      r1,sp
000046  4628              MOV      r0,r5
000048  f7fffffe          BL       GPIO_Init
;;;138    
;;;139        GPIO_ResetBits(GPIOA, GPIO_Pin_8);
00004c  4621              MOV      r1,r4
00004e  4640              MOV      r0,r8
000050  f7fffffe          BL       GPIO_ResetBits
;;;140        GPIO_ResetBits(GPIOC, GPIO_Pin_9);
000054  4639              MOV      r1,r7
000056  4628              MOV      r0,r5
000058  f7fffffe          BL       GPIO_ResetBits
;;;141    }
00005c  e8bd83f8          POP      {r3-r9,pc}
;;;142    
                          ENDP

                  |L2.96|
                          DCD      0x40010800
                  |L2.100|
                          DCD      0x40011000

                          AREA ||i.flexcan_count||, CODE, READONLY, ALIGN=2

                  flexcan_count PROC
;;;244    
;;;245    uint8_t flexcan_count(void)
000000  4905              LDR      r1,|L3.24|
;;;246    {
;;;247        if(w_off >= r_off)
000002  7808              LDRB     r0,[r1,#0]  ; w_off
000004  7849              LDRB     r1,[r1,#1]  ; r_off
000006  4288              CMP      r0,r1
000008  d301              BCC      |L3.14|
;;;248            return w_off - r_off;
00000a  1a40              SUBS     r0,r0,r1
00000c  e002              B        |L3.20|
                  |L3.14|
;;;249        else
;;;250            return RX_PACKAGE_SIZE - r_off + w_off;
00000e  f1c10128          RSB      r1,r1,#0x28
000012  4408              ADD      r0,r0,r1
                  |L3.20|
000014  b2c0              UXTB     r0,r0
;;;251    }
000016  4770              BX       lr
;;;252    
                          ENDP

                  |L3.24|
                          DCD      ||.data||

                          AREA ||i.flexcan_dump||, CODE, READONLY, ALIGN=2

                  flexcan_dump PROC
;;;252    
;;;253    CanRxMsg *flexcan_dump(void)
000000  b510              PUSH     {r4,lr}
;;;254    {
;;;255        CanRxMsg *msg = NULL;
;;;256    
;;;257        flexcan_lock();
000002  f7fffffe          BL       flexcan_lock
;;;258        if(r_off == w_off) {
000006  490c              LDR      r1,|L4.56|
000008  784a              LDRB     r2,[r1,#1]  ; r_off
00000a  7808              LDRB     r0,[r1,#0]  ; w_off
00000c  4282              CMP      r2,r0
00000e  d103              BNE      |L4.24|
;;;259            flexcan_unlock();
000010  f7fffffe          BL       flexcan_unlock
;;;260            return NULL;
000014  2000              MOVS     r0,#0
;;;261        }
;;;262    
;;;263        msg = &g_rxMsg[r_off ++];
;;;264        if(r_off == RX_PACKAGE_SIZE)
;;;265            r_off = 0;
;;;266        flexcan_unlock();
;;;267    
;;;268        return msg;
;;;269    }
000016  bd10              POP      {r4,pc}
                  |L4.24|
000018  eb020082          ADD      r0,r2,r2,LSL #2       ;263
00001c  4b07              LDR      r3,|L4.60|
00001e  1c52              ADDS     r2,r2,#1              ;263
000020  eb030480          ADD      r4,r3,r0,LSL #2       ;263
000024  b2d0              UXTB     r0,r2                 ;263
000026  7048              STRB     r0,[r1,#1]            ;263
000028  2828              CMP      r0,#0x28              ;264
00002a  d101              BNE      |L4.48|
00002c  2000              MOVS     r0,#0                 ;265
00002e  7048              STRB     r0,[r1,#1]            ;265
                  |L4.48|
000030  f7fffffe          BL       flexcan_unlock
000034  4620              MOV      r0,r4                 ;268
000036  bd10              POP      {r4,pc}
;;;270    
                          ENDP

                  |L4.56|
                          DCD      ||.data||
                  |L4.60|
                          DCD      ||.bss||

                          AREA ||i.flexcan_filter||, CODE, READONLY, ALIGN=2

                  flexcan_filter PROC
;;;104    
;;;105    void flexcan_filter(u32 id1, u32 id2, u32 mid1, u32 mid2)
000000  b57f              PUSH     {r0-r6,lr}
;;;106    {
;;;107        CAN_FilterInitTypeDef  CAN_FilterInitStructure;
;;;108    
;;;109        CAN_FilterInitStructure.CAN_FilterNumber=1;
;;;110        CAN_FilterInitStructure.CAN_FilterMode=CAN_FilterMode_IdMask;
;;;111        CAN_FilterInitStructure.CAN_FilterScale=CAN_FilterScale_16bit;
;;;112        CAN_FilterInitStructure.CAN_FilterIdHigh=id1<<5;
000002  f64f74ff          MOV      r4,#0xffff
000006  ea041040          AND      r0,r4,r0,LSL #5
00000a  f8ad0000          STRH     r0,[sp,#0]
;;;113        CAN_FilterInitStructure.CAN_FilterIdLow=id2<<5;
00000e  ea041041          AND      r0,r4,r1,LSL #5
000012  f8ad0002          STRH     r0,[sp,#2]
000016  2601              MOVS     r6,#1                 ;109
000018  2500              MOVS     r5,#0                 ;110
;;;114        CAN_FilterInitStructure.CAN_FilterMaskIdHigh=mid1<<5;
00001a  ea041042          AND      r0,r4,r2,LSL #5
00001e  f8ad0004          STRH     r0,[sp,#4]
000022  f88d600a          STRB     r6,[sp,#0xa]          ;109
;;;115        CAN_FilterInitStructure.CAN_FilterMaskIdLow=mid2<<5;
000026  ea041043          AND      r0,r4,r3,LSL #5
00002a  f88d500b          STRB     r5,[sp,#0xb]          ;110
00002e  f88d500c          STRB     r5,[sp,#0xc]          ;111
000032  f8ad0006          STRH     r0,[sp,#6]
;;;116        CAN_FilterInitStructure.CAN_FilterFIFOAssignment=CAN_FIFO0;
000036  f8ad5008          STRH     r5,[sp,#8]
;;;117        CAN_FilterInitStructure.CAN_FilterActivation=ENABLE;
00003a  f88d600d          STRB     r6,[sp,#0xd]
;;;118        CAN_FilterInit(&CAN_FilterInitStructure);
00003e  4668              MOV      r0,sp
000040  f7fffffe          BL       CAN_FilterInit
;;;119        CAN_ITConfig(CAN1, CAN_IT_FMP0, ENABLE);
000044  2201              MOVS     r2,#1
000046  2102              MOVS     r1,#2
000048  4801              LDR      r0,|L5.80|
00004a  f7fffffe          BL       CAN_ITConfig
;;;120    }
00004e  bd7f              POP      {r0-r6,pc}
;;;121    
                          ENDP

                  |L5.80|
                          DCD      0x40006400

                          AREA ||i.flexcan_gpio_init||, CODE, READONLY, ALIGN=2

                  flexcan_gpio_init PROC
;;;80     
;;;81     void flexcan_gpio_init(void)
000000  b538              PUSH     {r3-r5,lr}
;;;82     {
;;;83         GPIO_InitTypeDef GPIO_InitStructure;
;;;84     
;;;85         RCC_APB2PeriphClockCmd(RCC_APBxPeriph_CAN_IO |
000002  2101              MOVS     r1,#1
000004  2005              MOVS     r0,#5
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;86                 RCC_APB2Periph_AFIO,
;;;87                 ENABLE);
;;;88         RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN1,
00000a  2101              MOVS     r1,#1
00000c  0648              LSLS     r0,r1,#25
00000e  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;89                 ENABLE);
;;;90         GPIO_InitStructure.GPIO_Pin = CAN_RXD;
000012  f44f6000          MOV      r0,#0x800
000016  f8ad0000          STRH     r0,[sp,#0]
;;;91         GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
00001a  2004              MOVS     r0,#4
00001c  f88d0003          STRB     r0,[sp,#3]
;;;92         GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;93         GPIO_Init(CAN_IO, &GPIO_InitStructure);
000020  4d0a              LDR      r5,|L6.76|
000022  2403              MOVS     r4,#3                 ;92
000024  f88d4002          STRB     r4,[sp,#2]            ;92
000028  4669              MOV      r1,sp
00002a  4628              MOV      r0,r5
00002c  f7fffffe          BL       GPIO_Init
;;;94     
;;;95         GPIO_InitStructure.GPIO_Pin = CAN_TXD;
000030  14a8              ASRS     r0,r5,#18
000032  f8ad0000          STRH     r0,[sp,#0]
;;;96         GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
000036  2018              MOVS     r0,#0x18
000038  f88d0003          STRB     r0,[sp,#3]
;;;97         GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00003c  f88d4002          STRB     r4,[sp,#2]
;;;98         GPIO_Init(CAN_IO, &GPIO_InitStructure);
000040  4669              MOV      r1,sp
000042  4628              MOV      r0,r5
000044  f7fffffe          BL       GPIO_Init
;;;99     
;;;100        if(CAN_PinRemap == ENABLE) {
;;;101            GPIO_PinRemapConfig(GPIO_Remap1_CAN1, ENABLE);
;;;102        }
;;;103    }
000048  bd38              POP      {r3-r5,pc}
;;;104    
                          ENDP

00004a  0000              DCW      0x0000
                  |L6.76|
                          DCD      0x40010800

                          AREA ||i.flexcan_init||, CODE, READONLY, ALIGN=2

                  flexcan_init PROC
;;;36     
;;;37     void flexcan_init(u8 velocity)
000000  b57f              PUSH     {r0-r6,lr}
;;;38     {
000002  4605              MOV      r5,r0
;;;39         OS_ERR err;
;;;40         CAN_InitTypeDef CAN_InitStructure;
;;;41     
;;;42         //init for can
;;;43         flexcan_can_enable();
000004  f7fffffe          BL       flexcan_can_enable
;;;44         flexcan_nvic_init();
000008  f7fffffe          BL       flexcan_nvic_init
;;;45         flexcan_gpio_init();
00000c  f7fffffe          BL       flexcan_gpio_init
;;;46     
;;;47         CAN_DeInit(CAN1);
000010  4e1b              LDR      r6,|L7.128|
000012  4630              MOV      r0,r6
000014  f7fffffe          BL       CAN_DeInit
;;;48         CAN_StructInit(&CAN_InitStructure);
000018  4668              MOV      r0,sp
00001a  f7fffffe          BL       CAN_StructInit
;;;49     
;;;50         CAN_InitStructure.CAN_TTCM = DISABLE;
00001e  2400              MOVS     r4,#0
000020  f88d4006          STRB     r4,[sp,#6]
;;;51         CAN_InitStructure.CAN_ABOM = DISABLE;
000024  f88d4007          STRB     r4,[sp,#7]
;;;52         CAN_InitStructure.CAN_AWUM = DISABLE;
;;;53         CAN_InitStructure.CAN_NART = DISABLE;
;;;54         CAN_InitStructure.CAN_RFLM = DISABLE;
;;;55         CAN_InitStructure.CAN_TXFP = DISABLE;
;;;56         CAN_InitStructure.CAN_Mode = CAN_Mode_Normal;
;;;57         CAN_InitStructure.CAN_SJW = CAN_SJW_1tq;
;;;58         CAN_InitStructure.CAN_BS1 = CAN_BS1_11tq;
000028  200a              MOVS     r0,#0xa
00002a  f88d0004          STRB     r0,[sp,#4]
00002e  f88d4002          STRB     r4,[sp,#2]            ;56
;;;59         CAN_InitStructure.CAN_BS2 = CAN_BS2_6tq;
000032  2005              MOVS     r0,#5
000034  f88d4003          STRB     r4,[sp,#3]            ;57
000038  f88d0005          STRB     r0,[sp,#5]
00003c  9402              STR      r4,[sp,#8]            ;56
;;;60         CAN_InitStructure.CAN_Prescaler = velocity;
00003e  f8ad5000          STRH     r5,[sp,#0]
;;;61         CAN_Init(CAN1, &CAN_InitStructure);
000042  4669              MOV      r1,sp
000044  4630              MOV      r0,r6
000046  f7fffffe          BL       CAN_Init
;;;62         w_off = 0;
00004a  480e              LDR      r0,|L7.132|
;;;63         r_off = 0;
;;;64         OSMutexCreate(
00004c  aa03              ADD      r2,sp,#0xc
00004e  a10e              ADR      r1,|L7.136|
000050  7004              STRB     r4,[r0,#0]            ;62
000052  7044              STRB     r4,[r0,#1]            ;63
000054  4810              LDR      r0,|L7.152|
000056  f7fffffe          BL       OSMutexCreate
;;;65                 (OS_MUTEX *)&mFlexcanMutex,
;;;66                 (CPU_CHAR *)"FLEXCAN_MUTEX",
;;;67                 &err
;;;68                 );
;;;69         OSQCreate(
00005a  480f              LDR      r0,|L7.152|
00005c  ab03              ADD      r3,sp,#0xc
00005e  2228              MOVS     r2,#0x28
000060  a10e              ADR      r1,|L7.156|
000062  302c              ADDS     r0,r0,#0x2c
000064  f7fffffe          BL       OSQCreate
;;;70                 (OS_Q *)&mFlexcanQueue,
;;;71                 (CPU_CHAR *)"FLEXCAN_QUEUE",
;;;72                 (OS_MSG_QTY)FLEXCAN_QUEUE_SIZE,
;;;73                 (OS_ERR *)&err
;;;74                 );
;;;75         
;;;76         BSP_IntVectSet(BSP_INT_ID_CAN1_RX0, (CPU_FNCT_VOID)flexcan_recv);
000068  4910              LDR      r1,|L7.172|
00006a  2014              MOVS     r0,#0x14
00006c  f7fffffe          BL       BSP_IntVectSet
;;;77         BSP_IntPrioSet(BSP_INT_ID_CAN1_RX0, 1);
000070  2101              MOVS     r1,#1
000072  2014              MOVS     r0,#0x14
000074  f7fffffe          BL       BSP_IntPrioSet
;;;78         BSP_IntEn(BSP_INT_ID_CAN1_RX0);
000078  2014              MOVS     r0,#0x14
00007a  f7fffffe          BL       BSP_IntEn
;;;79     }
00007e  bd7f              POP      {r0-r6,pc}
;;;80     
                          ENDP

                  |L7.128|
                          DCD      0x40006400
                  |L7.132|
                          DCD      ||.data||
                  |L7.136|
000088  464c4558          DCB      "FLEXCAN_MUTEX",0
00008c  43414e5f
000090  4d555445
000094  5800    
000096  00                DCB      0
000097  00                DCB      0
                  |L7.152|
                          DCD      ||.bss||+0x334
                  |L7.156|
00009c  464c4558          DCB      "FLEXCAN_QUEUE",0
0000a0  43414e5f
0000a4  51554555
0000a8  4500    
0000aa  00                DCB      0
0000ab  00                DCB      0
                  |L7.172|
                          DCD      flexcan_recv

                          AREA ||i.flexcan_ioctl||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                  flexcan_ioctl PROC
;;;156    
;;;157    int8_t flexcan_ioctl(uint8_t dir, CanTxMsg *txMsg, uint16_t rxId, uint8_t rxCount)
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;158    {
;;;159        CanRxMsg *rxMsg;
;;;160        OS_MSG_SIZE size;
;;;161        OS_ERR err;
;;;162    
;;;163        uint8_t i = 0, j = 0;
000004  2700              MOVS     r7,#0
000006  4605              MOV      r5,r0                 ;158
;;;164        int8_t ret = 0;
;;;165        uint8_t exception_count = 0;
;;;166    
;;;167        if(dir & DIR_INPUT) {
;;;168            flexcan_filter(rxId, rxId, rxId | 0xff, rxId | 0xff);
;;;169            filter_id = rxId;
000008  4c52              LDR      r4,|L8.340|
00000a  b085              SUB      sp,sp,#0x14           ;158
00000c  4616              MOV      r6,r2                 ;158
00000e  469a              MOV      r10,r3                ;158
000010  46b8              MOV      r8,r7                 ;164
000012  46bb              MOV      r11,r7                ;165
000014  07c0              LSLS     r0,r0,#31             ;167
000016  46b9              MOV      r9,r7                 ;167
000018  d008              BEQ      |L8.44|
00001a  f04602ff          ORR      r2,r6,#0xff           ;168
00001e  4631              MOV      r1,r6                 ;168
000020  4613              MOV      r3,r2                 ;168
000022  4608              MOV      r0,r1                 ;168
000024  f7fffffe          BL       flexcan_filter
000028  8066              STRH     r6,[r4,#2]
00002a  e007              B        |L8.60|
                  |L8.44|
;;;170        } else {
;;;171            flexcan_filter(0x00, 0x00, 0x00ff, 0x00ff);
00002c  23ff              MOVS     r3,#0xff
00002e  2100              MOVS     r1,#0
000030  461a              MOV      r2,r3
000032  4608              MOV      r0,r1
000034  f7fffffe          BL       flexcan_filter
;;;172            filter_id = 0x00;
000038  f8a49002          STRH     r9,[r4,#2]
                  |L8.60|
;;;173        }
;;;174        if(dir & DIR_OUTPUT) {
00003c  07a8              LSLS     r0,r5,#30
00003e  d502              BPL      |L8.70|
;;;175            flexcan_send_frame(txMsg);
000040  9806              LDR      r0,[sp,#0x18]
000042  f7fffffe          BL       flexcan_send_frame
                  |L8.70|
;;;176    #ifdef FLEXCAN_DEBUG
;;;177            printf("->send %04x ", txMsg->StdId);
;;;178            for(i = 0; i < 8; i++) {
;;;179                printf("%02x ", txMsg->Data[i]);
;;;180            }
;;;181            printf("\r\n");
;;;182    #endif
;;;183        }
;;;184    
;;;185    #if 1
;;;186        if(dir & DIR_INPUT) {
000046  07e8              LSLS     r0,r5,#31
000048  d14a              BNE      |L8.224|
00004a  e04b              B        |L8.228|
                  |L8.76|
;;;187            for(i = 0; i < rxCount; /*i++*/) {
;;;188                rxMsg = OSQPend(
00004c  a902              ADD      r1,sp,#8
00004e  e9cd9100          STRD     r9,r1,[sp,#0]
000052  ab03              ADD      r3,sp,#0xc
000054  2200              MOVS     r2,#0
000056  f2427110          MOV      r1,#0x2710
00005a  483f              LDR      r0,|L8.344|
00005c  f7fffffe          BL       OSQPend
000060  4605              MOV      r5,r0
;;;189                        (OS_Q *)&mFlexcanQueue,
;;;190                        (OS_TICK)(OS_CFG_TICK_RATE_HZ * FLEXCAN_TIMEOUT),
;;;191                        (OS_OPT)OS_OPT_PEND_BLOCKING,
;;;192                        (OS_MSG_SIZE *)&size,
;;;193                        (CPU_TS *)0,
;;;194                        (OS_ERR *)&err
;;;195                        );
;;;196                if(err != OS_ERR_TIMEOUT) {
000062  f8bd0008          LDRH     r0,[sp,#8]
000066  f5a041e4          SUB      r1,r0,#0x7200
00006a  39d9              SUBS     r1,r1,#0xd9
00006c  d05d              BEQ      |L8.298|
;;;197                    flexcan_lock();
00006e  f7fffffe          BL       flexcan_lock
;;;198    #ifdef FLEXCAN_DEBUG
;;;199                    printf("->recv %04x ", rxMsg->StdId);
;;;200                    for(j = 0; j < 8; j++) {
;;;201                        printf("%02x ", rxMsg->Data[j]);
;;;202                    }
;;;203                    printf("\r\n");
;;;204    #endif
;;;205                    //check if the recv id is real rx id
;;;206                    if(rxMsg->StdId == rxId) {
000072  682b              LDR      r3,[r5,#0]
000074  42b3              CMP      r3,r6
000076  d111              BNE      |L8.156|
;;;207                        i ++;
;;;208                    } else {
;;;209                        loge("exception!");
;;;210                        exception_count ++;
;;;211                        if(exception_count > 5) {
;;;212                            ret = -1;
;;;213                            flexcan_unlock();
;;;214                            break;
;;;215                        }
;;;216                        flexcan_unlock();
;;;217                        continue;
;;;218                    }
;;;219                    //write can msg
;;;220                    g_rxMsg[w_off].StdId = rxMsg->StdId;
000078  7820              LDRB     r0,[r4,#0]  ; w_off
00007a  4938              LDR      r1,|L8.348|
00007c  eb000280          ADD      r2,r0,r0,LSL #2
000080  1c7f              ADDS     r7,r7,#1              ;207
000082  f8413022          STR      r3,[r1,r2,LSL #2]
;;;221                    g_rxMsg[w_off].DLC = rxMsg->DLC;
000086  eb010282          ADD      r2,r1,r2,LSL #2
00008a  7aab              LDRB     r3,[r5,#0xa]
00008c  7293              STRB     r3,[r2,#0xa]
;;;222                    for(j = 0; j < rxMsg->DLC; j++) {
;;;223                        g_rxMsg[w_off].Data[j] = rxMsg->Data[j];
00008e  eb000380          ADD      r3,r0,r0,LSL #2
000092  b2ff              UXTB     r7,r7                 ;207
000094  2200              MOVS     r2,#0                 ;222
000096  eb010183          ADD      r1,r1,r3,LSL #2
00009a  e037              B        |L8.268|
                  |L8.156|
00009c  4668              MOV      r0,sp                 ;209
00009e  f7fffffe          BL       OSTimeGet
0000a2  492f              LDR      r1,|L8.352|
0000a4  7809              LDRB     r1,[r1,#0]            ;209  ; DEBUG_MODE
0000a6  07c9              LSLS     r1,r1,#31             ;209
0000a8  d00c              BEQ      |L8.196|
0000aa  f2413188          MOV      r1,#0x1388            ;209
0000ae  fbb0f3f1          UDIV     r3,r0,r1              ;209
0000b2  fb010113          MLS      r1,r1,r3,r0           ;209
0000b6  2005              MOVS     r0,#5                 ;209
0000b8  fbb1f2f0          UDIV     r2,r1,r0              ;209
0000bc  4619              MOV      r1,r3                 ;209
0000be  a029              ADR      r0,|L8.356|
0000c0  f7fffffe          BL       __2printf
                  |L8.196|
0000c4  f10b0001          ADD      r0,r11,#1             ;210
0000c8  f0000bff          AND      r11,r0,#0xff          ;210
0000cc  f1bb0f05          CMP      r11,#5                ;211
0000d0  d904              BLS      |L8.220|
0000d2  f04f38ff          MOV      r8,#0xffffffff        ;212
0000d6  f7fffffe          BL       flexcan_unlock
0000da  e003              B        |L8.228|
                  |L8.220|
0000dc  f7fffffe          BL       flexcan_unlock
                  |L8.224|
0000e0  4557              CMP      r7,r10                ;187
0000e2  d3b3              BCC      |L8.76|
                  |L8.228|
;;;224                    }
;;;225                    w_off ++;
;;;226                    if(w_off == RX_PACKAGE_SIZE) {
;;;227                        w_off = 0;
;;;228                    }
;;;229                    ret ++;
;;;230                    flexcan_unlock();
;;;231                } else {
;;;232                    loge("%s: timeout", __func__);
;;;233                    break;
;;;234                }
;;;235            }
;;;236        }
;;;237    #endif
;;;238        //filter none of can id
;;;239        flexcan_filter(0x00, 0x00, 0x00ff, 0x00ff);
0000e4  23ff              MOVS     r3,#0xff
0000e6  2100              MOVS     r1,#0
0000e8  461a              MOV      r2,r3
0000ea  4608              MOV      r0,r1
0000ec  f7fffffe          BL       flexcan_filter
;;;240        filter_id = 0x00;
0000f0  f8a49002          STRH     r9,[r4,#2]
;;;241    
;;;242        return ret;
;;;243    }
0000f4  b009              ADD      sp,sp,#0x24
0000f6  4640              MOV      r0,r8                 ;242
0000f8  e8bd8ff0          POP      {r4-r11,pc}
                  |L8.252|
0000fc  18ab              ADDS     r3,r5,r2              ;223
0000fe  eb010c02          ADD      r12,r1,r2             ;223
000102  7adb              LDRB     r3,[r3,#0xb]          ;223
000104  1c52              ADDS     r2,r2,#1              ;222
000106  f88c300b          STRB     r3,[r12,#0xb]         ;223
00010a  b2d2              UXTB     r2,r2                 ;222
                  |L8.268|
00010c  7aab              LDRB     r3,[r5,#0xa]          ;222
00010e  4293              CMP      r3,r2                 ;222
000110  d8f4              BHI      |L8.252|
000112  1c40              ADDS     r0,r0,#1              ;225
000114  b2c0              UXTB     r0,r0                 ;225
000116  7020              STRB     r0,[r4,#0]            ;225
000118  2828              CMP      r0,#0x28              ;226
00011a  d101              BNE      |L8.288|
00011c  f8849000          STRB     r9,[r4,#0]            ;227
                  |L8.288|
000120  f1080001          ADD      r0,r8,#1              ;229
000124  fa4ff880          SXTB     r8,r0                 ;229
000128  e7d8              B        |L8.220|
                  |L8.298|
00012a  4668              MOV      r0,sp                 ;232
00012c  f7fffffe          BL       OSTimeGet
000130  490b              LDR      r1,|L8.352|
000132  7809              LDRB     r1,[r1,#0]            ;232  ; DEBUG_MODE
000134  07c9              LSLS     r1,r1,#31             ;232
000136  d0d5              BEQ      |L8.228|
000138  f2413288          MOV      r2,#0x1388            ;232
00013c  fbb0f1f2          UDIV     r1,r0,r2              ;232
000140  fb020211          MLS      r2,r2,r1,r0           ;232
000144  2005              MOVS     r0,#5                 ;232
000146  fbb2f2f0          UDIV     r2,r2,r0              ;232
00014a  4b0d              LDR      r3,|L8.384|
00014c  a00d              ADR      r0,|L8.388|
00014e  f7fffffe          BL       __2printf
000152  e7c7              B        |L8.228|
;;;244    
                          ENDP

                  |L8.340|
                          DCD      ||.data||
                  |L8.344|
                          DCD      ||.bss||+0x360
                  |L8.348|
                          DCD      ||.bss||
                  |L8.352|
                          DCD      DEBUG_MODE
                  |L8.356|
000164  5b253035          DCB      "[%05d.%03d/E]: exception!\r\n",0
000168  642e2530
00016c  33642f45
000170  5d3a2065
000174  78636570
000178  74696f6e
00017c  210d0a00
                  |L8.384|
                          DCD      ||.constdata||
                  |L8.388|
000184  5b253035          DCB      "[%05d.%03d/E]: %s: timeout\r\n",0
000188  642e2530
00018c  33642f45
000190  5d3a2025
000194  733a2074
000198  696d656f
00019c  75740d0a
0001a0  00      
0001a1  00                DCB      0
0001a2  00                DCB      0
0001a3  00                DCB      0

                          AREA ||i.flexcan_lock||, CODE, READONLY, ALIGN=2

                  flexcan_lock PROC
;;;278    
;;;279    void flexcan_lock(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;280    {
;;;281        OS_ERR err;
;;;282        OSMutexPend(&mFlexcanMutex, 0, OS_OPT_PEND_BLOCKING, 0, &err);
000002  a801              ADD      r0,sp,#4
000004  2300              MOVS     r3,#0
000006  9000              STR      r0,[sp,#0]
000008  461a              MOV      r2,r3
00000a  4619              MOV      r1,r3
00000c  4801              LDR      r0,|L9.20|
00000e  f7fffffe          BL       OSMutexPend
;;;283    }
000012  bd1c              POP      {r2-r4,pc}
;;;284    
                          ENDP

                  |L9.20|
                          DCD      ||.bss||+0x334

                          AREA ||i.flexcan_nvic_init||, CODE, READONLY, ALIGN=1

                  flexcan_nvic_init PROC
;;;23     
;;;24     void flexcan_nvic_init(void)
000000  b508              PUSH     {r3,lr}
;;;25     {
;;;26     	NVIC_InitTypeDef  NVIC_InitStructure;
;;;27     
;;;28     	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_3);
000002  f44f6080          MOV      r0,#0x400
000006  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;29     
;;;30     	NVIC_InitStructure.NVIC_IRQChannel = USB_LP_CAN1_RX0_IRQn;
00000a  2014              MOVS     r0,#0x14
00000c  f88d0000          STRB     r0,[sp,#0]
;;;31     	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
000010  2001              MOVS     r0,#1
000012  f88d0001          STRB     r0,[sp,#1]
;;;32     	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000016  2100              MOVS     r1,#0
000018  f88d1002          STRB     r1,[sp,#2]
;;;33     	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00001c  f88d0003          STRB     r0,[sp,#3]
;;;34     	NVIC_Init(&NVIC_InitStructure);
000020  4668              MOV      r0,sp
000022  f7fffffe          BL       NVIC_Init
;;;35     }
000026  bd08              POP      {r3,pc}
;;;36     
                          ENDP


                          AREA ||i.flexcan_recv||, CODE, READONLY, ALIGN=2

                  flexcan_recv PROC
;;;311    
;;;312    void flexcan_recv(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;313    {
;;;314        OS_ERR err;
;;;315    
;;;316        CAN_Receive(CAN1, CAN_FIFO0, &m_rxMsg);
000002  4a0a              LDR      r2,|L11.44|
000004  2100              MOVS     r1,#0
000006  480a              LDR      r0,|L11.48|
000008  f7fffffe          BL       CAN_Receive
;;;317        //flexcan_recv_hook(m_rxMsg.StdId);
;;;318        if(m_rxMsg.StdId == filter_id) {
00000c  4807              LDR      r0,|L11.44|
00000e  4909              LDR      r1,|L11.52|
000010  6800              LDR      r0,[r0,#0]  ; m_rxMsg
000012  8849              LDRH     r1,[r1,#2]  ; filter_id
000014  4288              CMP      r0,r1
000016  d108              BNE      |L11.42|
;;;319            OSQPost(
000018  a801              ADD      r0,sp,#4
00001a  4904              LDR      r1,|L11.44|
00001c  9000              STR      r0,[sp,#0]
00001e  2300              MOVS     r3,#0
000020  2214              MOVS     r2,#0x14
000022  f1010040          ADD      r0,r1,#0x40
000026  f7fffffe          BL       OSQPost
                  |L11.42|
;;;320                    (OS_Q *)&mFlexcanQueue,
;;;321                    (void *)&m_rxMsg,
;;;322                    (OS_MSG_SIZE)sizeof(CanRxMsg),
;;;323                    (OS_OPT)OS_OPT_POST_FIFO,
;;;324                    (OS_ERR *)&err
;;;325                   );
;;;326        } else {
;;;327            //drop
;;;328            //TODO:???
;;;329        }
;;;330    }
00002a  bd1c              POP      {r2-r4,pc}
                          ENDP

                  |L11.44|
                          DCD      ||.bss||+0x320
                  |L11.48|
                          DCD      0x40006400
                  |L11.52|
                          DCD      ||.data||

                          AREA ||i.flexcan_recv_hook||, CODE, READONLY, ALIGN=2

                  flexcan_recv_hook PROC
;;;300    
;;;301    void flexcan_recv_hook(uint16_t id)
000000  4906              LDR      r1,|L12.28|
;;;302    {
000002  b510              PUSH     {r4,lr}
;;;303        //logi("%s: engine_on = %d, engine_ = %04x, id = %04x", __func__,
;;;304        //        vehicle_check_engine(),
;;;305        //        engine_id, id);
;;;306        if(id == engine_id && vehicle_check_engine() == 0) {
000004  8889              LDRH     r1,[r1,#4]  ; engine_id
000006  4288              CMP      r0,r1
000008  d107              BNE      |L12.26|
00000a  f7fffffe          BL       vehicle_check_engine
00000e  2800              CMP      r0,#0
000010  d103              BNE      |L12.26|
;;;307            rf_unlock();
000012  e8bd4010          POP      {r4,lr}
000016  f7ffbffe          B.W      rf_unlock
                  |L12.26|
;;;308        //    logi("%s: rf_unlock()", __func__);
;;;309        }
;;;310    }
00001a  bd10              POP      {r4,pc}
;;;311    
                          ENDP

                  |L12.28|
                          DCD      ||.data||

                          AREA ||i.flexcan_reset||, CODE, READONLY, ALIGN=2

                  flexcan_reset PROC
;;;270    
;;;271    void flexcan_reset(void)
000000  b510              PUSH     {r4,lr}
;;;272    {
;;;273        flexcan_lock();
000002  f7fffffe          BL       flexcan_lock
;;;274        w_off = 0;
000006  4804              LDR      r0,|L13.24|
000008  2100              MOVS     r1,#0
00000a  7001              STRB     r1,[r0,#0]
;;;275        r_off = 0;
00000c  7041              STRB     r1,[r0,#1]
;;;276        flexcan_unlock();
00000e  e8bd4010          POP      {r4,lr}
000012  f7ffbffe          B.W      flexcan_unlock
;;;277    }
;;;278    
                          ENDP

000016  0000              DCW      0x0000
                  |L13.24|
                          DCD      ||.data||

                          AREA ||i.flexcan_send_frame||, CODE, READONLY, ALIGN=2

                  flexcan_send_frame PROC
;;;142    
;;;143    void flexcan_send_frame(CanTxMsg *txMsg)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;144    {
;;;145        u32 count = 0;
000004  2400              MOVS     r4,#0
;;;146        u8 transmitMailBox;
;;;147    
;;;148        txMsg->IDE = CAN_ID_STD;
;;;149        transmitMailBox = CAN_Transmit(CAN1, txMsg);
000006  4e0a              LDR      r6,|L14.48|
000008  7204              STRB     r4,[r0,#8]            ;148
00000a  4601              MOV      r1,r0
00000c  4630              MOV      r0,r6
00000e  f7fffffe          BL       CAN_Transmit
000012  4605              MOV      r5,r0
;;;150        while(CAN_TransmitStatus(CAN1, transmitMailBox) != CANTXOK) {
;;;151            count ++;
;;;152            if(count > 1000000)
000014  4f07              LDR      r7,|L14.52|
000016  e002              B        |L14.30|
                  |L14.24|
000018  1c64              ADDS     r4,r4,#1              ;151
00001a  42bc              CMP      r4,r7
00001c  d805              BHI      |L14.42|
                  |L14.30|
00001e  4629              MOV      r1,r5                 ;150
000020  4630              MOV      r0,r6                 ;150
000022  f7fffffe          BL       CAN_TransmitStatus
000026  2801              CMP      r0,#1                 ;150
000028  d1f6              BNE      |L14.24|
                  |L14.42|
;;;153                break;
;;;154        }
;;;155    }
00002a  e8bd81f0          POP      {r4-r8,pc}
;;;156    
                          ENDP

00002e  0000              DCW      0x0000
                  |L14.48|
                          DCD      0x40006400
                  |L14.52|
                          DCD      0x000f4240

                          AREA ||i.flexcan_set_engine_id||, CODE, READONLY, ALIGN=2

                  flexcan_set_engine_id PROC
;;;18     
;;;19     void flexcan_set_engine_id(uint16_t id)
000000  4901              LDR      r1,|L15.8|
;;;20     {
;;;21         engine_id = id;
000002  8088              STRH     r0,[r1,#4]
;;;22     }
000004  4770              BX       lr
;;;23     
                          ENDP

000006  0000              DCW      0x0000
                  |L15.8|
                          DCD      ||.data||

                          AREA ||i.flexcan_unlock||, CODE, READONLY, ALIGN=2

                  flexcan_unlock PROC
;;;284    
;;;285    void flexcan_unlock(void)
000000  b508              PUSH     {r3,lr}
;;;286    {
;;;287        OS_ERR err;
;;;288    
;;;289        OSMutexPost(&mFlexcanMutex, OS_OPT_POST_NONE, &err);
000002  466a              MOV      r2,sp
000004  2100              MOVS     r1,#0
000006  4802              LDR      r0,|L16.16|
000008  f7fffffe          BL       OSMutexPost
;;;290    }
00000c  bd08              POP      {r3,pc}
;;;291    
                          ENDP

00000e  0000              DCW      0x0000
                  |L16.16|
                          DCD      ||.bss||+0x334

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  g_rxMsg
                          %        800
                  m_rxMsg
                          %        20
                  mFlexcanMutex
                          %        44
                  mFlexcanQueue
                          %        48

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  __func__
000000  666c6578          DCB      0x66,0x6c,0x65,0x78
000004  63616e5f          DCB      0x63,0x61,0x6e,0x5f
000008  696f6374          DCB      0x69,0x6f,0x63,0x74
00000c  6c00              DCB      0x6c,0x00

                          AREA ||.data||, DATA, ALIGN=1

                  w_off
000000  00                DCB      0x00
                  r_off
000001  00                DCB      0x00
                  filter_id
000002  0000              DCW      0x0000
                  engine_id
000004  0000              DCB      0x00,0x00
